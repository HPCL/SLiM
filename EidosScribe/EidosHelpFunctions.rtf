{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Optima-Regular;\f1\fnil\fcharset0 Menlo-Regular;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fnil\fcharset0 Menlo-Italic;\f4\fnil\fcharset0 AppleSymbols;\f5\fswiss\fcharset0 Helvetica;
\f6\fnil\fcharset0 Menlo-Bold;\f7\ftech\fcharset77 Symbol;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red213\green0\blue5;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c87536\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat0\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat0\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab397
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.1.  Math functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (numeric)abs(numeric
\f2 \'a0
\f1 x)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b absolute value
\b0  of 
\f1\fs18 x
\f0\fs20 .  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 integer
\f0\fs20 , the C++ function 
\f1\fs18 llabs()
\f0\fs20  is used and an 
\f1\fs18 integer
\f0\fs20  vector is returned; if 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 float
\f0\fs20 , the C++ function 
\f1\fs18 fabs()
\f0\fs20  is used and a 
\f1\fs18 float
\f0\fs20  vector is returned.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)acos(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b arc cosine
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 acos()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)asin(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b arc sine
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 asin()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)atan(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b arc tangent
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 atan()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)atan2(numeric
\f2 \'a0
\f1 x, numeric
\f2 \'a0
\f1 y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b arc tangent
\b0  of 
\f1\fs18 y/x
\f0\fs20  using the C++ function 
\f1\fs18 atan2()
\f0\fs20 , which uses the signs of both x and y to determine the correct quadrant for the result.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)ceil(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b ceiling
\b0  of 
\f1\fs18 x
\f0\fs20 : the smallest integral value greater than or equal to 
\f1\fs18 x
\f0\fs20 .  Note that the return value is 
\f1\fs18 float
\f0\fs20  even though integral values are guaranteed, because values could be outside of the range representable by 
\f1\fs18 integer
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)cos(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b cosine
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 cos()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric)cumProduct(numeric
\f2 \'a0
\f1 x)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b cumulative product
\b0  of 
\f1\fs18 x
\f0\fs20 : a vector of equal length as 
\f1\fs18 x
\f0\fs20 , in which the element at index 
\f1\fs18 i
\f0\fs20  is equal to the product of the elements of 
\f1\fs18 x
\f0\fs20  across the range 
\f1\fs18 0:i
\f2\fs20 .
\f0   The return type will match the type of 
\f1\fs18 x
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  is of type 
\f1\fs18 integer
\f0\fs20 , but all of the values of the cumulative product vector cannot be represented in that type, an error condition will result.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric)cumSum(numeric
\f2 \'a0
\f1 x)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b cumulative sum
\b0  of 
\f1\fs18 x
\f0\fs20 : a vector of equal length as 
\f1\fs18 x
\f0\fs20 , in which the element at index 
\f1\fs18 i
\f0\fs20  is equal to the sum of the elements of 
\f1\fs18 x
\f0\fs20  across the range 
\f1\fs18 0:i
\f2\fs20 .
\f0   The return type will match the type of 
\f1\fs18 x
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  is of type 
\f1\fs18 integer
\f0\fs20 , but all of the values of the cumulative sum vector cannot be represented in that type, an error condition will result.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)exp(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b base-
\i e
\i0  exponential
\b0  of 
\f1\fs18 x, 
\f3\i e
\f1\i0 \super x
\f0\fs20 \nosupersub ,  using the C++ function 
\f1\fs18 exp()
\f2\fs20 .
\f0   This may be somewhat faster than 
\f1\fs18 E^x
\f0\fs20  for large vectors.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)floor(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b floor
\b0  of 
\f1\fs18 x
\f0\fs20 : the largest integral value less than or equal to 
\f1\fs18 x
\f2\fs20 .
\f0   Note that the return value is 
\f1\fs18 float
\f0\fs20  even though integral values are guaranteed, because values could be outside of the range representable by 
\f1\fs18 integer
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)integerDiv(integer\'a0x, integer\'a0y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the result of 
\b integer division
\b0  of 
\f1\fs18 x
\f0\fs20  by 
\f1\fs18 y
\f0\fs20 .  The 
\f1\fs18 /
\f0\fs20  operator in Eidos always produces a 
\f1\fs18 float
\f0\fs20  result; if you want an 
\f1\fs18 integer
\f0\fs20  result you may use this function instead.  If any value of 
\f1\fs18 y
\f0\fs20  is 
\f1\fs18 0
\f0\fs20 , an error will result.  The parameters 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must either be of equal length, or one of the two must be a singleton.  The precise behavior of 
\f1\fs18 integer
\f0\fs20  division, in terms of how rounding and negative values are handled, may be platform dependent; it will be whatever the C++ behavior of 
\f1\fs18 integer
\f0\fs20  division is on the given platform.  Eidos does not guarantee any particular behavior, so use this function with caution.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)integerMod(integer\'a0x
\f2 ,
\f1  integer\'a0y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the result of 
\b integer modulo
\b0  of 
\f1\fs18 x
\f0\fs20  by 
\f1\fs18 y
\f0\fs20 .  The 
\f1\fs18 %
\f0\fs20  operator in Eidos always produces a 
\f1\fs18 float
\f0\fs20  result; if you want an 
\f1\fs18 integer
\f0\fs20  result you may use this function instead.  If any value of 
\f1\fs18 y
\f0\fs20  is 
\f1\fs18 0
\f0\fs20 , an error will result.  The parameters 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must either be of equal length, or one of the two must be a singleton.  The precise behavior of 
\f1\fs18 integer
\f0\fs20  modulo, in terms of how rounding and negative values are handled, may be platform dependent; it will be whatever the C++ behavior of 
\f1\fs18 integer
\f0\fs20  modulo is on the given platform.  Eidos does not guarantee any particular behavior, so use this function with caution.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical)isFinite(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b finiteness
\b0  of 
\f1\fs18 x
\f0\fs20 : 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  is not 
\f1\fs18 INF
\f0\fs20  or 
\f1\fs18 NAN
\f0\fs20 , 
\f1\fs18 F
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 INF
\f0\fs20  or 
\f1\fs18 NAN
\f2\fs20 .
\f0   
\f1\fs18 INF
\f0\fs20  and 
\f1\fs18 NAN
\f0\fs20  are defined only for type 
\f1\fs18 float
\f0\fs20 , so x is required to be a 
\f1\fs18 float
\f2\fs20 .
\f0   Note that 
\f1\fs18 isFinite()
\f0\fs20  is not the opposite of 
\f1\fs18 isInfinite()
\f0\fs20 , because 
\f1\fs18 NAN
\f0\fs20  is considered to be neither finite nor infinite.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical)isInfinite(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b infiniteness
\b0  of 
\f1\fs18 x
\f0\fs20 : 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 INF
\f0\fs20 , 
\f1\fs18 F
\f0\fs20  otherwise.  
\f1\fs18 INF
\f0\fs20  is defined only for type 
\f1\fs18 float
\f0\fs20 , so x is required to be a 
\f1\fs18 float
\f0\fs20 .  Note that 
\f1\fs18 isInfinite()
\f0\fs20  is not the opposite of 
\f1\fs18 isFinite()
\f0\fs20 , because 
\f1\fs18 NAN
\f0\fs20  is considered to be neither finite nor infinite.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical)isNAN(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b undefinedness
\b0  of 
\f1\fs18 x
\f0\fs20 : 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  is not 
\f1\fs18 NAN
\f0\fs20 , 
\f1\fs18 F
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 NAN
\f2\fs20 .
\f0   
\f1\fs18 NAN
\f0\fs20  is defined only for type 
\f1\fs18 float
\f0\fs20 , so x is required to be a 
\f1\fs18 float
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)log(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b base-
\i e
\i0  logarithm
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 log()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)log10(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b base-10 logarithm
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 log10()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)log2(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b base-2 logarithm
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 log2()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric$)product(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b product
\b0  of 
\f1\fs18 x
\f0\fs20 : the result of multiplying all of the elements of 
\f1\fs18 x
\f0\fs20  together.  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 float
\f0\fs20 , the result will be 
\f1\fs18 float
\f0\fs20 .  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 integer
\f0\fs20 , things are a bit more complex; the result will be 
\f1\fs18 integer
\f0\fs20  if it can fit into the 
\f1\fs18 integer
\f0\fs20  type without overflow issues (including during intermediate stages of the computation), otherwise it will be 
\f1\fs18 float
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)round(float
\f2 \'a0
\f1 x)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b round
\b0  of 
\f1\fs18 x
\f0\fs20 : the integral value nearest to 
\f1\fs18 x
\f0\fs20 , rounding half-way cases away from 
\f1\fs18 0
\f0\fs20  (different from the rounding policy of R, which rounds halfway cases toward the nearest even number).  Note that the return value is 
\f1\fs18 float
\f0\fs20  even though integral values are guaranteed, because values could be outside of the range representable by 
\f1\fs18 integer
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)setDifference(*
\f2 \'a0
\f1 x, *
\f2 \'a0
\f1 y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b set-theoretic (asymmetric) difference
\b0  of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 , denoted 
\f1\fs18 x
\f0\fs20  
\f4 \uc0\u8726 
\f0  
\f1\fs18 y
\f0\fs20 : a vector containing all elements that are in 
\f1\fs18 x
\f0\fs20  but are not in 
\f1\fs18 y
\f0\fs20 .  Duplicate elements will be stripped out, in the same manner as the 
\f1\fs18 unique()
\f0\fs20  function.  The order of elements in the returned vector is arbitrary and should not be relied upon.  The returned vector will be of the same type as 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f2\fs20 ,
\f0  and 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must be of the same type.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)setIntersection(*
\f2 \'a0
\f1 x, *
\f2 \'a0
\f1 y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b set-theoretic intersection
\b0  of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 , denoted 
\f1\fs18 x
\f0\fs20  
\f4 \uc0\u8745 
\f0  
\f1\fs18 y
\f0\fs20 : a vector containing all elements that are in both 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  (but not in 
\i only
\i0  
\f1\fs18 x
\f0\fs20  or 
\f1\fs18 y
\f0\fs20 ).  Duplicate elements will be stripped out, in the same manner as the 
\f1\fs18 unique()
\f0\fs20  function.  The order of elements in the returned vector is arbitrary and should not be relied upon.  The returned vector will be of the same type as 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f2\fs20 ,
\f0  and 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must be of the same type.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)setSymmetricDifference(*
\f2 \'a0
\f1 x, *
\f2 \'a0
\f1 y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b set-theoretic symmetric difference
\b0  of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 , denoted 
\f1\fs18 x
\f0\fs20  
\f4 \uc0\u8710 
\f0  
\f1\fs18 y
\f0\fs20 : a vector containing all elements that are in 
\f1\fs18 x
\f0\fs20  or 
\f1\fs18 y
\f0\fs20 , but not in both.  Duplicate elements will be stripped out, in the same manner as the 
\f1\fs18 unique()
\f0\fs20  function.  The order of elements in the returned vector is arbitrary and should not be relied upon.  The returned vector will be of the same type as 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f2\fs20 ,
\f0  and 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must be of the same type.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)setUnion(*
\f2 \'a0
\f1 x, *
\f2 \'a0
\f1 y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b set-theoretic union
\b0  of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 , denoted 
\f1\fs18 x
\f0\fs20  
\f4 \uc0\u8746 
\f0  
\f1\fs18 y
\f0\fs20 : a vector containing all elements that are in 
\f1\fs18 x
\f0\fs20  and/or 
\f1\fs18 y
\f0\fs20 .  Duplicate elements will be stripped out, in the same manner as the 
\f1\fs18 unique()
\f0\fs20  function.  This function is therefore roughly equivalent to 
\f1\fs18 unique(c(x, y))
\f0\fs20 , but this function will probably be faster.  The order of elements in the returned vector is arbitrary and should not be relied upon.  The returned vector will be of the same type as 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f2\fs20 ,
\f0  and 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must be of the same type.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)sin(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b sine
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 sin()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)sqrt(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b square root
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 sqrt()
\f2\fs20 .
\f0   This may be somewhat faster than 
\f1\fs18 x^0.5
\f0\fs20  for large vectors.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric$)sum(lif\'a0x)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b sum
\b0  of 
\f1\fs18 x
\f0\fs20 : the result of adding all of the elements of 
\f1\fs18 x
\f0\fs20  together.  The unusual parameter type signature 
\f1\fs18 lif
\f0\fs20  indicates that 
\f1\fs18 x
\f0\fs20  can be 
\f1\fs18 logical
\f0\fs20 , 
\f1\fs18 integer
\f0\fs20 , or 
\f1\fs18 float
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 float
\f0\fs20 , the result will be 
\f1\fs18 float
\f0\fs20 .  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 logical
\f0\fs20 , the result will be 
\f1\fs18 integer
\f0\fs20  (the number of 
\f1\fs18 T
\f0\fs20  values in 
\f1\fs18 x
\f0\fs20 , since the 
\f1\fs18 integer
\f0\fs20  values of 
\f1\fs18 T
\f0\fs20  and 
\f1\fs18 F
\f0\fs20  are 
\f1\fs18 1
\f0\fs20  and 
\f1\fs18 0
\f0\fs20  respectively).  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 integer
\f0\fs20 , things are a bit more complex; in this case, the result will be 
\f1\fs18 integer
\f0\fs20  if it can fit into the 
\f1\fs18 integer
\f0\fs20  type without overflow issues (including during intermediate stages of the computation), otherwise it will be 
\f1\fs18 float
\f2\fs20 .
\f0   Note that floating-point roundoff issues can cause this function to return inexact results when 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 float
\f0\fs20  type; this is rarely an issue, but see the 
\f1\fs18 sumExact()
\f0\fs20  function for an alternative.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float$)sumExact(float\'a0x)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b exact sum
\b0  of 
\f1\fs18 x
\f0\fs20 : the exact result of adding all of the elements of 
\f1\fs18 x
\f0\fs20  together.  Unlike the 
\f1\fs18 sum()
\f0\fs20  function, 
\f1\fs18 sumExact()
\f0\fs20  accepts only type 
\f1\fs18 float
\f0\fs20 , since the 
\f1\fs18 sum()
\f0\fs20  function is already exact for other types.  When summing floating-point values \'96 particularly values that vary across many orders of magnitude \'96 the precision limits of floating-point numbers can lead to roundoff errors that cause the 
\f1\fs18 sum()
\f0\fs20  function to return an inexact result.  This function does additional work to ensure that the final result is exact within the possible limits of the 
\f1\fs18 float
\f0\fs20  type; some roundoff may still inevitably occur, in other words, but a more exact result could not be represented with a value of type 
\f1\fs18 float
\f2\fs20 .
\f0   The disadvantage of using this function instead of 
\f1\fs18 sum()
\f0\fs20  is that it is much slower \'96 about 35 times slower, according to one test on Mac OS X 10.2.5, but that will vary across operating systems and hardware.  This function is rarely truly needed, but apart from the performance consequences there is no disadvantage to using it.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)tan(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b tangent
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 tan()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)trunc(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b truncation
\b0  of 
\f1\fs18 x
\f0\fs20 : the integral value nearest to, but no larger in magnitude than, 
\f1\fs18 x
\f0\fs20 .  Note that the return value is 
\f1\fs18 float
\f0\fs20  even though integral values are guaranteed, because values could be outside of the range representable by 
\f1\fs18 integer
\f2\fs20 .\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.2.  Statistics functions\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf2 \expnd0\expndtw0\kerning0
(float$)cor(numeric\'a0x, numeric\'a0y)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns the 
\b sample Pearson\'92s correlation coefficient
\b0  between 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 , usually denoted 
\i r
\i0 .  The sizes of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must be identical.  If 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  have a size of 
\f1\fs18 0
\f0\fs20  or 
\f1\fs18 1
\f0\fs20 , the return value will be 
\f1\fs18 NULL
\f0\fs20 .  At present it is illegal to call 
\f1\fs18 cor()
\f0\fs20  with a matrix or array argument, because the desired behavior in that case has not yet been implemented.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (float$)cov(numeric\'a0x, numeric\'a0y)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns the 
\b corrected sample covariance
\b0  between 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 .  The sizes of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must be identical.  If 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  have a size of 
\f1\fs18 0
\f0\fs20  or 
\f1\fs18 1
\f0\fs20 , the return value will be 
\f1\fs18 NULL
\f0\fs20 .  At present it is illegal to call 
\f1\fs18 cov()
\f0\fs20  with a matrix or array argument, because the desired behavior in that case has not yet been implemented.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (+$)max(+\'a0x, ...)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b maximum
\b0  of 
\f1\fs18 x
\f0\fs20  and the other arguments supplied: the single greatest value contained by all of them.  All of the arguments must be the same type as 
\f1\fs18 x
\f0\fs20 , and the return type will match that of 
\f1\fs18 x
\f2\fs20 .
\f0   If all of the arguments have a size of 
\f1\fs18 0
\f0\fs20 , the return value will be 
\f1\fs18 NULL
\f0\fs20 ; note that this means that 
\f1\fs18 max(x,\'a0max(y))
\f0\fs20  may produce an error, if 
\f1\fs18 max(y)
\f0\fs20  is 
\f1\fs18 NULL
\f0\fs20 , in cases where 
\f1\fs18 max(x,\'a0y)
\f0\fs20  does not.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float$)mean(lif
\f2 \'a0
\f1 x)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b arithmetic mean
\b0  of 
\f1\fs18 x
\f0\fs20 : the sum of 
\f1\fs18 x
\f0\fs20  divided by the number of values in 
\f1\fs18 x
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  has a size of 
\f1\fs18 0
\f0\fs20 , the return value will be 
\f1\fs18 NULL
\f2\fs20 .
\f0 \cf2 \expnd0\expndtw0\kerning0
  The unusual parameter type signature 
\f1\fs18 lif
\f0\fs20  indicates that 
\f1\fs18 x
\f0\fs20  can be 
\f1\fs18 logical
\f0\fs20 , 
\f1\fs18 integer
\f0\fs20 , or 
\f1\fs18 float
\f0\fs20 ; if 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 logical
\f0\fs20 , it is coerced to 
\f1\fs18 integer
\f0\fs20  internally (with 
\f1\fs18 F
\f0\fs20  being 
\f1\fs18 0
\f0\fs20  and 
\f1\fs18 T
\f0\fs20  being 
\f1\fs18 1
\f0\fs20 , as always), allowing 
\f1\fs18 mean()
\f0\fs20  to calculate the average truth value of a 
\f1\fs18 logical
\f0\fs20  vector.
\f2 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (+$)min(+\'a0x, ...)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b minimum
\b0  of 
\f1\fs18 x
\f0\fs20  and the other arguments supplied: the single smallest value contained by all of them.  All of the arguments must be the same type as 
\f1\fs18 x
\f0\fs20 , and the return type will match that of 
\f1\fs18 x
\f2\fs20 .
\f0   If all of the arguments have a size of 
\f1\fs18 0
\f0\fs20 , the return value will be 
\f1\fs18 NULL
\f0\fs20 ; note that this means that 
\f1\fs18 min(x,\'a0min(y))
\f0\fs20  may produce an error, if 
\f1\fs18 min(y)
\f0\fs20  is 
\f1\fs18 NULL
\f0\fs20 , in cases where 
\f1\fs18 min(x,\'a0y)
\f0\fs20  does not.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (+)pmax(+\'a0x, +\'a0y)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b parallel maximum
\b0  of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 : the element-wise maximum for each corresponding pair of elements in 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 .  The type of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must match, and the returned value will have the same type.  In one usage pattern the size of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  match, in which case the returned value will have the same size.  In the other usage pattern either 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  is a singleton, in which case the returned value will match the size of the non-singleton argument, and pairs of elements for comparison will be formed between the singleton\'92s element and each of the elements in the non-singleton.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (+)pmin(+\'a0x, +\'a0y)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b parallel minimum
\b0  of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 : the element-wise minimum for each corresponding pair of elements in 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 .  The type of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must match, and the returned value will have the same type.  In one usage pattern the size of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  match, in which case the returned value will have the same size.  In the other usage pattern either 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  is a singleton, in which case the returned value will match the size of the non-singleton argument, and pairs of elements for comparison will be formed between the singleton\'92s element and each of the elements in the non-singleton.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric)range(numeric
\f2 \'a0
\f1 x, ...)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b range
\b0  of 
\f1\fs18 x
\f0\fs20  and the other arguments supplied: a vector of length 
\f1\fs18 2
\f0\fs20  composed of the minimum and maximum values contained by all of them, at indices 
\f1\fs18 0
\f0\fs20  and 
\f1\fs18 1
\f0\fs20  respectively.  All of the arguments must be the same type as 
\f1\fs18 x
\f0\fs20 , and the return type will match that of 
\f1\fs18 x
\f2\fs20 .
\f0   If all of the arguments have a size of 
\f1\fs18 0
\f0\fs20 , the return value will be 
\f1\fs18 NULL
\f0\fs20 ; note that this means that 
\f1\fs18 range(x,\'a0range(y))
\f0\fs20  may produce an error, if 
\f1\fs18 range(y)
\f0\fs20  is 
\f1\fs18 NULL
\f0\fs20 , in cases where 
\f1\fs18 range(x,\'a0y)
\f0\fs20  does not.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float$)sd(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b corrected sample standard deviation
\b0  of 
\f1\fs18 x
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  has a size of 
\f1\fs18 0
\f0\fs20  or 
\f1\fs18 1
\f2\fs20 ,
\f0  the return value will be 
\f1\fs18 NULL
\f2\fs20 .\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float$)ttest(float
\f2 \'a0
\f1 x, [Nf\'a0y\'a0=\'a0NULL], [Nf$\'a0mu\'a0=\'a0NULL])\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\i p
\i0 -value resulting from running a 
\i t
\i0 -test with the supplied data.  Two types of 
\i t
\f2\i0 -
\f0 tests can be performed.  If 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  are supplied (i.e., 
\f1\fs18 y
\f0\fs20  is non-
\f1\fs18 NULL
\f0\fs20 ), a two-sample unpaired two-sided Welch\'92s 
\i t
\i0 -test is conducted using the samples in 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 , each of which must contain at least two elements.  The null hypothesis for this test is that the two samples are drawn from populations with the same mean.  Other options, such as pooled-variance 
\i t
\i0 -tests, paired 
\i t
\i0 -tests, and one-sided 
\i t
\i0 -tests, are not presently available.  If 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 mu
\f0\fs20  are supplied (i.e., 
\f1\fs18 mu
\f0\fs20  is non-
\f1\fs18 NULL
\f0\fs20 ), a one-sample 
\i t
\i0 -test is conducted in which the null hypothesis is that the sample is drawn from a population with mean 
\f1\fs18 mu
\f2\fs20 .\

\f0 Note that the results from this function are substantially different from those produced by R.  The Eidos 
\f1\fs18 ttest() 
\f0\fs20 function uses uncorrected sample statistics, which means they will be biased for small sample sizes, whereas R probably uses corrected, unbiased sample statistics.  This is an Eidos bug, and might be fixed if anyone complains.  If large sample sizes are used, however, the bias is likely to be small, and uncorrected statistics are simpler and faster to compute.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 \expnd0\expndtw0\kerning0
(float$)var(numeric\'a0x)\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns the 
\b corrected sample variance
\b0  of 
\f1\fs18 x
\f0\fs20 .  If 
\f1\fs18 x
\f0\fs20  has a size of 
\f1\fs18 0
\f0\fs20  or 
\f1\fs18 1
\f0\fs20 , the return value will be 
\f1\fs18 NULL
\f0\fs20 .  This is the square of the standard deviation calculated by 
\f1\fs18 sd()
\f0\fs20 .  At present it is illegal to call 
\f1\fs18 var()
\f0\fs20  with a matrix or array argument, because the desired behavior in that case has not yet been implemented.\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\b\fs22 \cf0 \kerning1\expnd0\expndtw0 3.3.  Distribution drawing and density functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (float)dnorm(float\'a0x, [numeric\'a0mean\'a0=\'a00], [numeric\'a0sd\'a0=\'a01])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\b probability densities for a normal distribution
\b0  at quantiles 
\f1\fs18 x
\f0\fs20  with mean 
\f1\fs18 mean
\f0\fs20  and standard deviation 
\f1\fs18 sd
\f0\fs20 .  The 
\f1\fs18 mean
\f0\fs20  and 
\f1\fs18 sd
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the densities, or they may be vectors of the same length as 
\f1\fs18 x
\f0\fs20 , specifying a value for each density computation.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)rbinom(integer$
\f2 \'a0
\f1 n, integer\'a0size, float\'a0prob)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a binomial distribution
\b0  with a number of trials specified by 
\f1\fs18 size
\f0\fs20  and a probability of success specified by 
\f1\fs18 prob
\f0\fs20 .  The 
\f1\fs18 size
\f0\fs20  and 
\f1\fs18 prob
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 \expnd0\expndtw0\kerning0
(float)rcauchy(integer$\'a0n, [numeric\'a0location\'a0=\'a00], [numeric\'a0scale\'a0=\'a01])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a Cauchy distribution
\b0  with location 
\f1\fs18 location
\f0\fs20  and scale 
\f1\fs18 scale
\f0\fs20 .  The 
\f1\fs18 location
\f0\fs20  and 
\f1\fs18 scale
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (integer)rdunif(integer$\'a0n, [integer\'a0min\'a0=\'a00], [integer\'a0max
\f2 \'a0
\f1 =\'a01])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a discrete uniform distribution
\b0  from 
\f1\fs18 min
\f0\fs20  to 
\f1\fs18 max
\f0\fs20 , inclusive.  The 
\f1\fs18 min
\f0\fs20  and 
\f1\fs18 max
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.  See 
\f1\fs18 runif()
\f0\fs20  for draws from a continuous uniform distribution.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (float)rexp(integer$
\f2 \'a0
\f1 n, [numeric\'a0mu\'a0=\'a01])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from an exponential distribution
\b0  with mean 
\f1\fs18 mu
\f0\fs20  (i.e. rate 
\f1\fs18 1/mu
\f0\fs20 ).  The 
\f1\fs18 mu
\f0\fs20  parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)rgamma(integer$
\f2 \'a0
\f1 n, numeric\'a0mean, numeric\'a0shape)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a gamma distribution
\b0  with mean 
\f1\fs18 mean
\f0\fs20  and shape parameter 
\f1\fs18 shape
\f0\fs20 .  The 
\f1\fs18 mean
\f0\fs20  and 
\f1\fs18 shape
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.  Draws are made from a gamma distribution with probability density 
\f2\i P
\i0 (
\i s
\i0 \'a0|\'a0
\f5\i \uc0\u945 
\f2\i0 ,
\f5\i \uc0\u946 
\f2\i0 )\'a0= [
\f5 \uc0\u915 
\f2 (
\f5\i \uc0\u945 
\f2\i0 )
\f5\i \uc0\u946 \u945 
\f2\i0 ]\super \uc0\u8722 1\nosupersub exp(\uc0\u8722 
\i s
\i0 /
\f5\i \uc0\u946 
\f2\i0 )
\f0 , where 
\f5\i \uc0\u945 
\f0\i0  is the shape parameter 
\f1\fs18 shape
\f0\fs20 , and the mean of the distribution given by 
\f1\fs18 mean
\f0\fs20  is equal to 
\f5\i \uc0\u945 \u946 
\f2\i0 .
\f0   Values of 
\f1\fs18 mean
\f0\fs20  less than zero are allowed, and are equivalent (in principle) to the negation of a draw from a gamma distribution with the same 
\f1\fs18 shape
\f0\fs20  parameter and the negation of the 
\f1\fs18 mean
\f0\fs20  parameter.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)rlnorm(integer$
\f2 \'a0
\f1 n, [numeric\'a0meanlog\'a0=\'a00], [numeric\'a0sdlog\'a0=\'a01])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a lognormal distribution
\b0  with mean 
\f1\fs18 meanlog
\f0\fs20  and standard deviation 
\f1\fs18 sdlog
\f0\fs20 , specified on the log scale.  The 
\f1\fs18 meanlog
\f0\fs20  and 
\f1\fs18 sdlog
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 \expnd0\expndtw0\kerning0
(float)rmvnorm(integer$\'a0n, numeric\'a0mu, numeric\'a0sigma)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns a matrix of 
\f1\fs18 n
\f0\fs20  
\b random draws from a 
\i k
\i0 -dimensional multivariate normal distribution
\b0  with a length 
\i k
\i0  mean vector 
\f1\fs18 mu
\f0\fs20  and a 
\i k
\i0  \'d7 
\i k
\i0  variance-covariance matrix 
\f1\fs18 sigma
\f0\fs20 .  The 
\f1\fs18 mu
\f0\fs20  and 
\f1\fs18 sigma
\f0\fs20  parameters are used for all 
\f1\fs18 n
\f0\fs20  draws.  The draws are returned as a matrix with 
\f1\fs18 n
\f0\fs20  rows (one row per draw) and 
\i k
\i0  columns (one column per dimension).  The number of dimensions 
\i k
\i0  must be at least two; for 
\i k
\i0 =1, use 
\f1\fs18 rnorm()
\f0\fs20 .\
Cholesky decomposition of the variance-covariance matrix 
\f1\fs18 sigma
\f0\fs20  is involved as an internal step, and this requires that 
\f1\fs18 sigma
\f0\fs20  be positive-definite; if it is not, an error will result.  When more than one draw is needed, it is much more efficient to call 
\f1\fs18 rmvnorm()
\f0\fs20  once to generate all of the draws, since the Cholesky decomposition of 
\f1\fs18 sigma
\f0\fs20  can then be done just once.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (float)rnorm(integer$
\f2 \'a0
\f1 n, [numeric\'a0mean\'a0=\'a00], [numeric\'a0sd\'a0=\'a01])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a normal distribution
\b0  with mean 
\f1\fs18 mean
\f0\fs20  and standard deviation 
\f1\fs18 sd
\f0\fs20 .  The 
\f1\fs18 mean
\f0\fs20  and 
\f1\fs18 sd
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)rpois(integer$
\f2 \'a0
\f1 n, numeric\'a0lambda)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a Poisson distribution
\b0  with parameter 
\f1\fs18 lambda
\f0\fs20  (not to be confused with the language concept of a \'93lambda\'94; 
\f1\fs18 lambda
\f0\fs20  here is just the name of a parameter, because the symbol typically used for the parameter of a Poisson distribution is the Greek letter 
\f5 \uc0\u955 
\f0 ).  The 
\f1\fs18 lambda
\f0\fs20  parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)runif(integer$\'a0n, [numeric\'a0min\'a0=\'a00], [numeric\'a0max
\f2 \'a0
\f1 =\'a01])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a continuous uniform distribution
\b0  from 
\f1\fs18 min
\f0\fs20  to 
\f1\fs18 max
\f0\fs20 , inclusive.  The 
\f1\fs18 min
\f0\fs20  and 
\f1\fs18 max
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.  See 
\f1\fs18 rdunif()
\f0\fs20  for draws from a discrete uniform distribution.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (float)rweibull(integer$
\f2 \'a0
\f1 n, numeric\'a0lambda, numeric\'a0k)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a Weibull distribution
\b0  with scale parameter 
\f1\fs18 lambda
\f0\fs20  and shape parameter 
\f1\fs18 k
\f0\fs20 , both greater than zero.  The 
\f1\fs18 lambda
\f0\fs20  and 
\f1\fs18 k
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.  Draws are made from a Weibull distribution with probability distribution 
\f2\i P
\i0 (
\i s
\i0 \'a0|\'a0
\f5\i \uc0\u955 
\f2\i0 ,
\i k
\i0 )\'a0=\'a0(
\i k
\i0  / 
\f5\i \uc0\u955 
\f2 \super k
\i0 \nosupersub )\'a0
\i s\super k
\i0 \uc0\u8722 1\nosupersub \'a0exp(-(
\i s
\i0 /
\f5\i \uc0\u955 
\f2\i0 )
\i \super k
\i0 \nosupersub ).\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.4.  Vector construction functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (*)c(...)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b concatenation
\b0  of all of its parameters into a single vector\cf2 \expnd0\expndtw0\kerning0
, stripped of all matrix/array dimensions (see 
\f1\fs18 rbind()
\f0\fs20  and 
\f1\fs18 cbind()
\f0\fs20  for concatenation that does not strip this information)\cf0 \kerning1\expnd0\expndtw0 .  The parameters will be promoted to the highest type represented among them, and that type will be the return type.  
\f1\fs18 NULL
\f0\fs20  values are ignored; they have no effect on the result.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)float(integer$
\f2 \'a0
\f1 length)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b new 
\f6\fs18 float
\f0\fs20  vector
\b0  of the length specified by 
\f1\fs18 length
\f0\fs20 , filled with 
\f1\fs18 0.0
\f0\fs20  values.  This can be useful for pre-allocating a vector which you then fill with values by subscripting.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)integer(integer$
\f2 \'a0
\f1 length, [integer$\'a0fill1\'a0=\'a00], [integer$\'a0fill2\'a0=\'a01], [Ni\'a0fill2Indices\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b new 
\f6\fs18 integer
\f0\fs20  vector
\b0  of the length specified by 
\f1\fs18 length
\f0\fs20 , filled with 
\f1\fs18 0
\f0\fs20  values by default.  This can be useful for pre-allocating a vector which you then fill with values by subscripting.\
If a value is supplied for 
\f1\fs18 fill1
\f0\fs20 , the new vector will be filled with that value instead of the default of 
\f1\fs18 0
\f2\fs20 .
\f0   Additionally, if a non-
\f1\fs18 NULL
\f0\fs20  vector is supplied for 
\f1\fs18 fill2Indices
\f0\fs20 , the indices specified by 
\f1\fs18 fill2Indices
\f0\fs20  will be filled with the value provided by 
\f1\fs18 fill2
\f2\fs20 .
\f0   For example, given the default values of 
\f1\fs18 0
\f0\fs20  and 
\f1\fs18 1
\f0\fs20  for 
\f1\fs18 fill1
\f0\fs20  and 
\f1\fs18 fill2
\f0\fs20 , the returned vector will contain 
\f1\fs18 1
\f0\fs20  at all positions specified by 
\f1\fs18 fill2Indices
\f0\fs20 , and will contain 
\f1\fs18 0
\f0\fs20  at all other positions.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical)logical(integer$
\f2 \'a0
\f1 length)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b new 
\f6\fs18 logical
\f0\fs20  vector
\b0  of the length specified by 
\f1\fs18 length
\f0\fs20 , filled with 
\f1\fs18 F
\f0\fs20  values.  This can be useful for pre-allocating a vector which you then fill with values by subscripting.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (object<undefined>)object(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b new empty 
\f6\fs18 object
\f0\fs20  vector
\b0 .  Unlike 
\f1\fs18 float()
\f0\fs20 , 
\f1\fs18 integer()
\f0\fs20 , 
\f1\fs18 logical()
\f0\fs20 , and 
\f1\fs18 string()
\f0\fs20 , a length cannot be specified and the new vector contains no elements.  This is because there is no default value for the object type.  Adding to such a vector is typically done with 
\f1\fs18 c()
\f2\fs20 .
\f0   Note that the return value is of type 
\f1\fs18 object<undefined>
\f0\fs20 ; this method creates an 
\f1\fs18 object
\f0\fs20  vector that does not know what element type it contains.  Such 
\f1\fs18 object
\f0\fs20  vectors may be mixed freely with other 
\f1\fs18 object
\f0\fs20  vectors in 
\f1\fs18 c()
\f0\fs20  and similar contexts; the result of such mixing will take its 
\f1\fs18 object
\f0\fs20 -element type from the 
\f1\fs18 object
\f0\fs20  vector with a defined 
\f1\fs18 object
\f0\fs20 -element type (if any).
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)rep(*
\f2 \'a0
\f1 x, integer$
\f2 \'a0
\f1 count)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b repetition
\b0  of 
\f1\fs18 x
\f0\fs20 : the entirety of 
\f1\fs18 x
\f0\fs20  is repeated 
\f1\fs18 count
\f0\fs20  times.  The return type matches the type of 
\f1\fs18 x
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)repEach(*
\f2 \'a0
\f1 x, integer
\f2 \'a0
\f1 count)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b repetition of elements
\b0  of 
\f1\fs18 x
\f0\fs20 : each element of 
\f1\fs18 x
\f0\fs20  is repeated.  If 
\f1\fs18 count
\f0\fs20  is a singleton, it specifies the number of times that each element of 
\f1\fs18 x
\f0\fs20  will be repeated.  Otherwise, the length of 
\f1\fs18 count
\f0\fs20  must be equal to the length of 
\f1\fs18 x
\f0\fs20 ; in this case, each element of 
\f1\fs18 x
\f0\fs20  is repeated a number of times specified by the corresponding value of 
\f1\fs18 count
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)sample(*\'a0x, integer$\'a0size, [logical$
\f2 \'a0
\f1 replace\'a0=\'a0F], [Nif\'a0weights\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 size
\f0\fs20  containing a 
\b sample from the elements of 
\f6\fs18 x
\f0\b0\fs20 .  If 
\f1\fs18 replace
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , sampling is conducted with replacement (the same element may be drawn more than once); if it is 
\f1\fs18 F
\f0\fs20  (the default), then sampling is done without replacement.  A vector of weights may be supplied in the optional parameter 
\f1\fs18 weights
\f0\fs20 ; if not 
\f1\fs18 NULL
\f0\fs20 , it must be equal in size to 
\f1\fs18 x
\f0\fs20 , all weights must be non-negative, and the sum of the weights must be greater than 
\f1\fs18 0
\f0\fs20 .  If 
\f1\fs18 weights
\f0\fs20  is 
\f1\fs18 NULL
\f0\fs20  (the default), then equal weights are used for all elements of 
\f1\fs18 x
\f0\fs20 .  An error occurs if 
\f1\fs18 sample()
\f0\fs20  runs out of viable elements from which to draw; most notably, if sampling is done without replacement then 
\f1\fs18 size
\f0\fs20  must be at most equal to the size of 
\f1\fs18 x
\f0\fs20 , but if weights of zero are supplied then the restriction on 
\f1\fs18 size
\f0\fs20  will be even more stringent.  The draws are obtained from the standard Eidos random number generator, which might be shared with the Context.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric)seq(numeric$
\f2 \'a0
\f1 from, numeric$
\f2 \'a0
\f1 to, [Nif$
\f2 \'a0
\f1 by
\f2 \'a0
\f1 =\'a0NULL], [Ni$
\f2 \'a0
\f1 length\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b sequence
\b0 , starting at 
\f1\fs18 from
\f0\fs20  and proceeding in the direction of 
\f1\fs18 to
\f0\fs20  until the next value in the sequence would fall beyond 
\f1\fs18 to
\f0\fs20 .  If the optional parameters 
\f1\fs18 by
\f0\fs20  and 
\f1\fs18 length
\f0\fs20  are both 
\f1\fs18 NULL
\f0\fs20  (the default), the sequence steps by values of 
\f1\fs18 1
\f0\fs20  or 
\f1\fs18 -1
\f0\fs20  (as needed to proceed in the direction of 
\f1\fs18 to
\f0\fs20 ).  A different step value may be supplied with 
\f1\fs18 by
\f0\fs20 , but must have the necessary sign.  Alternatively, a sequence length may be supplied in 
\f1\fs18 length
\f0\fs20 , in which case the step magnitude will be chosen to produce a sequence of the requested length (with the necessary sign, as before).  If 
\f1\fs18 from
\f0\fs20  and 
\f1\fs18 to
\f0\fs20  are both 
\f1\fs18 integer
\f0\fs20  then the return type will be 
\f1\fs18 integer
\f0\fs20  when possible (but this may not be possible, depending upon values supplied for 
\f1\fs18 by
\f0\fs20  or 
\f1\fs18 length
\f0\fs20 ), otherwise it will be 
\f1\fs18 float
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 \expnd0\expndtw0\kerning0
(integer)seqAlong(*\'a0x)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns an 
\b index sequence along 
\f6\fs18 x
\f0\b0\fs20 , from 
\f1\fs18 0
\f0\fs20  to 
\f1\fs18 size(x) - 1
\f0\fs20 , with a step of 
\f1\fs18 1
\f0\fs20 .  This is a convenience function for easily obtaining a set of indices to address or iterate through a vector.  Any matrix/array dimension information is ignored; the index sequence is suitable for indexing into 
\f1\fs18 x
\f0\fs20  as a vector.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 (integer)seqLen(integer$\'a0length)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns an 
\b index sequence of 
\f6\fs18 length
\f0\b0\fs20 , from 
\f1\fs18 0
\f0\fs20  to 
\f1\fs18 length - 1
\f0\fs20 , with a step of 
\f1\fs18 1
\f0\fs20 ; if 
\f1\fs18 length
\f0\fs20  is 
\f1\fs18 0
\f0\fs20  the sequence will be zero-length.  This is a convenience function for easily obtaining a set of indices to address or iterate through a vector.  Note that when 
\f1\fs18 length
\f0\fs20  is 
\f1\fs18 0
\f0\fs20 , using the sequence operator with 
\f1\fs18 0:(length-1)
\f0\fs20  will produce 
\f1\fs18 0\'a0-1
\f0\fs20 , and calling 
\f1\fs18 seq(a,\'a0b,\'a0length=length)
\f0\fs20  will raise an error, but 
\f1\fs18 seqLen(length)
\f0\fs20  will return 
\f1\fs18 integer(0)
\f0\fs20 , making 
\f1\fs18 seqLen()
\f0\fs20  particularly useful for generating a sequence of a given length that might be zero.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (string)string(integer$
\f2 \'a0
\f1 length)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b new 
\f6\fs18 string
\f0\fs20  vector
\b0  of the length specified by 
\f1\fs18 length
\f0\fs20 , filled with 
\f1\fs18 ""
\f0\fs20  values.  This can be useful for pre-allocating a vector which you then fill with values by subscripting.
\f2 \
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.5.  Value inspection & manipulation functions\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (logical$)all(logical
\f2 \'a0
\f1 x, ...)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\b all values are 
\f6\fs18 T
\f0\b0\fs20  in 
\f1\fs18 x
\f0\fs20  and in any other arguments supplied; if any value is 
\f1\fs18 F
\f0\fs20 , returns 
\f1\fs18 F
\f2\fs20 .
\f0   All arguments must be of 
\f1\fs18 logical
\f0\fs20  type.  If all arguments are zero-length, 
\f1\fs18 T
\f0\fs20  is returned.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)any(logical
\f2 \'a0
\f1 x, ...)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\b any value is 
\f6\fs18 T
\f0\b0\fs20  in 
\f1\fs18 x
\f0\fs20  or in any other arguments supplied; if all values are 
\f1\fs18 F
\f0\fs20 , returns 
\f1\fs18 F
\f2\fs20 .
\f0   All arguments must be of 
\f1\fs18 logical
\f0\fs20  type.  If all arguments are zero-length, 
\f1\fs18 F
\f0\fs20  is returned.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)cat(*
\f2 \'a0
\f1 x, [string$
\f2 \'a0
\f1 sep
\f2 \'a0
\f1 =\'a0" "])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Concatenates output
\b0  to Eidos\'92s output stream, joined together by 
\f1\fs18 sep
\f0\fs20 .  The value 
\f1\fs18 x
\f0\fs20  that is output may be of any type.  A newline is not appended to the output, unlike the behavior of 
\f1\fs18 print()
\f0\fs20 ; if a trailing newline is desired, you can use 
\f1\fs18 "\\n"
\f0\fs20  (or use the 
\f1\fs18 catn()
\f0\fs20  function).  Also unlike 
\f1\fs18 print()
\f0\fs20 , 
\f1\fs18 cat()
\f0\fs20  tends to emit very literal output; 
\f1\fs18 print(logical(0))
\f0\fs20  will emit \'93
\f1\fs18 logical(0)
\f0\fs20 \'94, for example \'96 showing a semantic interpretation of the value \'96 whereas 
\f1\fs18 cat(logical(0))
\f0\fs20  will emit nothing at all, since there are no elements in the value (it is zero-length).  Similarly, 
\f1\fs18 print(NULL)
\f0\fs20  will emit \'93
\f1\fs18 NULL
\f0\fs20 \'94, but 
\f1\fs18 cat(NULL)
\f0\fs20  will emit nothing.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)catn([*
\f2 \'a0
\f1 x
\f2 \'a0
\f1 =\'a0""], [string$
\f2 \'a0
\f1 sep
\f2 \'a0
\f1 =\'a0" "])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Concatenates output (with a trailing newline)
\b0  to Eidos\'92s output stream, joined together by 
\f1\fs18 sep
\f0\fs20 .  The behavior of 
\f1\fs18 catn()
\f0\fs20  is identical to that of 
\f1\fs18 cat()
\f0\fs20 , except that a final newline character is appended to the output for convenience.  For 
\f1\fs18 catn()
\f0\fs20  a default value of 
\f1\fs18 ""
\f0\fs20  is supplied for 
\f1\fs18 x
\f0\fs20 , to allow a simple 
\f1\fs18 catn()
\f0\fs20  call with no parameters to emit a newline.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string)format(string$
\f2 \'a0
\f1 format, numeric\'a0x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\b formatted strings
\b0  generated from 
\f1\fs18 x
\f0\fs20 , based upon the formatting string 
\f1\fs18 format
\f2\fs20 .
\f0   The 
\f1\fs18 format
\f0\fs20  parameter may be any 
\f1\fs18 string
\f0\fs20  value, but must contain exactly one escape sequence beginning with the 
\f1\fs18 %
\f0\fs20  character.  This escape sequence specifies how to format a single value from the vector 
\f1\fs18 x
\f0\fs20 .  The returned vector contains one 
\f1\fs18 string
\f0\fs20  value for each element of 
\f1\fs18 x
\f0\fs20 ; each 
\f1\fs18 string
\f0\fs20  value is identical to the string supplied in 
\f1\fs18 format
\f0\fs20 , except with a formatted version of the corresponding value from 
\f1\fs18 x
\f0\fs20  substituted in place of the escape sequence.\
The syntax for 
\f1\fs18 format
\f0\fs20  is a subset of the standard C/C++ 
\f1\fs18 printf()
\f0\fs20 -style format strings (e.g., http://en.cppreference.com/w/c/io/fprintf).  The escape sequence used to format each value of x is composed of several elements:\
\pard\pardeftab397\li907\fi-187\ri720\sb60\sa60\partightenfactor0
\ls1\ilvl0\cf0 \'96  A 
\f1\fs18 %
\f0\fs20  character at the beginning, initiating the escape sequence (if an actual 
\f1\fs18 %
\f0\fs20  character is desired, rather than an escape sequence, 
\f1\fs18 %%
\f0\fs20  may be used)\
\'96  Optional flags that modify the style of formatting:\
\pard\tx1170\tx1890\pardeftab397\li1890\fi-990\ri720\sb60\sa60\partightenfactor0
\ls2\ilvl0
\f7\fs18 \cf0 \'a5	
\f1 -
\f0\fs20  :	The value is left-justified with the field (as opposed to the default of right-justification).\
\ls2\ilvl0
\f7\fs18 \'a5	
\f1 +
\f0\fs20  :	The sign of the value is always prepended, even if the value is positive (as opposed to the default of appending the sign only if the value is negative).\
\pard\tx1170\tx1890\pardeftab397\li1890\fi-990\ri720\sb60\sa60\partightenfactor0
\ls2\ilvl0
\f7 \cf0 \'a5	
\f0\i space
\i0  :	The value is prepended by a space when a sign is not prepended.  This is ignored if the 
\f1\fs18 +
\f0\fs20  flag is present, since values are then always prepended by a sign.\
\pard\tx1170\tx1890\pardeftab397\li1890\fi-990\ri720\sb60\sa60\partightenfactor0
\ls2\ilvl0
\f7\fs18 \cf0 \'a5	
\f1 #
\f0\fs20  :	An alternative format is used.  For 
\f1\fs18 %o
\f0\fs20 , at least one leading zero is always produced.  For 
\f1\fs18 %x
\f0\fs20  and 
\f1\fs18 %X
\f0\fs20 , 
\f1\fs18 0x
\f0\fs20  or 
\f1\fs18 0X
\f0\fs20  (respectively) is prepended if the value is nonzero.  For 
\f1\fs18 %f
\f0\fs20 , 
\f1\fs18 %F
\f0\fs20 , 
\f1\fs18 %e
\f0\fs20 , 
\f1\fs18 %E
\f0\fs20 , 
\f1\fs18 %g
\f0\fs20 , and 
\f1\fs18 %G
\f0\fs20 , a decimal point is forced even if no zeros follow.\
\ls2\ilvl0
\f7\fs18 \'a5	
\f1 0
\f0\fs20  :	The value is left-justified with the field (as opposed to the default of right-justification)\
\pard\pardeftab397\li907\fi-187\ri720\sb60\sa60\partightenfactor0
\ls3\ilvl0\cf0 \'96  An optional minimum field width, specified as an integer value.  Fields will be padded out to this minimum width.  Padding will be done with space characters by default (or with zeros, if the 
\f1\fs18 0
\f0\fs20  flag is used), on the left by default (or on the right, if the 
\f1\fs18 -
\f0\fs20  flag is used).\
\'96  An optional precision, given as an integer value preceded by a 
\f1\fs18 .
\f0\fs20  character.  If no integer value follows the 
\f1\fs18 .
\f0\fs20  character, a precision of zero will be used.  For integer values of 
\f1\fs18 x
\f0\fs20  (formatted with 
\f1\fs18 %d
\f0\fs20 , 
\f1\fs18 %i
\f0\fs20 , 
\f1\fs18 %o
\f0\fs20 , 
\f1\fs18 %x
\f0\fs20 , or 
\f1\fs18 %X
\f0\fs20 ) the precision specifies the minimum number of digits that will appear (with extra zeros on the left if necessary), with a default precision of 
\f1\fs18 1
\f2\fs20 .
\f0   For float values of 
\f1\fs18 x
\f0\fs20  formatted with 
\f1\fs18 %f
\f0\fs20 , 
\f1\fs18 %F
\f0\fs20 , 
\f1\fs18 %e
\f0\fs20 , 
\f1\fs18 %E
\f0\fs20 , 
\f1\fs18 %g
\f0\fs20 , or 
\f1\fs18 %G
\f0\fs20 , the precision specifies the minimum number of digits that will appear to the right of the decimal point (with extra zeros on the right if necessary), with a default precision of 
\f1\fs18 6
\f2\fs20 .\
\ls3\ilvl0
\f0 \'96  A format specifier.  For 
\f1\fs18 integer
\f0\fs20  values, this may be 
\f1\fs18 %d
\f0\fs20  or 
\f1\fs18 %i
\f0\fs20  (producing base-10 output; there is no difference between the two), 
\f1\fs18 %o
\f0\fs20  (producing base-8 or octal output), 
\f1\fs18 %x
\f0\fs20  (producing base-16 hexadecimal output using lowercase letters), or 
\f1\fs18 %X
\f0\fs20  (producing base-16 hexadecimal output using uppercase letters).  For 
\f1\fs18 float
\f0\fs20  values, this may be 
\f1\fs18 %f
\f0\fs20  or 
\f1\fs18 %F
\f0\fs20  to produce decimal notation (of the form 
\f1\fs18 [\uc0\u8722 ]ddd.ddd
\f0\fs20 ; there is no difference between the two), 
\f1\fs18 %e
\f0\fs20  or 
\f1\fs18 %E
\f0\fs20  to produce scientific notation (of the form 
\f1\fs18 [\uc0\u8722 ]d.ddde\'b1dd
\f0\fs20  or 
\f1\fs18 [\uc0\u8722 ]d.dddE\'b1dd
\f0\fs20 , respectively), or 
\f1\fs18 %g
\f0\fs20  or 
\f1\fs18 %G
\f0\fs20  to produce either decimal notation or scientific notation (using the formatting of 
\f1\fs18 %f
\f0\fs20  / 
\f1\fs18 %e
\f0\fs20  or 
\f1\fs18 %F
\f0\fs20  / 
\f1\fs18 %E
\f0\fs20 , respectively) on a per-value basis, depending upon the range of the value.\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0
\cf0 Note that relative to the standard C/C++ 
\f1\fs18 printf()
\f0\fs20 -style behavior, there are a few differences: (1) only a single escape sequence may be present in the format string, (2) the use of 
\f1\fs18 *
\f0\fs20  to defer field width and precision values to a passed parameter is not supported, (3) only 
\f1\fs18 integer
\f0\fs20  and 
\f1\fs18 float
\f0\fs20  values of 
\f1\fs18 x
\f0\fs20  are supported, (4) only the 
\f1\fs18 %d
\f0\fs20 , 
\f1\fs18 %i
\f0\fs20 , 
\f1\fs18 %o
\f0\fs20 , 
\f1\fs18 %x
\f0\fs20 , 
\f1\fs18 %X
\f0\fs20 , 
\f1\fs18 %f
\f0\fs20 , 
\f1\fs18 %F
\f0\fs20 , 
\f1\fs18 %e
\f0\fs20 , 
\f1\fs18 %E
\f0\fs20 , 
\f1\fs18 %g
\f0\fs20 , and 
\f1\fs18 %G
\f0\fs20  format specifiers are supported, and (5) no length modifiers may be supplied, since Eidos does not support different sizes of the 
\f1\fs18 integer
\f0\fs20  and 
\f1\fs18 float
\f0\fs20  types.  Note also that the Eidos conventions of emitting 
\f1\fs18 INF
\f0\fs20  and 
\f1\fs18 NAN
\f0\fs20  for infinities and Not-A-Number values respectively is not honored by this function; the strings generated for such values are platform-dependent, following the implementation definition of the C++ compiler used to build Eidos, since 
\f1\fs18 format()
\f0\fs20  calls through to 
\f1\fs18 snprintf()
\f0\fs20  to assemble the final string values.\
For example, 
\f1\fs18 format("A number: %+7.2f", c(-4.1, 15.375, 8))
\f0\fs20  will produce a vector with three elements: 
\f1\fs18 "A number:   -4.10" "A number:  +15.38" "A number:   +8.00"
\f2\fs20 .
\f0   The precision of 
\f1\fs18 .2
\f0\fs20  results in two digits after the decimal point, the minimum field width of 
\f1\fs18 7
\f0\fs20  results in padding of the values on the left (with spaces) to a minimum of seven characters, the flag 
\f1\fs18 +
\f0\fs20  causes a sign to be shown on positive values as well as negative values, and the format specifier 
\f1\fs18 f
\f0\fs20  leads to the 
\f1\fs18 float
\f0\fs20  values of 
\f1\fs18 x
\f0\fs20  being formatted in base-10 decimal.  One 
\f1\fs18 string
\f0\fs20  value is produced in the result vector for each value in the parameter 
\f1\fs18 x
\f2\fs20 .
\f0   These values could then be merged into a single string with 
\f1\fs18 paste()
\f0\fs20 , for example, or printed with 
\f1\fs18 print()
\f0\fs20  or 
\f1\fs18 cat()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)identical(*\'a0x, *\'a0y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\f1\fs18 logical
\f0\fs20  value indicating 
\b whether two values are identical
\b0 .  If 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  have exactly the same type and size, and all of their corresponding elements are exactly the same, \cf2 \expnd0\expndtw0\kerning0
and (for matrices and arrays) their dimensions are identical, \cf0 \kerning1\expnd0\expndtw0 this will return 
\f1\fs18 T
\f0\fs20 , otherwise it will return 
\f1\fs18 F
\f0\fs20 .  The test here is for 
\i exact
\i0  equality; an 
\f1\fs18 integer
\f0\fs20  value of 
\f1\fs18 1
\f0\fs20  is not considered identical to a 
\f1\fs18 float
\f0\fs20  value of 
\f1\fs18 1.0
\f0\fs20 , for example.  Elements in 
\f1\fs18 object
\f0\fs20  values must be literally the same element, not simply identical in all of their properties.  Type promotion is never done.  For testing whether two values are the same, this is generally preferable to the use of operator\'a0
\f1\fs18 ==
\f0\fs20  or operator\'a0
\f1\fs18 !=
\f0\fs20 ; see the discussion at section 2.5.1.  Note that 
\f1\fs18 identical(NULL,NULL)
\f0\fs20  is 
\f1\fs18 T
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)ifelse(logical\'a0test, *\'a0trueValues, *\'a0falseValues)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the result of a 
\b vector conditional
\b0  operation: a vector composed of values from 
\f1\fs18 trueValues
\f0\fs20 , for indices where 
\f1\fs18 test
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , and values from 
\f1\fs18 falseValues
\f0\fs20 , for indices where 
\f1\fs18 test
\f0\fs20  is 
\f1\fs18 F
\f0\fs20 .  The lengths of 
\f1\fs18 trueValues
\f0\fs20  and 
\f1\fs18 falseValues
\f0\fs20  must either be equal to 
\f1\fs18 1
\f0\fs20  or to the length of 
\f1\fs18 test
\f0\fs20 ; however, 
\f1\fs18 trueValues
\f0\fs20  and 
\f1\fs18 falseValues
\f0\fs20  don\'92t need to be the same length as each other.  Furthermore, the type of 
\f1\fs18 trueValues
\f0\fs20  and 
\f1\fs18 falseValues
\f0\fs20  must be the same (including, if they are 
\f1\fs18 object
\f0\fs20  type, their element type).  The return will be of the same length as 
\f1\fs18 test
\f0\fs20 , and of the same type as 
\f1\fs18 trueValues
\f0\fs20  and 
\f1\fs18 falseValues
\f0\fs20 .  Each element of the return vector will be taken from the corresponding element of 
\f1\fs18 trueValues
\f0\fs20  if the corresponding element of 
\f1\fs18 test
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , or from the corresponding element of 
\f1\fs18 falseValues
\f0\fs20  if the corresponding element of 
\f1\fs18 test
\f0\fs20  is 
\f1\fs18 F
\f0\fs20 ; if the vector from which the value is to be taken (i.e., 
\f1\fs18 trueValues
\f0\fs20  or 
\f1\fs18 falseValues
\f0\fs20 ) has a length of 
\f1\fs18 1
\f0\fs20 , that single value is used repeatedly, recycling the vector.\cf2 \expnd0\expndtw0\kerning0
  If 
\f1\fs18 test
\f0\fs20 , 
\f1\fs18 trueValues
\f0\fs20 , and/or 
\f1\fs18 falseValues
\f0\fs20  are matrices or arrays, that will be ignored by 
\f1\fs18 ifelse()
\f0\fs20  
\i except
\i0  that the result will be of the same dimensionality as 
\f1\fs18 test
\f0\fs20 .\cf0 \kerning1\expnd0\expndtw0 \
This is quite similar to a function in R of the same name; note, however, that Eidos evaluates all arguments to functions calls immediately, so 
\f1\fs18 trueValues
\f0\fs20  and 
\f1\fs18 falseValues
\f0\fs20  will be evaluated fully regardless of the values in 
\f1\fs18 test
\f0\fs20 , unlike in R.  Value expressions without side effects are therefore recommended.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 \expnd0\expndtw0\kerning0
(integer$)length(*\'a0x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns the 
\b \cf2 size
\b0 \cf2  (e.g., length) of 
\f1\fs18 x
\f0\fs20 : the number of elements contained in 
\f1\fs18 x
\f0\fs20 .  Note that 
\f1\fs18 length()
\f0\fs20  is a synonym for 
\f1\fs18 size()
\f0\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (integer)match(*\'a0x, *\'a0table)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of the 
\b positions of (first) matches
\b0  of 
\f1\fs18 x
\f0\fs20  in 
\f1\fs18 table
\f0\fs20 .  Type promotion is not performed; x and 
\f1\fs18 table
\f0\fs20  must be of the same type.  For each element of 
\f1\fs18 x
\f0\fs20 , the corresponding element in the result will give the position of the first match for that element of 
\f1\fs18 x
\f0\fs20  in 
\f1\fs18 table
\f0\fs20 ; if the element has no match in 
\f1\fs18 table
\f0\fs20 , the element in the result vector will be 
\f1\fs18 -1
\f0\fs20 .  The result is therefore a vector of the same length as 
\f1\fs18 x
\f0\fs20 .  If a 
\f1\fs18 logical
\f0\fs20  result is desired, with 
\f1\fs18 T
\f0\fs20  indicating that a match was found for the corresponding element of 
\f1\fs18 x
\f0\fs20 , use 
\f1\fs18 (match(x, table) >= 0)
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)nchar(string
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of the 
\b number of characters
\b0  in the string-elements of 
\f1\fs18 x
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)order(+\'a0x, [logical$
\f2 \'a0
\f1 ascending
\f2 \'a0
\f1 =\'a0T])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b vector of sorting indices
\b0  for 
\f1\fs18 x
\f0\fs20 : a new 
\f1\fs18 integer
\f0\fs20  vector of the same length as 
\f1\fs18 x
\f0\fs20 , containing the indices into 
\f1\fs18 x
\f0\fs20  that would sort 
\f1\fs18 x
\f0\fs20 .  In other words, 
\f1\fs18 x[order(x)]==sort(x)
\f0\fs20 .  This can be useful for more complex sorting problems, such as sorting several vectors in parallel by a sort order determined by one of the vectors.  If the optional 
\f1\fs18 logical
\f0\fs20  parameter 
\f1\fs18 ascending
\f0\fs20  is 
\f1\fs18 T
\f0\fs20  (the default), then the sorted order will be ascending; if it is 
\f1\fs18 F
\f0\fs20 , the sorted order will be descending.  The ordering is determined according to the same logic as the 
\f1\fs18 <
\f0\fs20  and 
\f1\fs18 >
\f0\fs20  operators in Eidos.  To easily sort vectors in a single step, use 
\f1\fs18 sort()
\f0\fs20  or 
\f1\fs18 sortBy()
\f0\fs20 , for non-
\f1\fs18 object
\f0\fs20  and 
\f1\fs18 object
\f0\fs20  vectors respectively.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)paste(*\'a0x, [string$
\f2 \'a0
\f1 sep
\f2 \'a0
\f1 =\'a0" "])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b joined string
\b0  composed from the 
\f1\fs18 string
\f0\fs20  representations of the elements of 
\f1\fs18 x
\f0\fs20 , joined together by 
\f1\fs18 sep
\f0\fs20 .  Although this function is based upon the R function of the same name, note that it is much simpler and less powerful; in particular, only the elements of a single vector may be joined, rather than the var-args functionality of the R 
\f1\fs18 paste()
\f2\fs20 .
\f0   The string representation used by 
\f1\fs18 paste()
\f0\fs20  is the same as that emitted by 
\f1\fs18 cat()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)paste
\f2 0
\f1 (*\'a0x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b joined string
\b0  composed from the 
\f1\fs18 string
\f0\fs20  representations of the elements of 
\f1\fs18 x
\f0\fs20 , joined together with no separator.  This function is identical to 
\f1\fs18 paste()
\f0\fs20 , except that no separator is used.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)print(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints output
\b0  to Eidos\'92s output stream.  The value 
\f1\fs18 x
\f0\fs20  that is output may be of any type.  A newline is appended to the output.  See 
\f1\fs18 cat()
\f0\fs20  for a discussion of the differences between 
\f1\fs18 print()
\f0\fs20  and 
\f1\fs18 cat()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)rev(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b reverse
\b0  of 
\f1\fs18 x
\f0\fs20 : a new vector with the same elements as 
\f1\fs18 x
\f0\fs20 , but in the opposite order.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer$)size(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b size
\b0  of 
\f1\fs18 x
\f0\fs20 : the number of elements contained in 
\f1\fs18 x
\f2\fs20 .
\f0 \cf2 \expnd0\expndtw0\kerning0
  Note that 
\f1\fs18 length()
\f0\fs20  is a synonym for 
\f1\fs18 size()
\f0\fs20 .
\f2 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (+)sort(+\'a0x, [logical$
\f2 \'a0
\f1 ascending
\f2 \'a0
\f1 =\'a0T])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b sorted copy
\b0  of 
\f1\fs18 x
\f0\fs20 : a new vector with the same elements as 
\f1\fs18 x
\f0\fs20 , but in sorted order.  If the optional 
\f1\fs18 logical
\f0\fs20  parameter 
\f1\fs18 ascending
\f0\fs20  is 
\f1\fs18 T
\f0\fs20  (the default), then the sorted order will be ascending; if it is 
\f1\fs18 F
\f0\fs20 , the sorted order will be descending.  The ordering is determined according to the same logic as the 
\f1\fs18 <
\f0\fs20  and 
\f1\fs18 >
\f0\fs20  operators in Eidos.  To sort an 
\f1\fs18 object
\f0\fs20  vector, use 
\f1\fs18 sortBy()
\f2\fs20 .
\f0   To obtain indices for sorting, use 
\f1\fs18 order()
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (object)sortBy(object\'a0x, string$
\f2 \'a0
\f1 property, [logical$
\f2 \'a0
\f1 ascending
\f2 \'a0
\f1 =\'a0T])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b sorted copy
\b0  of 
\f1\fs18 x
\f0\fs20 : a new vector with the same elements as 
\f1\fs18 x
\f0\fs20 , but in sorted order.  If the optional 
\f1\fs18 logical
\f0\fs20  parameter 
\f1\fs18 ascending
\f0\fs20  is 
\f1\fs18 T
\f0\fs20  (the default), then the sorted order will be ascending; if it is 
\f1\fs18 F
\f0\fs20 , the sorted order will be descending.  The ordering is determined according to the same logic as the 
\f1\fs18 <
\f0\fs20  and 
\f1\fs18 >
\f0\fs20  operators in Eidos.  The 
\f1\fs18 property
\f0\fs20  argument gives the name of the property within the elements of 
\f1\fs18 x
\f0\fs20  according to which sorting should be done.  This must be a simple property name; it cannot be a property path.  For example, to sort a 
\f1\fs18 Mutation
\f0\fs20  vector by the selection coefficients of the mutations, you would simply pass 
\f1\fs18 "selectionCoeff"
\f0\fs20 , including the quotes, for 
\f1\fs18 property
\f2\fs20 .
\f0   To sort a non-
\f1\fs18 object
\f0\fs20  vector, use 
\f1\fs18 sort()
\f0\fs20 .  To obtain indices for sorting, use 
\f1\fs18 order()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)str(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints the structure
\b0  of 
\f1\fs18 x
\f0\fs20 : a summary of its type and the values it contains.  If 
\f1\fs18 x
\f0\fs20  is an 
\f1\fs18 object
\f2\fs20 ,
\f0  note that 
\f1\fs18 str()
\f0\fs20  produces different results from the 
\f1\fs18 str()
\f0\fs20  method of 
\f1\fs18 x
\f0\fs20 ; the 
\f1\fs18 str()
\f0\fs20  function prints the external structure of 
\f1\fs18 x
\f0\fs20  (the fact that it is an object, and the number and type of its elements), whereas the 
\f1\fs18 str()
\f0\fs20  method prints the internal structure of 
\f1\fs18 x
\f0\fs20  (the external structure of all the properties contained by 
\f1\fs18 x
\f0\fs20 ).
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string)strsplit(string$
\f2 \'a0
\f1 x, [string$
\f2 \'a0
\f1 sep
\f2 \'a0
\f1 =\'a0" "])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\b substrings
\b0  of 
\f1\fs18 x
\f0\fs20  that were separated by the separator string 
\f1\fs18 sep
\f0\fs20 .  Every substring defined by an occurrence of the separator is included, and thus zero-length substrings may be returned.  For example, 
\f1\fs18 strsplit(".foo..bar.", ".")
\f0\fs20  returns a string vector containing 
\f1\fs18 ""
\f0\fs20 , 
\f1\fs18 "foo"
\f0\fs20 , 
\f1\fs18 ""
\f0\fs20 , 
\f1\fs18 "bar"
\f0\fs20 , 
\f1\fs18 ""
\f0\fs20 .  In that example, the empty string between 
\f1\fs18 "foo"
\f0\fs20  and 
\f1\fs18 "bar"
\f0\fs20  in the returned vector is present because there were two periods between 
\f1\fs18 foo
\f0\fs20  and 
\f1\fs18 bar
\f0\fs20  in the input string \'96 the empty string is the substring between those two separators.  Note that 
\f1\fs18 paste()
\f0\fs20  performs the inverse operation of 
\f1\fs18 strsplit()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string)substr(string\'a0x, integer\'a0first, [Ni\'a0last\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\b substrings
\b0  extracted from the elements of 
\f1\fs18 x,
\f0\fs20  spanning character position 
\f1\fs18 first
\f0\fs20  to character position 
\f1\fs18 last
\f0\fs20  (inclusive).  Character positions are numbered from 
\f1\fs18 0
\f0\fs20  to 
\f1\fs18 nchar(x)-1
\f0\fs20 .  Positions that fall outside of that range are legal; a substring range that encompasses no characters will produce an empty string.  If 
\f1\fs18 first
\f0\fs20  is greater than 
\f1\fs18 last
\f0\fs20 , an empty string will also result.  If 
\f1\fs18 last
\f0\fs20  is NULL (the default), then the substring will extend to the end of the string.  The parameters 
\f1\fs18 first
\f0\fs20  and 
\f1\fs18 last
\f0\fs20  may either be singletons, specifying a single value to be used for all of the substrings, or they may be vectors of the same length as 
\f1\fs18 x
\f0\fs20 , specifying a value for each substring.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)unique(*\'a0x, [logical$\'a0preserveOrder\'a0=\'a0T])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b unique values
\b0  in 
\f1\fs18 x
\f0\fs20 .  In other words, for each value 
\f1\fs18 k
\f0\fs20  in 
\f1\fs18 x
\f0\fs20  that occurs at least once, the vector returned will contain 
\f1\fs18 k
\f0\fs20  exactly once.  If 
\f1\fs18 preserveOrder
\f0\fs20  is 
\f1\fs18 T
\f0\fs20  (the default), the order of values in 
\f1\fs18 x
\f0\fs20  is preserved, taking the first instance of each value; this is relatively slow, with O(
\i n
\i0 ^2) performance.  If 
\f1\fs18 preserveOrder
\f0\fs20  if 
\f1\fs18 F
\f0\fs20  instead, the order of values in 
\f1\fs18 x
\f0\fs20  is not preserved, and no particular ordering should be relied upon; this is relatively fast, with O(
\i n
\i0  log 
\i n
\i0 ) performance.  This performance difference will only matter for large vectors, however; for most applications the default behavior can be retained whether the order of the result matters or not.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)which(logical
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b indices of 
\f6\fs18 T
\f0\fs20  values
\b0  in 
\f1\fs18 x
\f0\fs20 .  In other words, if an index 
\f1\fs18 k
\f0\fs20  in 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , then the vector returned will contain 
\f1\fs18 k
\f0\fs20 ; if index 
\f1\fs18 k
\f0\fs20  in 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 F
\f0\fs20 , the vector returned will omit 
\f1\fs18 k
\f0\fs20 .  One way to look at this is that it converts from a 
\f1\fs18 logical
\f0\fs20  subsetting vector to an 
\f1\fs18 integer
\f0\fs20  (index-based) subsetting vector, without changing which subset positions would be selected.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)whichMax(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b index of the (first) maximum value
\b0  in 
\f1\fs18 x
\f0\fs20 .  In other words, if 
\f1\fs18 k
\f0\fs20  is equal to the maximum value in 
\f1\fs18 x
\f0\fs20 , then the vector returned will contain the index of the first occurrence of 
\f1\fs18 k
\f0\fs20  in 
\f1\fs18 x
\f2\fs20 .
\f0   If the maximum value is unique, the result is the same as (but more efficient than) the expression 
\f1\fs18 which(x==max(x))
\f0\fs20 , which returns the indices of 
\i all
\i0  of the occurrences of the maximum value in 
\f1\fs18 x
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)whichMin(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b index of the (first) minimum value
\b0  in 
\f1\fs18 x
\f0\fs20 .  In other words, if 
\f1\fs18 k
\f0\fs20  is equal to the minimum value in 
\f1\fs18 x
\f0\fs20 , then the vector returned will contain the index of the first occurrence of 
\f1\fs18 k
\f0\fs20  in 
\f1\fs18 x
\f0\fs20 .  If the minimum value is unique, the result is the same as (but more efficient than) the expression 
\f1\fs18 which(x==min(x))
\f0\fs20 , which returns the indices of 
\i all
\i0  of the occurrences of the minimum value in 
\f1\fs18 x
\f2\fs20 .\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.6.  Value type testing and coercion functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (float)asFloat(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b conversion to 
\f6\fs18 float
\f0\b0\fs20  of 
\f1\fs18 x
\f0\fs20 .  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 string
\f0\fs20  and cannot be converted to 
\f1\fs18 float
\f0\fs20 , Eidos will throw an error.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)asInteger(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b conversion to 
\f6\fs18 integer
\f0\b0\fs20  of 
\f1\fs18 x
\f0\fs20 .  If 
\f1\fs18 x
\f0\fs20  is of type 
\f1\fs18 string
\f0\fs20  or 
\f1\fs18 float
\f0\fs20  and cannot be converted to 
\f1\fs18 integer
\f0\fs20 , Eidos will throw an error.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical)asLogical(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b conversion to 
\f6\fs18 logical
\f0\b0\fs20  of 
\f1\fs18 x
\f0\fs20 .  Recall that in Eidos the empty 
\f1\fs18 string
\f0\fs20  
\f1\fs18 ""
\f0\fs20  is considered 
\f1\fs18 F
\f0\fs20 , and all other 
\f1\fs18 string
\f0\fs20  values are considered 
\f1\fs18 T
\f2\fs20 .
\f0   Converting 
\f1\fs18 INF
\f0\fs20  or 
\f1\fs18 -INF
\f0\fs20  to 
\f1\fs18 logical
\f0\fs20  yields 
\f1\fs18 T
\f0\fs20  (since those values are not equal to zero); converting 
\f1\fs18 NAN
\f0\fs20  to 
\f1\fs18 logical
\f0\fs20  throws an error.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string)asString(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b conversion to 
\f6\fs18 string
\f0\b0\fs20  of 
\f1\fs18 x
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)elementType(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b element type
\b0  of 
\f1\fs18 x
\f0\fs20 , as a 
\f1\fs18 string
\f0\fs20 .  For the non-
\f1\fs18 object
\f0\fs20  types, the element type is the same as the type: 
\f1\fs18 "NULL"
\f0\fs20 , 
\f1\fs18 "logical"
\f0\fs20 , 
\f1\fs18 "integer"
\f0\fs20 , 
\f1\fs18 "float"
\f0\fs20 , or 
\f1\fs18 "string"
\f0\fs20 .  For 
\f1\fs18 object
\f0\fs20  type, however, 
\f1\fs18 elementType()
\f0\fs20  returns the name of the type of element contained by the object, such as 
\f1\fs18 "SLiMSim"
\f0\fs20  or 
\f1\fs18 "Mutation"
\f0\fs20  in the Context of SLiM.  Contrast this with 
\f1\fs18 type()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isFloat(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f6\fs18 float
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isInteger(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f6\fs18 integer
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isLogical(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f6\fs18 logical
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isNULL(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f6\fs18 NULL
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isObject(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f6\fs18 object
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isString(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f6\fs18 string
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)type(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b type
\b0  of 
\f1\fs18 x
\f0\fs20 , as a 
\f1\fs18 string
\f0\fs20 : 
\f1\fs18 "NULL"
\f0\fs20 , 
\f1\fs18 "logical"
\f0\fs20 , 
\f1\fs18 "integer"
\f0\fs20 , 
\f1\fs18 "float"
\f0\fs20 , 
\f1\fs18 "string"
\f0\fs20 , or 
\f1\fs18 "object"
\f0\fs20 .  Contrast this with 
\f1\fs18 elementType()
\f2\fs20 .\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.7.  Matrix and array functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (*)apply(*\'a0x, integer\'a0margin, string$\'a0lambdaSource)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\i\fs20 \cf3 \expnd0\expndtw0\kerning0
Prior to Eidos 1.6 / SLiM 2.6, 
\f3\fs18 sapply()
\f0\fs20  was named 
\f3\fs18 apply()
\f0\fs20 , and this function did not yet exist\

\i0\b \cf2 Applies a block of Eidos code to margins of x
\b0 .  This function is essentially an extension of 
\f1\fs18 sapply()
\f0\fs20  for use with matrices and arrays; it is recommended that you fully understand 
\f1\fs18 sapply()
\f0\fs20  before tackling this function.  As with 
\f1\fs18 sapply()
\f0\fs20 , the lambda specified by 
\f1\fs18 lambdaSource
\f0\fs20  will be executed for subsets of 
\f1\fs18 x
\f0\fs20 , and the results will be concatenated together with type-promotion in the style of 
\f1\fs18 c()
\f0\fs20  to produce a result.  Unlike 
\f1\fs18 sapply()
\f0\fs20 , however, the subsets of 
\f1\fs18 x
\f0\fs20  used might be rows, columns, or higher-dimensional slices of 
\f1\fs18 x
\f0\fs20 , rather than just single elements, depending upon the value of 
\f1\fs18 margin
\f0\fs20 .  For 
\f1\fs18 apply()
\f0\fs20 , 
\f1\fs18 x
\f0\fs20  must be a matrix or array (see section 2.9).  The 
\f1\fs18 apply()
\f0\fs20  function in Eidos is patterned directly after the 
\f1\fs18 apply()
\f0\fs20  function in R, and should behave identically, except that dimension indices in Eidos are zero-based whereas in R they are one-based.\
The 
\f1\fs18 margin
\f0\fs20  parameter gives the indices of dimensions of 
\f1\fs18 x
\f0\fs20  that will be iterated over when assembling values to supply to lambdaSource.  If 
\f1\fs18 x
\f0\fs20  is a matrix it has two dimensions: rows, of dimension index 
\f1\fs18 0
\f0\fs20 , and columns, of dimension index 
\f1\fs18 1
\f0\fs20 .  These are the indices of the dimension sizes returned by 
\f1\fs18 dim()
\f0\fs20 ; 
\f1\fs18 dim(x)[0]
\f0\fs20  gives the number of rows of 
\f1\fs18 x
\f0\fs20 , and 
\f1\fs18 dim(x)[1]
\f0\fs20  gives the number of columns.  These dimension indices are also apparent when subsetting 
\f1\fs18 x
\f0\fs20 ; a subset index in position 
\f1\fs18 0
\f0\fs20 , such as 
\f1\fs18 x[m,]
\f0\fs20 , gives row 
\f1\fs18 m
\f0\fs20  of 
\f1\fs18 x
\f0\fs20 , whereas a subset index in position 
\f1\fs18 1
\f0\fs20 , such as 
\f1\fs18 x[,n]
\f0\fs20 , gives column 
\f1\fs18 n
\f0\fs20  of 
\f1\fs18 x
\f0\fs20 .  In the same manner, supplying 
\f1\fs18 0
\f0\fs20  for 
\f1\fs18 margin
\f0\fs20  specifies that subsets of 
\f1\fs18 x
\f0\fs20  from 
\f1\fs18 x[0,]
\f0\fs20  to 
\f1\fs18 x[m,]
\f0\fs20  should be \'93passed\'94 to 
\f1\fs18 lambdaSource
\f0\fs20 , through the 
\f1\fs18 applyValue
\f0\fs20  \'93parameter\'94; dimension 
\f1\fs18 0
\f0\fs20  is iterated over, whereas dimension 
\f1\fs18 1
\f0\fs20  is taken in aggregate since it is not included in 
\f1\fs18 margin
\f0\fs20 .  The final effect of this is that whole rows of 
\f1\fs18 x
\f0\fs20  are passed to 
\f1\fs18 lambdaSource
\f0\fs20  through 
\f1\fs18 applyValue
\f0\fs20 .  Similarly, 
\f1\fs18 margin=1
\f0\fs20  would specify that subsets of 
\f1\fs18 x
\f0\fs20  from 
\f1\fs18 x[,0]
\f0\fs20  to 
\f1\fs18 x[,n]
\f0\fs20  should be passed to 
\f1\fs18 lambdaSource
\f0\fs20 , resulting in whole columns being passed.  Specifying 
\f1\fs18 margin=c(0,1)
\f0\fs20  would indicate that dimensions 
\f1\fs18 0
\f0\fs20  and 
\f1\fs18 1
\f0\fs20  should both be iterated over (dimension 
\f1\fs18 0
\f0\fs20  more rapidly), so for a matrix each each individual value of 
\f1\fs18 x
\f0\fs20  would be passed to l
\f1\fs18 ambdaSource
\f0\fs20 .  Specifying 
\f1\fs18 margin=c(1,0)
\f0\fs20  would similarly iterate over both dimensions, but dimension 
\f1\fs18 1
\f0\fs20  more rapidly; the traversal order would therefore be different, and the dimensionality of the result would also differ (see below).  For higher-dimensional arrays dimension indices beyond 
\f1\fs18 1
\f0\fs20  exist, and so 
\f1\fs18 margin=c(0,1)
\f0\fs20  or 
\f1\fs18 margin=c(1,0)
\f0\fs20  would provide slices of 
\f1\fs18 x
\f0\fs20  to 
\f1\fs18 lambdaSource
\f0\fs20 , each slice having a specific row and column index.  Slices are generated by subsetting in the same way as operator 
\f1\fs18 []
\f0\fs20 , but additionally, redundant dimensions are dropped as by 
\f1\fs18 drop()
\f0\fs20 .\
The return value from 
\f1\fs18 apply()
\f0\fs20  is built up from the type-promoted concatenated results, as if by the 
\f1\fs18 c()
\f0\fs20  function, from the iterated execution of 
\f1\fs18 lambdaSource
\f0\fs20 ; the only question is what dimensional structure is imposed upon that vector of values.  If the results from 
\f1\fs18 lambdaSource
\f0\fs20  are not of a consistent length, or are of length zero, then the concatenated results are returned as a plain vector.  If all results are of length 
\f1\fs18 n > 1
\f0\fs20 , the return value is an array of dimensions 
\f1\fs18 c(n, dim(x)[margin]);
\f0\fs20  in other words, each 
\f1\fs18 n
\f0\fs20 -vector provides the lowest dimension of the result, and the sizes of the marginal dimensions are imposed upon the data above that.  If all results are of length 
\f1\fs18 n == 1
\f0\fs20 , then if a single margin was specified the result is a vector (of length equal to the size of that marginal dimension), or if more than one margin was specified the result is an array of dimension 
\f1\fs18 dim(x)[margin]
\f0\fs20 ; in other words, the sizes of the marginal dimensions are imposed upon the data.  Since 
\f1\fs18 apply()
\f0\fs20  iterates over the marginal dimensions in the same manner, these structures follows the structure of the data.\
The above explanation may not be entirely clear, so let\'92s look at an example.  If 
\f1\fs18 x
\f0\fs20  is a matrix with two rows and three columns, such as defined by 
\f1\fs18 x = matrix(1:6, nrow=2);
\f0\fs20 , then executing 
\f1\fs18 apply(x,\'a00,\'a0"sum(applyValue);");
\f0\fs20  would cause each row of 
\f1\fs18 x
\f0\fs20  to be supplied to the lambda through 
\f1\fs18 applyValue
\f0\fs20 , and the values in each row would thus be summed to produce 
\f1\fs18 9 12
\f0\fs20  as a result.  The call 
\f1\fs18 apply(x,\'a01,\'a0"sum(applyValue);");
\f0\fs20  would instead sum columns of 
\f1\fs18 x
\f0\fs20 , producing 
\f1\fs18 3 7 11
\f0\fs20  as a result.  Now consider using 
\f1\fs18 range()
\f0\fs20  rather than 
\f1\fs18 sum()
\f0\fs20  in the lambda, thus producing two values for each row or column.  The call 
\f1\fs18 apply(x,\'a00,\'a0"range(applyValue);");
\f0\fs20  produces a result of 
\f1\fs18 matrix(c(1,5,2,6), nrow=2)
\f0\fs20 , with the range of the first row of 
\f1\fs18 x
\f0\fs20 , 1\'965, in the first column of the result, and the range of the second row of 
\f1\fs18 x
\f0\fs20 , 2\'966, in the second column.  Although visualization becomes more difficult, these same patterns extend to higher dimensions and arbitrary margins of 
\f1\fs18 x
\f0\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (*)array(*\'a0data, integer\'a0dim)
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 \expnd0\expndtw0\kerning0
Creates a new array
\b0  from the data specified by 
\f1\fs18 data
\f0\fs20 , with the dimension sizes specified by 
\f1\fs18 dim
\f0\fs20 .  The first dimension size in 
\f1\fs18 dim
\f0\fs20  is the number of rows, and the second is the number of columns; further entries specify the sizes of higher-order dimensions.  As many dimensions may be specified as desired, but with a minimum of two dimensions.  An array with two dimensions is a matrix (by definition); note that 
\f1\fs18 matrix()
\f0\fs20  may provide a more convenient way to make a new matrix.  Each dimension must be of size 
\f1\fs18 1
\f0\fs20  or greater; 
\f1\fs18 0
\f0\fs20 -size dimensions are not allowed.\
The elements of 
\f1\fs18 data
\f0\fs20  are used to populate the new array; the size of 
\f1\fs18 data
\f0\fs20  must therefore be equal to the size of the new array, which is the product of all the values in 
\f1\fs18 dim
\f0\fs20 .  The new array will be filled in dimension order: one element in each row until a column is filled, then on to the next column in the same manner until all columns are filled, and then onward into the higher-order dimensions in the same manner.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (*)cbind(...)
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 \expnd0\expndtw0\kerning0
Combines vectors or matrices by column
\b0  to produce a single matrix.  The parameters must be vectors (which are interpreted by 
\f1\fs18 cbind()
\f0\fs20  as if they were one-column matrices) or matrices.  They must be of the same type, of the same class if they are of type 
\f1\fs18 object
\f0\fs20 , and have the same number of rows.  If these conditions are met, the result is a single matrix with the parameters joined together, left to right.  Parameters may instead be 
\f1\fs18 NULL
\f0\fs20 , in which case they are ignored; or if all parameters are 
\f1\fs18 NULL
\f0\fs20 , the result is 
\f1\fs18 NULL
\f0\fs20 .  A sequence of vectors, matrices, and 
\f1\fs18 NULL
\f0\fs20 s may thus be concatenated with the 
\f1\fs18 NULL
\f0\fs20  values removed, analogous to 
\f1\fs18 c()
\f0\fs20 .  Calling 
\f1\fs18 cbind(x)
\f0\fs20  is an easy way to create a one-column matrix from a vector.\
To combine vectors or matrices by row instead, see 
\f1\fs18 rbind()
\f0\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (integer)dim(*\'a0x)
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns the dimensions
\b0  of matrix or array 
\f1\fs18 x
\f0\fs20 .  The first dimension value is the number of rows, the second is the number of columns, and further values indicate the sizes of higher-order dimensions, identically to how dimensions are supplied to 
\f1\fs18 array()
\f0\fs20 .  
\f1\fs18 NULL
\f0\fs20  is returned if 
\f1\fs18 x
\f0\fs20  is not a matrix or array.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (*)drop(*\'a0x)
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns the result of dropping redundant dimensions
\b0  from matrix or array 
\f1\fs18 x
\f0\fs20 .  Redundant dimensions are those with a size of exactly 1.  Non-redundant dimensions are retained.  If only one non-redundant dimension is present, the result is a vector; if more than one non-redundant dimension is present, the result will be a matrix or array.  If 
\f1\fs18 x
\f0\fs20  is not a matrix or array, it is returned unmodified.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (*)matrix(*\'a0data, [Ni$\'a0nrow\'a0=\'a0NULL], [Ni$\'a0ncol\'a0=\'a0NULL], [logical$\'a0byrow\'a0=\'a0F])
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 \expnd0\expndtw0\kerning0
Creates a new matrix
\b0  from the data specified by 
\f1\fs18 data
\f0\fs20 .  By default this creates a one-column matrix.  If non-
\f1\fs18 NULL
\f0\fs20  values are supplied for 
\f1\fs18 nrow
\f0\fs20  and/or 
\f1\fs18 ncol
\f0\fs20 , a matrix will be made with the requested number of rows and/or columns if possible; if the length of 
\f1\fs18 data
\f0\fs20  is not compatible with the requested dimensions, an error will result.  By default, values from data will populate the matrix by columns, filling each column sequentially before moving on to the next column; if 
\f1\fs18 byrow
\f0\fs20  is 
\f1\fs18 T
\f0\fs20  the matrix will be populated by rows instead.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (*)matrixMult(*\'a0x, *\'a0y)
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns the result of matrix multiplication
\b0  of 
\f1\fs18 x
\f0\fs20  with 
\f1\fs18 y
\f0\fs20 .  In Eidos (as in R), with two matrices 
\f1\fs18 A
\f0\fs20  and 
\f1\fs18 B
\f0\fs20  the simple product 
\f1\fs18 A\'a0*\'a0B
\f0\fs20  multiplies the corresponding elements of the matrices; in other words, if 
\f1\fs18 X
\f0\fs20  is the result of 
\f1\fs18 A\'a0*\'a0B
\f0\fs20 , then 
\f1\fs18 X
\f0\i\fs13\fsmilli6667 \sub ij
\i0\fs20 \nosupersub \'a0=\'a0
\f1\fs18 A
\f0\i\fs13\fsmilli6667 \sub ij
\i0\fs20 \nosupersub \'a0* 
\f1\fs18 B
\f0\i\fs13\fsmilli6667 \sub ij
\i0\fs20 \nosupersub .  This is parallel to the definition of other operators; A\'a0+\'a0B adds the corresponding elements of the matrices (
\f1\fs18 X
\f0\i\fs13\fsmilli6667 \sub ij
\i0\fs20 \nosupersub \'a0=\'a0
\f1\fs18 A
\f0\i\fs13\fsmilli6667 \sub ij
\i0\fs20 \nosupersub \'a0+\'a0
\f1\fs18 B
\f0\i\fs13\fsmilli6667 \sub ij
\i0\fs20 \nosupersub ), etc.  In R, true matrix multiplication is achieved with a special operator, 
\f1\fs18 %*%
\f0\fs20 ; in Eidos, the 
\f1\fs18 matrixMult()
\f0\fs20  function is used instead.\
Both 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must be matrices, and must be conformable according to the standard definition of matrix multiplication (i.e., if 
\f1\fs18 x
\f0\fs20  is an 
\i n
\i0 \'a0\'d7\'a0
\i m
\i0  matrix then 
\f1\fs18 y
\f0\fs20  must be a 
\i m
\i0 \'a0\'d7\'a0
\i p
\i0  matrix, and the result will be a 
\i n
\i0 \'a0\'d7\'a0
\i p
\i0  matrix).  Vectors will not be promoted to matrices by this function, even if such promotion would lead to a conformable matrix.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (integer$)nrow(*\'a0x)
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns the number of rows
\b0  in matrix or array 
\f1\fs18 x
\f0\fs20 .  For vector 
\f1\fs18 x
\f0\fs20 , 
\f1\fs18 nrow()
\f0\fs20  returns 
\f1\fs18 NULL
\f0\fs20 ; 
\f1\fs18 size()
\f0\fs20  should be used.  An equivalent of R\'92s 
\f1\fs18 NROW()
\f0\fs20  function, which treats vectors as 
\f1\fs18 1
\f0\fs20 -column matrices, is not provided but would be trivial to implement as a user-defined function.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (integer$)ncol(*\'a0x)
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns the number of columns
\b0  in matrix or array 
\f1\fs18 x
\f0\fs20 .  For vector 
\f1\fs18 x
\f0\fs20 , 
\f1\fs18 ncol()
\f0\fs20  returns 
\f1\fs18 NULL
\f0\fs20 ; 
\f1\fs18 size()
\f0\fs20  should be used.  An equivalent of R\'92s 
\f1\fs18 NCOL()
\f0\fs20  function, which treats vectors as 
\f1\fs18 1
\f0\fs20 -column matrices, is not provided but would be trivial to implement as a user-defined function.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (*)rbind(...)
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 \expnd0\expndtw0\kerning0
Combines vectors or matrices by row
\b0  to produce a single matrix.  The parameters must be vectors (which are interpreted by 
\f1\fs18 rbind()
\f0\fs20  as if they were one-row matrices) or matrices.  They must be of the same type, of the same class if they are of type 
\f1\fs18 object
\f0\fs20 , and have the same number of columns.  If these conditions are met, the result is a single matrix with the parameters joined together, top to bottom.  Parameters may instead be 
\f1\fs18 NULL
\f0\fs20 , in which case they are ignored; or if all parameters are 
\f1\fs18 NULL
\f0\fs20 , the result is 
\f1\fs18 NULL
\f0\fs20 .  A sequence of vectors, matrices, and 
\f1\fs18 NULL
\f0\fs20 s may thus be concatenated with the 
\f1\fs18 NULL
\f0\fs20  values removed, analogous to 
\f1\fs18 c()
\f0\fs20 .  Calling 
\f1\fs18 rbind(x)
\f0\fs20  is an easy way to create a one-row matrix from a vector.\
To combine vectors or matrices by column instead, see 
\f1\fs18 cbind()
\f0\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (*)t(*\'a0x)
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns the transpose
\b0  of 
\f1\fs18 x
\f0\fs20 , which must be a matrix.  This is the matrix reflected across its diagonal; or alternatively, the matrix with its columns written out instead as rows in the same order.\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\b\fs22 \cf0 \kerning1\expnd0\expndtw0 3.8.  Filesystem access functions\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (logical$)createDirectory(string$\'a0path)
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Creates a new filesystem directory
\b0  at the path specified by 
\f1\fs18 path
\f0\fs20  and returns a 
\f1\fs18 logical
\f0\fs20  value indicating if the creation succeeded (
\f1\fs18 T
\f0\fs20 ) or failed (
\f1\fs18 F
\f0\fs20 ).  If the path already exists, 
\f1\fs18 createDirectory()
\f0\fs20  will do nothing to the filesystem, will emit a warning, and will return 
\f1\fs18 T
\f0\fs20  to indicate success if the existing path is a directory, or 
\f1\fs18 F
\f0\fs20  to indicate failure if the existing path is not a directory.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)deleteFile(string$\'a0filePath)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Deletes the file
\b0  specified by 
\f1\fs18 filePath
\f0\fs20  and returns a 
\f1\fs18 logical
\f0\fs20  value indicating if the deletion succeeded (
\f1\fs18 T
\f0\fs20 ) or failed (
\f1\fs18 F
\f0\fs20 ).
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string)filesAtPath(string$\'a0path, [logical$\'a0fullPaths\'a0=\'a0F])
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\f1\fs18 string
\f0\fs20  vector containing the 
\b names of all files in a directory
\b0  specified by 
\f1\fs18 path
\f2\fs20 .
\f0   If the optional parameter 
\f1\fs18 fullPaths
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , full filesystem paths are returned for each file; if 
\f1\fs18 fullPaths
\f0\fs20  is 
\f1\fs18 F
\f0\fs20  (the default), then only the filenames relative to the specified directory are returned.  This list includes directories (i.e. subfolders), including the 
\f1\fs18 "."
\f0\fs20  and 
\f1\fs18 ".."
\f0\fs20  directories on Un*x systems.  The list also includes invisible files, such as those that begin with a 
\f1\fs18 "."
\f0\fs20  on Un*x systems.  This function does not descend recursively into subdirectories.  If an error occurs during the read, 
\f1\fs18 NULL
\f0\fs20  will be returned.
\f2 \
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 \expnd0\expndtw0\kerning0
(string$)getwd(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 Gets the current filesystem working directory
\b0 .  The filesystem working directory is the directory which will be used as a base path for relative filesystem paths.  For example, if the working directory is 
\f1\fs18 "~/Desktop"
\f0\fs20  (the 
\f1\fs18 Desktop
\f0\fs20  subdirectory within the current user\'92s home directory, as represented by 
\f1\fs18 ~
\f0\fs20 ), then the filename 
\f1\fs18 "foo.txt"
\f0\fs20  would correspond to the filesystem path 
\f1\fs18 "~/Desktop/foo.txt"
\f0\fs20 , and the relative path 
\f1\fs18 "bar/baz/"
\f0\fs20  would correspond to the filesystem path 
\f1\fs18 \'93~/Desktop/bar/baz/\'93
\f0\fs20 .\
Note that the path returned may not be identical to the path previously set with 
\f1\fs18 setwd()
\f0\fs20 , if for example symbolic links are involved; but it ought to refer to the same actual directory in the filesystem.\
The initial working directory is \'96 as is generally the case on Un*x \'96 simply the directory given to the running Eidos process by its parent process (the operating system, a shell, a job scheduler, a debugger, or whatever the case may be).  If you launch Eidos (or SLiM) from the command line in a Un*x shell, it is typically the current directory in that shell.  Before relative filesystem paths are used, you may therefore wish check what the initial working directory is on your platform, with 
\f1\fs18 getwd()
\f0\fs20 , if you are not sure.  Alternatively, you can simply use 
\f1\fs18 setwd()
\f0\fs20  to set the working directory to a known path.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (string)readFile(string$\'a0filePath)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Reads in the contents of a file
\b0  specified by 
\f1\fs18 filePath
\f0\fs20  and returns a 
\f1\fs18 string
\f0\fs20  vector containing the lines (separated by 
\f1\fs18 \\n
\f0\fs20  and 
\f1\fs18 \\r
\f0\fs20  characters) of the file.  Reading files other than text files is not presently supported.  If an error occurs during the read, 
\f1\fs18 NULL
\f0\fs20  will be returned.
\f2 \
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf2 \expnd0\expndtw0\kerning0
(string$)setwd(string$\'a0path)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 Sets the current filesystem working directory
\b0 .  The filesystem working directory is the directory which will be used as a base path for relative filesystem paths (see 
\f1\fs18 getwd()
\f0\fs20  for further discussion).  An error will result if the working directory cannot be set to the given path.\
The current working directory prior to the change will be returned as an invisible 
\f1\fs18 string
\f0\fs20  value; the value returned is identical to the value that would have been returned by 
\f1\fs18 getwd()
\f0\fs20 , apart from its invisibility.\
See 
\f1\fs18 getwd()
\f0\fs20  for discussion regarding the initial working directory, before it is set with 
\f1\fs18 setwd()
\f0\fs20 .\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (logical$)writeFile(string$\'a0filePath, string\'a0contents, [logical$\'a0append\'a0=\'a0F])
\f2 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Writes or appends to a file
\b0  specified by 
\f1\fs18 filePath
\f0\fs20  with contents specified by 
\f1\fs18 contents
\f0\fs20 , a 
\f1\fs18 string
\f0\fs20  vector of lines.  If 
\f1\fs18 append
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , the write will be appended to the existing file (if any) at 
\f1\fs18 filePath
\f0\fs20 ; if it is 
\f1\fs18 F
\f0\fs20  (the default), then the write will replace an existing file at that path.  If the write is successful, 
\f1\fs18 T
\f0\fs20  will be returned; if not, 
\f1\fs18 F
\f0\fs20  will be returned.\
Note that newline characters will be added at the ends of the lines in 
\f1\fs18 contents
\f0\fs20 .  If you do not wish to have newlines added, you should use 
\f1\fs18 paste()
\f0\fs20  to assemble the elements of 
\f1\fs18 contents
\f0\fs20  together into a singleton 
\f1\fs18 string
\f2\fs20 .\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)writeTempFile(string$\'a0prefix, string$\'a0suffix, string\'a0contents)
\f2 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Writes to a unique temporary file
\b0  with contents specified by 
\f1\fs18 contents
\f0\fs20 , a 
\f1\fs18 string
\f0\fs20  vector of lines.  The filename used will begin with 
\f1\fs18 prefix
\f0\fs20  and end with 
\f1\fs18 suffix
\f0\fs20 , and will contain six random characters in between; for example, if 
\f1\fs18 prefix
\f0\fs20  is 
\f1\fs18 "plot1_"
\f0\fs20  and 
\f1\fs18 suffix
\f0\fs20  is 
\f1\fs18 ".pdf"
\f0\fs20 , the generated filename might look like 
\f1\fs18 "plot1_r5Mq0t.pdf"
\f0\fs20 .  It is legal for 
\f1\fs18 prefix
\f0\fs20 , 
\f1\fs18 suffix
\f0\fs20 , or both to be the empty string, 
\f1\fs18 ""
\f0\fs20 , but supplying a file extension is usually advisable at minimum.  The file will be created inside the 
\f1\fs18 /tmp/
\f0\fs20  directory of the system, which is provided by Un*x systems as a standard location for temporary files; the 
\f1\fs18 /tmp/
\f0\fs20  directory should not be specified as part of prefix (nor should any other directory information).  The filename generated is guaranteed not to already exist in 
\f1\fs18 /tmp/
\f0\fs20 .  The file is created with Un*x permissions 
\f1\fs18 0600
\f0\fs20 , allowing reading and writing only by the user for security.  If the write is successful, the full path to the temporary file will be returned; if not, 
\f1\fs18 ""
\f0\fs20  will be returned.\
Note that newline characters will be added at the ends of the lines in 
\f1\fs18 contents
\f0\fs20 .  If you do not wish to have newlines added, you should use 
\f1\fs18 paste()
\f0\fs20  to assemble the elements of 
\f1\fs18 contents
\f0\fs20  together into a singleton 
\f1\fs18 string
\f2\fs20 .\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.9.  Color manipulation functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (float)color2rgb(string$\'a0color)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Converts a color string to RGB
\f2\b0 .
\f0   The color string specified in 
\f1\fs18 color
\f0\fs20  may be either a named color (see section X) or a color in hexadecimal format such as 
\f1\fs18 "#007FC0"
\f0\fs20 .  The equivalent RGB color is returned as a 
\f1\fs18 float
\f0\fs20  vector of length three (red, green, blue).  Returned RGB values will be in the interval [0, 1].
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)hsv2rgb(float\'a0hsv)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Converts an HSV color to RGB
\f2\b0 .
\f0   The HSV color is specified in 
\f1\fs18 hsv
\f0\fs20  as a 
\f1\fs18 float
\f0\fs20  vector of length three (hue, saturation, value), and the equivalent RGB color is returned as a 
\f1\fs18 float
\f0\fs20  vector of length three (red, green, blue).  HSV values will be clamped to the interval [0, 1], and returned RGB values will also be in the interval [0, 1].
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)rgb2color(float\'a0rgb)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Converts an RGB color to a color string
\f2\b0 .
\f0   The RGB color is specified in 
\f1\fs18 rgb
\f0\fs20  as a 
\f1\fs18 float
\f0\fs20  vector of length three (red, green, blue).  The equivalent color string is returned as singleton 
\f1\fs18 string
\f0\fs20  specifying the color in the format 
\f1\fs18 "#RRGGBB"
\f0\fs20 , such as 
\f1\fs18 "#007FC0"
\f2\fs20 .
\f0   RGB values will be clamped to the interval [0, 1].
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)rgb2hsv(float\'a0rgb)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Converts an RGB color to HSV
\f2\b0 .
\f0   The RGB color is specified in 
\f1\fs18 rgb
\f0\fs20  as a 
\f1\fs18 float
\f0\fs20  vector of length three (red, green, blue), and the equivalent HSV color is returned as a 
\f1\fs18 float
\f0\fs20  vector of length three (hue, saturation, value).  RGB values will be clamped to the interval [0, 1], and returned HSV values will also be in the interval [0, 1].
\f2 \
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.10.  Miscellaneous functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (void)beep([Ns$\'a0soundName\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Plays a sound or beeps.
\b0   On Mac OS X in a GUI environment (i.e., in EidosScribe or SLiMgui), the optional parameter 
\f1\fs18 soundName
\f0\fs20  can be the name of a sound file to play; in other cases (if 
\f1\fs18 soundName
\f0\fs20  is 
\f1\fs18 NULL
\f0\fs20 , or at the command line, or on platforms other than OS X) 
\f1\fs18 soundName
\f0\fs20  is ignored and a standard system beep is played.\
When 
\f1\fs18 soundName
\f0\fs20  is not 
\f1\fs18 NULL
\f2\fs20 ,
\f0  a sound file in a supported format (such as 
\f1\fs18 .aiff
\f0\fs20  or 
\f1\fs18 .mp3
\f0\fs20 ) is searched for sequentially in four standard locations, in this order: 
\f1\fs18 ~/Library/Sounds
\f0\fs20 , 
\f1\fs18 /Library/Sounds
\f0\fs20 , 
\f1\fs18 /Network/Library/Sounds
\f0\fs20 , and finally 
\f1\fs18 /System/Library/Sounds
\f0\fs20 .  Standard OS X sounds located in /System/Library/Sounds include 
\f1\fs18 "Basso"
\f2\fs20 ,
\f0  
\f1\fs18 "Blow"
\f2\fs20 ,
\f0  
\f1\fs18 "Bottle"
\f2\fs20 ,
\f0  
\f1\fs18 "Frog"
\f2\fs20 ,
\f0  
\f1\fs18 "Funk"
\f2\fs20 ,
\f0  
\f1\fs18 "Glass"
\f2\fs20 ,
\f0  
\f1\fs18 "Hero"
\f2\fs20 ,
\f0  
\f1\fs18 "Morse"
\f2\fs20 ,
\f0  
\f1\fs18 "Ping"
\f2\fs20 ,
\f0  
\f1\fs18 "Pop"
\f2\fs20 ,
\f0  
\f1\fs18 "Purr"
\f2\fs20 ,
\f0  
\f1\fs18 "Sosumi"
\f2\fs20 ,
\f0  
\f1\fs18 "Submarine"
\f0\fs20 , and 
\f1\fs18 "Tink"
\f0\fs20 .  Do not include the file extension, such as 
\f1\fs18 .aiff
\f0\fs20  or 
\f1\fs18 .mp3
\f0\fs20 , in 
\f1\fs18 soundName
\f2\fs20 .\

\f0\b CAUTION:
\b0  When not running in EidosScribe or SLiMgui, it is often the case that the only simple means available to play a beep is to send a 
\f1\fs18 BEL
\f0\fs20  character (ASCII 7) to the standard output.  Unfortunately, when this is the case, it means that (1) no beep will be audible if output is being redirected into a file, and (2) a control character, 
\f1\fs18 ^G
\f0\fs20 , will occur in the output at the point when the beep was requested.  It is therefore recommended that 
\f1\fs18 beep()
\f0\fs20  be used only when doing interactive work in a terminal shell (or in a GUI, on OS X), not when producing output files.  However, this issue is platform-specific; on some platforms 
\f1\fs18 beep()
\f0\fs20  may result in a beep, and no emitted 
\f1\fs18 ^G
\f0\fs20 , even when output is redirected.  When a 
\f1\fs18 ^G
\f0\fs20  must be emitted to the standard output to generate the beep, a warning message will also be emitted to make any associated problems easier to diagnose.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)citation(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints citation information for Eidos
\b0  to Eidos\'92s output stream.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float$)clock(void)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b current CPU usage clock
\b0 .  This is the amount of CPU time used by the current process, in seconds; it is unrelated to the current time of day (for that, see the 
\f1\fs18 time()
\f0\fs20  function).  This is useful mainly for determining how much processor time a given section of code takes; 
\f1\fs18 clock()
\f0\fs20  can be called before and after a block of code, and the end clock minus the start clock gives the elapsed CPU time consumed in the execution of the block of code.  See also the 
\f1\fs18 timed
\f0\fs20  parameter of 
\f1\fs18 executeLambda()
\f0\fs20 , which automates this procedure.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)date(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b standard date string
\b0  for the current date in the local time of the executing machine.  The format is 
\f1\fs18 %d-%m-%Y
\f0\fs20  (day in two digits, then month in two digits, then year in four digits, zero-padded and separated by dashes) regardless of the localization of the executing machine, for predictability and consistency.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)defineConstant(string$\'a0symbol, +\'a0value)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Defines a new constant
\b0  with the name 
\f1\fs18 symbol
\f0\fs20  and the value specified by 
\f1\fs18 value
\f0\fs20 .  The value may be any non-object value at all.  The name cannot previously be defined in any way (i.e., as either a variable or a constant).  The defined constant acts identically to intrinsic Eidos constants such as 
\f1\fs18 T
\f0\fs20 , 
\f1\fs18 NAN
\f0\fs20 , and 
\f1\fs18 PI
\f0\fs20 , and will remain defined for as long as the Eidos context lives even if it is defined inside a block being executed by 
\f1\fs18 executeLambda()
\f0\fs20 , 
\f1\fs18 sapply()
\f0\fs20 , or a Context-defined script block.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (\cf2 \expnd0\expndtw0\kerning0
vNlifso\cf0 \kerning1\expnd0\expndtw0 )doCall(string$\'a0functionName, ...)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the results from a 
\b call to a specified function
\b0 .  The function named by the parameter 
\f1\fs18 functionName
\f0\fs20  is called, and the remaining parameters to 
\f1\fs18 doCall()
\f0\fs20  are forwarded on to that function verbatim.  This can be useful for calling one of a set of similar functions, such as 
\f1\fs18 sin()
\f0\fs20 , 
\f1\fs18 cos()
\f0\fs20 , etc., to perform a math function determined at runtime, or one of the 
\f1\fs18 as...()
\f0\fs20  family of functions to convert to a type determined at runtime.  Note that named arguments and default arguments, beyond the 
\f1\fs18 functionName
\f0\fs20  argument, are not supported by 
\f1\fs18 doCall()
\f0\fs20 ; all arguments to the target function must be specified explicitly, without names.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (\cf2 \expnd0\expndtw0\kerning0
vNlifso\cf0 \kerning1\expnd0\expndtw0 )executeLambda(string$\'a0lambdaSource, [logical$\'a0timed\'a0=\'a0F])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Executes a block of Eidos code
\b0  defined by 
\f1\fs18 lambdaSource
\f0\fs20 .  
\fs22 Eidos allows you to execute 
\i lambdas
\i0 : blocks of Eidos code which can be called directly within the same scope as the caller.  Eidos lambdas do not take arguments; for this reason, they are not first-class functions.  (Since they share the scope of the caller, however, you may effectively pass values in and out of a lambda using global variables.)
\fs20   The 
\f1\fs18 string
\f0\fs20  argument 
\f1\fs18 lambdaSource
\f0\fs20  may contain one or many Eidos statements as a single 
\f1\fs18 string
\f0\fs20  value.  Lambdas are represented, to the caller, only as the source code 
\f1\fs18 string
\f0\fs20  
\f1\fs18 lambdaSource
\f0\fs20 ; the executable code is not made available programmatically.  If an error occurs during the tokenization, parsing, or execution of the lambda, that error is raised as usual; executing code inside a lambda does not provide any additional protection against exceptions raised.  The return value produced by the code in the lambda is returned by 
\f1\fs18 executeLambda()
\f2\fs20 .
\f0   If the optional parameter 
\f1\fs18 timed
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , the total (user clock) execution time for the lambda will be printed after the lambda has completed
\fs22  (see 
\f1\fs18 clock()
\f0\fs22 )
\fs20 ; if it is 
\f1\fs18 F
\f0\fs20  (the default), no timing information will be printed.\
The current implementation of 
\f1\fs18 executeLambda()
\f0\fs20  caches a tokenized and parsed version of 
\f1\fs18 lambdaSource
\f0\fs20 , so calling 
\f1\fs18 executeLambda()
\f0\fs20  repeatedly on a single source 
\f1\fs18 string
\f0\fs20  is much more efficient than calling 
\f1\fs18 executeLambda()
\f0\fs20  with a newly constructed 
\f1\fs18 string
\f0\fs20  each time.  If you can use a 
\f1\fs18 string
\f0\fs20  literal for 
\f1\fs18 lambdaSource
\f0\fs20 , or reuse a constructed source 
\f1\fs18 string
\f0\fs20  stored in a variable, that will improve performance considerably.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)exists(string$\'a0symbol)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\f1\fs18 logical
\f0\fs20  value indicating 
\b whether a symbol exists
\f2\b0 .
\f0   If the symbol has been defined as an intrinsic Eidos constant like 
\f1\fs18 T
\f0\fs20 , 
\f1\fs18 INF
\f0\fs20 , and 
\f1\fs18 PI
\f0\fs20 , or as a Context-defined constant like 
\f1\fs18 sim
\f0\fs20  in SLiM, or as a user-defined constant using 
\f1\fs18 defineConstant()
\f0\fs20 , or as a variable by assignment, this function returns 
\f1\fs18 T
\f0\fs20 .  Otherwise, the symbol has not been defined, and 
\f1\fs18 exists()
\f0\fs20  returns 
\f1\fs18 F
\f0\fs20 .  This is commonly used to check whether a user-defined constant already exists, with the intention of defining the constant if it has not already been defined.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)functionSignature([Ns$
\f2 \'a0
\f1 functionName
\f2 \'a0
\f1 =\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints function signatures
\b0  for all functions (if 
\f1\fs18 functionName
\f0\fs20  is 
\f1\fs18 NULL
\f0\fs20 , the default), or for the function named by 
\f1\fs18 functionName
\f0\fs20 , to Eidos\'92s output stream.  See section 2.7.3 for more information.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer$)getSeed(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b random number seed
\b0 .  This is the last seed value set using 
\f1\fs18 setSeed()
\f0\fs20 ; if 
\f1\fs18 setSeed()
\f0\fs20  has not been called, it will be a seed value chosen based on the process-id and the current time when Eidos was initialized, unless the Context has set a different seed value.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)license(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints Eidos\'92s license terms
\b0  to Eidos\'92s output stream.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)ls(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints all currently defined variables
\b0  to Eidos\'92s output stream.  See section 2.4.1 for more information.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)rm([Ns\'a0variableNames
\f2 \'a0
\f1 =\'a0NULL], [logical$\'a0removeConstants\'a0=\'a0F])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Removes global variables
\b0  from the Eidos namespace; in other words, it causes the variables to become undefined.  Variables are specified by their 
\f1\fs18 string
\f0\fs20  name in the 
\f1\fs18 variableNames
\f0\fs20  parameter.  If the optional 
\f1\fs18 variableNames
\f0\fs20  parameter is 
\f1\fs18 NULL
\f0\fs20  (the default), 
\i all
\i0  variables will be removed (be careful!).  If the optional parameter 
\f1\fs18 removeConstants
\f0\fs20  is 
\f1\fs18 F
\f0\fs20  (the default), then attempting to remove a constant is an error; if 
\f1\fs18 removeConstants
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , constants defined with 
\f1\fs18 defineConstant()
\f0\fs20  may be removed, but attempting to remove intrinsic Eidos constants is still an error.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)sapply(*\'a0x, string$\'a0lambdaSource, [string$\'a0simplify\'a0=\'a0"vector"])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\i\fs20 \cf3 \expnd0\expndtw0\kerning0
Named 
\f3\fs18 apply()
\f0\fs20  prior to Eidos 1.6 / SLiM 2.6\

\i0\b \cf2 Applies a block of Eidos code to the elements of x
\b0 .  This function is sort of a hybrid between 
\f1\fs18 c()
\f0\fs20  and 
\f1\fs18 executeLambda()
\f0\fs20 ; it might be useful to consult the documentation for both of those functions to better understand what 
\f1\fs18 sapply()
\f0\fs20  does.  For each element in 
\f1\fs18 x
\f0\fs20 , the lambda defined by 
\f1\fs18 lambdaSource
\f0\fs20  will be called.  For the duration of that callout, a variable named 
\f1\fs18 applyValue
\f0\fs20  will be defined to have as its value the element of 
\f1\fs18 x
\f0\fs20  currently being processed.  The expectation is that the lambda will use 
\f1\fs18 applyValue
\f0\fs20  in some way, and will return either 
\f1\fs18 NULL
\f0\fs20  or a new value (which need not be a singleton, and need not be of the same type as 
\f1\fs18 x
\f0\fs20 ).  The return value of 
\f1\fs18 sapply()
\f0\fs20  is generated by concatenating together all of the individual vectors returned by the lambda, in exactly the same manner as the 
\f1\fs18 c()
\f0\fs20  function (including the possibility of type promotion).\
Since this function can be hard to understand at first, here is an example:\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f1\fs18 \cf2 sapply(1:10, "if (applyValue % 2) applyValue ^ 2;");\

\f0\fs20 This produces the output 
\f1\fs18 1 9 25 49 81
\f0\fs20 .  The 
\f1\fs18 sapply()
\f0\fs20  operation begins with the vector 
\f1\fs18 1:10
\f0\fs20 .  For each element of that vector, the lambda is called and 
\f1\fs18 applyValue
\f0\fs20  is defined with the element value.  In this respect, 
\f1\fs18 sapply()
\f0\fs20  is actually very much like a 
\f1\fs18 for
\f0\fs20  loop.  If 
\f1\fs18 applyValue
\f0\fs20  is even (as evaluated by the modulo operator, 
\f1\fs18 %
\f0\fs20 ), the condition of the 
\f1\fs18 if
\f0\fs20  statement is 
\f1\fs18 F
\f0\fs20  and so 
\f1\fs18 NULL
\f0\fs20  is implicitly returned by the lambda (since the 
\f1\fs18 if
\f0\fs20  has no 
\f1\fs18 else
\f0\fs20  clause).  If 
\f1\fs18 applyValue
\f0\fs20  is odd, on the other hand, the lambda returns its square (as calculated by the exponential operator, 
\f1\fs18 ^
\f0\fs20 ).  Just as with the 
\f1\fs18 c()
\f0\fs20  function, 
\f1\fs18 NULL
\f0\fs20  values are dropped during concatenation, so the final result contains only the squares of the odd values.\
This example illustrates that the lambda can \'93drop\'94 values by returning 
\f1\fs18 NULL
\f0\fs20 , so 
\f1\fs18 sapply()
\f0\fs20  can be used to select particular elements of a vector that satisfy some condition, much like the subscript operator, 
\f1\fs18 []
\f0\fs20 .  The example also illustrates that input and result types do not have to match; the vector passed in is 
\f1\fs18 integer
\f0\fs20 , whereas the result vector is 
\f1\fs18 float
\f0\fs20 .\
Beginning in Eidos 1.6, a new optional parameter named 
\f1\fs18 simplify
\f0\fs20  allows the result of 
\f1\fs18 sapply()
\f0\fs20  to be a matrix or array in certain cases, better organizing the elements of the result.  If the 
\f1\fs18 simplify
\f0\fs20  parameter is 
\f1\fs18 "vector"
\f0\fs20 , the concatenated result value is returned as a plain vector in all cases; this is the default behavior, for backward compatibility.  Two other possible values for 
\f1\fs18 simplify
\f0\fs20  are presently supported.  If 
\f1\fs18 simplify
\f0\fs20  is 
\f1\fs18 "matrix"
\f0\fs20 , the concatenated result value will be turned into a matrix with one column for each non-
\f1\fs18 NULL
\f0\fs20  value returned by the lambda, as if the values were joined together with 
\f1\fs18 cbind()
\f0\fs20 , as long as all of the lambda\'92s return values are either (a) 
\f1\fs18 NULL
\f0\fs20  or (b) the same length as the other non-
\f1\fs18 NULL
\f0\fs20  values returned.  If 
\f1\fs18 simplify
\f0\fs20  is 
\f1\fs18 "match"
\f0\fs20 , the concatenated result value will be turned into a vector, matrix, or array that exactly matches the dimensions as 
\f1\fs18 x
\f0\fs20 , with a one-to-one correspondence between 
\f1\fs18 x
\f0\fs20  and the elements of the return value just like a unary operator, as long as all of the lambda\'92s return values are singletons (with no 
\f1\fs18 NULL
\f0\fs20  values).  Both 
\f1\fs18 "matrix"
\f0\fs20  and 
\f1\fs18 "match"
\f0\fs20  will raise an error if their preconditions are not met, to avoid unexpected behavior, so care should be taken that the preconditions are always met when these options are used.\
As with 
\f1\fs18 executeLambda()
\f0\fs20 , all defined variables are accessible within the lambda, and changes made to variables inside the lambda will persist beyond the end of the 
\f1\fs18 sapply()
\f0\fs20  call; the lambda is executing in the same scope as the rest of your code.\
The 
\f1\fs18 sapply()
\f0\fs20  function can seem daunting at first, but it is an essential tool in the Eidos toolbox.  It combines the iteration of a 
\f1\fs18 for
\f0\fs20  loop, the ability to select elements like operator 
\f1\fs18 []
\f0\fs20 , and the ability to assemble results of mixed type together into a single vector like 
\f1\fs18 c()
\f0\fs20 , all with the power of arbitrary Eidos code execution like 
\f1\fs18 executeLambda()
\f0\fs20 .  It is relatively fast, compared to other ways of achieving similar results such as a 
\f1\fs18 for
\f0\fs20  loop that accumulates results with 
\f1\fs18 c()
\f0\fs20 .  Like 
\f1\fs18 executeLambda()
\f0\fs20 , 
\f1\fs18 sapply()
\f0\fs20  is most efficient if it is called multiple times with a single 
\f1\fs18 string
\f0\fs20  script variable, rather than with a newly constructed 
\f1\fs18 string
\f0\fs20  for 
\f1\fs18 lambdaSource
\f0\fs20  each time.\
Prior to Eidos 1.6 (SLiM 2.6), 
\f1\fs18 sapply()
\f0\fs20  was instead named 
\f1\fs18 apply()
\f0\fs20 ; it was renamed to 
\f1\fs18 sapply()
\f0\fs20  in order to more closely match the naming of functions in R.  This renaming allowed a new 
\f1\fs18 apply()
\f0\fs20  function to be added to Eidos that operates on the margins of matrices and arrays, similar to the 
\f1\fs18 apply()
\f0\fs20  function of R (see 
\f1\fs18 apply()
\f0\fs20 , above).\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 \kerning1\expnd0\expndtw0 (void)setSeed(integer$\'a0seed)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Set the random number seed
\b0 .  Future random numbers will be based upon the seed value set, and the random number sequence generated from a particular seed value is guaranteed to be reproducible.  The last seed set can be recovered with the 
\f1\fs18 getSeed()
\f0\fs20  function.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)source(string$
\f2 \'a0
\f1 filePath)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Executes the contents of an Eidos source file
\b0  found at the filesystem path 
\f1\fs18 filePath
\f2\fs20 .
\f0   This is essentially shorthand for calling 
\f1\fs18 readFile()
\f0\fs20 , joining the read lines with newlines to form a single string using 
\f1\fs18 paste()
\f0\fs20 , and then passing that string to 
\f1\fs18 executeLambda()
\f2\fs20 .
\f0   The source file must consist of complete Eidos statements.  Regardless of what the last executed source line evaluates to, 
\f1\fs18 source()
\f0\fs20  has no return value.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)stop([Ns$
\f2 \'a0
\f1 message
\f2 \'a0
\f1 =\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Stops execution
\b0  of Eidos (and of the Context, such as the running SLiM simulation, if applicable), in the event of an error.  If the optional 
\f1\fs18 message
\f0\fs20  parameter is not 
\f1\fs18 NULL
\f0\fs20 , it will be printed to Eidos\'92s output stream prior to stopping.
\f2 \
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string)system(string$\'a0command, [string\'a0args\'a0=\'a0""], [string\'a0input\'a0=\'a0""], [logical$\'a0stderr\'a0=\'a0F])\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Runs a Un*x command in a 
\f6\fs18 /bin/sh
\f0\fs20  shell
\b0  with optional arguments and input, and returns the result as a vector of output lines.  The 
\f1\fs18 args
\f0\fs20  parameter may contain a vector of arguments to 
\f1\fs18 command
\f0\fs20 ; they will be passed directly to the shell without any quoting, so applying the appropriate quoting as needed by 
\f1\fs18 /bin/sh
\f0\fs20  is the caller\'92s responsibility.  The arguments are appended to 
\f1\fs18 command
\f0\fs20 , separated by spaces, and the result is passed to the shell as a single command string, so arguments may simply be given as part of 
\f1\fs18 command
\f0\fs20  instead, if preferred.  By default no input is supplied to 
\f1\fs18 command
\f0\fs20 ; if 
\f1\fs18 input
\f0\fs20  is non-empty, however, it will be written to a temporary file (one line per 
\f1\fs18 string
\f0\fs20  element) and the standard input of 
\f1\fs18 command
\f0\fs20  will be redirected to that temporary file (using standard 
\f1\fs18 /bin/sh
\f0\fs20  redirection with 
\f1\fs18 <
\f0\fs20 , appended to the command string passed to the shell).  By default, output sent to standard error will not be captured (and thus may end up in the output of the SLiM process, or may be lost); if 
\f1\fs18 stderr
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , however, standard error will be redirected into standard out (using standard 
\f1\fs18 /bin/sh
\f0\fs20  redirection with 
\f1\fs18 2>&1
\f0\fs20 , appended to the command string passed to the shell).\
Arbitrary command strings involving multiple commands, pipes, redirection, etc., may be used with 
\f1\fs18 system()
\f0\fs20 , but may be incompatible with the way that 
\f1\fs18 args
\f2\fs20 ,
\f0  
\f1\fs18 input
\f0\fs20 , and 
\f1\fs18 stderr
\f0\fs20  are handled by this function, so in this case supplying the whole command string in 
\f1\fs18 command
\f0\fs20  may be the simplest course.  You may redirect standard error into standard output yourself in 
\f1\fs18 command
\f0\fs20  with 
\f1\fs18 2>&1
\f2\fs20 .
\f0   Supplying input to a complex command line can often be facilitated by the use of parentheses to create a subshell; for example,\
\pard\tx990\tx1260\tx1530\tx1800\tx2070\tx2340\pardeftab543\li900\ri1440\sb180\sa180\partightenfactor0

\f1\fs18 \cf0 system("(wc -l | sed 's/ //g')", input=c('foo', 'bar', 'baz'));
\f2 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 will supply the input lines to 
\f1\fs18 wc
\f0\fs20  courtesy of the subshell started for the 
\f1\fs18 ()
\f0\fs20  operator.  If this strategy doesn\'92t work for the command line you want to execute, you can always write a temporary file yourself using 
\f1\fs18 writeFile()
\f0\fs20  and redirect that file to standard input in 
\f1\fs18 command
\f0\fs20  with 
\f1\fs18 <
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)time(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b standard time string
\b0  for the current time in the local time of the executing machine.  The format is 
\f1\fs18 %H:%M:%S
\f0\fs20  (hour in two digits, then minute in two digits, then seconds in two digits, zero-padded and separated by dashes) regardless of the localization of the executing machine, for predictability and consistency.  The 24-hour clock time is used (i.e., no AM/PM).
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)version(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf2 \expnd0\expndtw0\kerning0
Prints Eidos\'92s version 
\b0 to Eidos\'92s output stream.  If Eidos is attached to a Context that provides a version number, that is also printed.  The Eidos version number, and the Context version number if available, are returned as an invisible 
\f1\fs18 float
\f0\fs20  vector to make it possible for script to test the code version it is running against.  (In this 
\f1\fs18 float
\f0\fs20  return, a version like 2.4.2 would be returned as 
\f1\fs18 2.42
\f0\fs20 ; this would not scale well to subversions greater than nine, so that will be avoided in our versioning).}