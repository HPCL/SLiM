{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Optima-Regular;\f1\fnil\fcharset0 Menlo-Regular;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fnil\fcharset0 Menlo-Italic;\f4\fswiss\fcharset0 Helvetica;\f5\fnil\fcharset0 Menlo-Bold;
}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab397
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.1.  Math functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (numeric)abs(numeric
\f2 \'a0
\f1 x)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b absolute value
\b0  of 
\f1\fs18 x
\f0\fs20 .  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 integer
\f0\fs20 , the C++ function 
\f1\fs18 llabs()
\f0\fs20  is used and an 
\f1\fs18 integer
\f0\fs20  vector is returned; if 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 float
\f0\fs20 , the C++ function 
\f1\fs18 fabs()
\f0\fs20  is used and a 
\f1\fs18 float
\f0\fs20  vector is returned.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)acos(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b arc cosine
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 acos()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)asin(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b arc sine
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 asin()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)atan(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b arc tangent
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 atan()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)atan2(numeric
\f2 \'a0
\f1 x, numeric
\f2 \'a0
\f1 y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b arc tangent
\b0  of 
\f1\fs18 y/x
\f0\fs20  using the C++ function 
\f1\fs18 atan2()
\f0\fs20 , which uses the signs of both x and y to determine the correct quadrant for the result.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)ceil(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b ceiling
\b0  of 
\f1\fs18 x
\f0\fs20 : the smallest integral value greater than or equal to 
\f1\fs18 x
\f0\fs20 .  Note that the return value is 
\f1\fs18 float
\f0\fs20  even though integral values are guaranteed, because values could be outside of the range representable by 
\f1\fs18 integer
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)cos(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b cosine
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 cos()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric)cumProduct(numeric
\f2 \'a0
\f1 x)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b cumulative product
\b0  of 
\f1\fs18 x
\f0\fs20 : a vector of equal length as 
\f1\fs18 x
\f0\fs20 , in which the element at index 
\f1\fs18 i
\f0\fs20  is equal to the product of the elements of 
\f1\fs18 x
\f0\fs20  across the range 
\f1\fs18 0:i
\f2\fs20 .
\f0   The return type will match the type of 
\f1\fs18 x
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  is of type 
\f1\fs18 integer
\f0\fs20 , but all of the values of the cumulative product vector cannot be represented in that type, an error condition will result.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric)cumSum(numeric
\f2 \'a0
\f1 x)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b cumulative sum
\b0  of 
\f1\fs18 x
\f0\fs20 : a vector of equal length as 
\f1\fs18 x
\f0\fs20 , in which the element at index 
\f1\fs18 i
\f0\fs20  is equal to the sum of the elements of 
\f1\fs18 x
\f0\fs20  across the range 
\f1\fs18 0:i
\f2\fs20 .
\f0   The return type will match the type of 
\f1\fs18 x
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  is of type 
\f1\fs18 integer
\f0\fs20 , but all of the values of the cumulative sum vector cannot be represented in that type, an error condition will result.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)exp(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b base-
\i e
\i0  exponential
\b0  of 
\f1\fs18 x, 
\f3\i e
\f1\i0 \super x
\f0\fs20 \nosupersub ,  using the C++ function 
\f1\fs18 exp()
\f2\fs20 .
\f0   This may be somewhat faster than 
\f1\fs18 E^x
\f0\fs20  for large vectors.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)floor(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b floor
\b0  of 
\f1\fs18 x
\f0\fs20 : the largest integral value less than or equal to 
\f1\fs18 x
\f2\fs20 .
\f0   Note that the return value is 
\f1\fs18 float
\f0\fs20  even though integral values are guaranteed, because values could be outside of the range representable by 
\f1\fs18 integer
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)integerDiv(integer\'a0x, integer\'a0y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the result of 
\b integer division
\b0  of 
\f1\fs18 x
\f0\fs20  by 
\f1\fs18 y
\f0\fs20 .  The 
\f1\fs18 /
\f0\fs20  operator in Eidos always produces a 
\f1\fs18 float
\f0\fs20  result; if you want an 
\f1\fs18 integer
\f0\fs20  result you may use this function instead.  If any value of 
\f1\fs18 y
\f0\fs20  is 
\f1\fs18 0
\f0\fs20 , an error will result.  The parameters 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must either be of equal length, or one of the two must be a singleton.  The precise behavior of 
\f1\fs18 integer
\f0\fs20  division, in terms of how rounding and negative values are handled, may be platform dependent; it will be whatever the C++ behavior of 
\f1\fs18 integer
\f0\fs20  division is on the given platform.  Eidos does not guarantee any particular behavior, so use this function with caution.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)integerMod(integer\'a0x
\f2 ,
\f1  integer\'a0y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the result of 
\b integer modulo
\b0  of 
\f1\fs18 x
\f0\fs20  by 
\f1\fs18 y
\f0\fs20 .  The 
\f1\fs18 %
\f0\fs20  operator in Eidos always produces a 
\f1\fs18 float
\f0\fs20  result; if you want an 
\f1\fs18 integer
\f0\fs20  result you may use this function instead.  If any value of 
\f1\fs18 y
\f0\fs20  is 
\f1\fs18 0
\f0\fs20 , an error will result.  The parameters 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must either be of equal length, or one of the two must be a singleton.  The precise behavior of 
\f1\fs18 integer
\f0\fs20  modulo, in terms of how rounding and negative values are handled, may be platform dependent; it will be whatever the C++ behavior of 
\f1\fs18 integer
\f0\fs20  modulo is on the given platform.  Eidos does not guarantee any particular behavior, so use this function with caution.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical)isFinite(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b finiteness
\b0  of 
\f1\fs18 x
\f0\fs20 : 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  is not 
\f1\fs18 INF
\f0\fs20  or 
\f1\fs18 NAN
\f0\fs20 , 
\f1\fs18 F
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 INF
\f0\fs20  or 
\f1\fs18 NAN
\f2\fs20 .
\f0   
\f1\fs18 INF
\f0\fs20  and 
\f1\fs18 NAN
\f0\fs20  are defined only for type 
\f1\fs18 float
\f0\fs20 , so x is required to be a 
\f1\fs18 float
\f2\fs20 .
\f0   Note that 
\f1\fs18 isFinite()
\f0\fs20  is not the opposite of 
\f1\fs18 isInfinite()
\f0\fs20 , because 
\f1\fs18 NAN
\f0\fs20  is considered to be neither finite nor infinite.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical)isInfinite(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b infiniteness
\b0  of 
\f1\fs18 x
\f0\fs20 : 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 INF
\f0\fs20 , 
\f1\fs18 F
\f0\fs20  otherwise.  
\f1\fs18 INF
\f0\fs20  is defined only for type 
\f1\fs18 float
\f0\fs20 , so x is required to be a 
\f1\fs18 float
\f0\fs20 .  Note that 
\f1\fs18 isInfinite()
\f0\fs20  is not the opposite of 
\f1\fs18 isFinite()
\f0\fs20 , because 
\f1\fs18 NAN
\f0\fs20  is considered to be neither finite nor infinite.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical)isNAN(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b undefinedness
\b0  of 
\f1\fs18 x
\f0\fs20 : 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  is not 
\f1\fs18 NAN
\f0\fs20 , 
\f1\fs18 F
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 NAN
\f2\fs20 .
\f0   
\f1\fs18 NAN
\f0\fs20  is defined only for type 
\f1\fs18 float
\f0\fs20 , so x is required to be a 
\f1\fs18 float
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)log(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b base-
\i e
\i0  logarithm
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 log()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)log10(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b base-10 logarithm
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 log10()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)log2(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b base-2 logarithm
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 log2()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric$)product(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b product
\b0  of 
\f1\fs18 x
\f0\fs20 : the result of multiplying all of the elements of 
\f1\fs18 x
\f0\fs20  together.  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 float
\f0\fs20 , the result will be 
\f1\fs18 float
\f0\fs20 .  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 integer
\f0\fs20 , things are a bit more complex; the result will be 
\f1\fs18 integer
\f0\fs20  if it can fit into the 
\f1\fs18 integer
\f0\fs20  type without overflow issues (including during intermediate stages of the computation), otherwise it will be 
\f1\fs18 float
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)round(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b round
\b0  of 
\f1\fs18 x
\f0\fs20 : the integral value nearest to 
\f1\fs18 x
\f0\fs20 , rounding half-way cases away from 
\f1\fs18 0
\f0\fs20 .  Note that the return value is 
\f1\fs18 float
\f0\fs20  even though integral values are guaranteed, because values could be outside of the range representable by 
\f1\fs18 integer
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)sin(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b sine
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 sin()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)sqrt(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b square root
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 sqrt()
\f2\fs20 .
\f0   This may be somewhat faster than 
\f1\fs18 x^0.5
\f0\fs20  for large vectors.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric$)sum(lif\'a0x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b sum
\b0  of 
\f1\fs18 x
\f0\fs20 : the result of adding all of the elements of 
\f1\fs18 x
\f0\fs20  together.  The unusual parameter type signature 
\f1\fs18 lif
\f0\fs20  indicates that 
\f1\fs18 x
\f0\fs20  can be 
\f1\fs18 logical
\f0\fs20 , 
\f1\fs18 integer
\f0\fs20 , or 
\f1\fs18 float
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 float
\f0\fs20 , the result will be 
\f1\fs18 float
\f0\fs20 .  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 logical
\f0\fs20 , the result will be 
\f1\fs18 integer
\f0\fs20  (the number of 
\f1\fs18 T
\f0\fs20  values in 
\f1\fs18 x
\f0\fs20 , since the 
\f1\fs18 integer
\f0\fs20  values of 
\f1\fs18 T
\f0\fs20  and 
\f1\fs18 F
\f0\fs20  are 
\f1\fs18 1
\f0\fs20  and 
\f1\fs18 0
\f0\fs20  respectively).  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 integer
\f0\fs20 , things are a bit more complex; in this case, the result will be 
\f1\fs18 integer
\f0\fs20  if it can fit into the 
\f1\fs18 integer
\f0\fs20  type without overflow issues (including during intermediate stages of the computation), otherwise it will be 
\f1\fs18 float
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)tan(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b tangent
\b0  of 
\f1\fs18 x
\f0\fs20  using the C++ function 
\f1\fs18 tan()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)trunc(float
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b truncation
\b0  of 
\f1\fs18 x
\f0\fs20 : the integral value nearest to, but no larger in magnitude than, 
\f1\fs18 x
\f0\fs20 .  Note that the return value is 
\f1\fs18 float
\f0\fs20  even though integral values are guaranteed, because values could be outside of the range representable by 
\f1\fs18 integer
\f2\fs20 .\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.2.  Summary statistics functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (+$)max(+\'a0x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b maximum
\b0  of 
\f1\fs18 x
\f0\fs20 : the greatest value it contains.  The return type will match that of 
\f1\fs18 x
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  has a size of 
\f1\fs18 0
\f0\fs20 , the return value will be 
\f1\fs18 NULL
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float$)mean(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b arithmetic mean
\b0  of 
\f1\fs18 x
\f0\fs20 : the sum of 
\f1\fs18 x
\f0\fs20  divided by the number of values in 
\f1\fs18 x
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  has a size of 
\f1\fs18 0
\f0\fs20 , the return value will be 
\f1\fs18 NULL
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (+$)min(+\'a0x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b minimum
\b0  of 
\f1\fs18 x
\f0\fs20 : the least value it contains.  The return type will match that of 
\f1\fs18 x
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  has a size of 
\f1\fs18 0
\f0\fs20 , the return value will be 
\f1\fs18 NULL
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (+)pmax(+\'a0x, +\'a0y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b parallel maximum
\b0  of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 : the element-wise maximum for each corresponding pair of elements in 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 .  Both the type and the size of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must match, and the returned value will have the same type and size.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (+)pmin(+\'a0x, +\'a0y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b parallel minimum
\b0  of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 : the element-wise minimum for each corresponding pair of elements in 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20 .  Both the type and the size of 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  must match, and the returned value will have the same type and size.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric)range(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b range
\b0  of 
\f1\fs18 x
\f0\fs20 , a vector of length 
\f1\fs18 2
\f0\fs20  composed of the minimum and maximum values of 
\f1\fs18 x
\f0\fs20  at indices 
\f1\fs18 0
\f0\fs20  and 
\f1\fs18 1
\f0\fs20 , respectively.  The return type will match that of 
\f1\fs18 x
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  has a size of 
\f1\fs18 0
\f0\fs20 , the return value will be 
\f1\fs18 NULL
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float$)sd(numeric
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b corrected sample standard deviation
\b0  of 
\f1\fs18 x
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  has a size of 
\f1\fs18 0
\f0\fs20  or 
\f1\fs18 1
\f2\fs20 ,
\f0  the return value will be 
\f1\fs18 NULL
\f2\fs20 .\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.3.  Distribution drawing and density functions\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (float)dnorm(float\'a0x, [numeric\'a0mean], [numeric\'a0sd])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\b probability densities for a normal distribution
\b0  at quantiles 
\f1\fs18 x
\f0\fs20  with mean 
\f1\fs18 mean
\f0\fs20  and standard deviation 
\f1\fs18 sd
\f0\fs20 .  The 
\f1\fs18 mean
\f0\fs20  and 
\f1\fs18 sd
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the densities, or they may be vectors of the same length as 
\f1\fs18 x
\f0\fs20 , specifying a value for each density computation.  By default, 
\f1\fs18 mean
\f0\fs20  is 
\f1\fs18 0.0
\f0\fs20  and 
\f1\fs18 sd
\f0\fs20  is 
\f1\fs18 1.0
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)rbinom(integer$
\f2 \'a0
\f1 n, integer\'a0size, float\'a0prob)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a binomial distribution
\b0  with a number of trials specified by 
\f1\fs18 size
\f0\fs20  and a probability of success specified by 
\f1\fs18 prob
\f0\fs20 .  The 
\f1\fs18 size
\f0\fs20  and 
\f1\fs18 prob
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)rexp(integer$
\f2 \'a0
\f1 n, [numeric\'a0mu])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from an exponential distribution
\b0  with mean 
\f1\fs18 mu
\f0\fs20  (i.e. rate 
\f1\fs18 1/mu
\f0\fs20 ).  The 
\f1\fs18 mu
\f0\fs20  parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.  By default, 
\f1\fs18 mu
\f0\fs20  is 
\f1\fs18 1.0
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)rgamma(integer$
\f2 \'a0
\f1 n, numeric\'a0mean, numeric\'a0shape)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a gamma distribution
\b0  with mean 
\f1\fs18 mean
\f0\fs20  and shape parameter 
\f1\fs18 shape
\f0\fs20 .  The 
\f1\fs18 mean
\f0\fs20  and 
\f1\fs18 shape
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.  Draws are made from a gamma distribution with probability density 
\f2\i P
\i0 (
\i s
\i0 \'a0|\'a0
\f4\i \uc0\u945 
\f2\i0 ,
\f4\i \uc0\u946 
\f2\i0 )\'a0= [
\f4 \uc0\u915 
\f2 (
\f4\i \uc0\u945 
\f2\i0 )
\f4\i \uc0\u946 \u945 
\f2\i0 ]\super \uc0\u8722 1\nosupersub exp(\uc0\u8722 
\i s
\i0 /
\f4\i \uc0\u946 
\f2\i0 )
\f0 , where 
\f4\i \uc0\u945 
\f0\i0  is the shape parameter 
\f1\fs18 shape
\f0\fs20 , and the mean of the distribution given by 
\f1\fs18 mean
\f0\fs20  is equal to 
\f4\i \uc0\u945 \u946 
\f2\i0 .
\f0   Values of 
\f1\fs18 mean
\f0\fs20  less than zero are allowed, and are equivalent (in principle) to the negation of a draw from a gamma distribution with the same 
\f1\fs18 shape
\f0\fs20  parameter and the negation of the 
\f1\fs18 mean
\f0\fs20  parameter.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)rlnorm(integer$
\f2 \'a0
\f1 n, [numeric\'a0meanlog], [numeric\'a0sdlog])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a lognormal distribution
\b0  with mean 
\f1\fs18 meanlog
\f0\fs20  and standard deviation 
\f1\fs18 sdlog
\f0\fs20 , specified on the log scale.  The 
\f1\fs18 meanlog
\f0\fs20  and 
\f1\fs18 sdlog
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.  By default, 
\f1\fs18 meanlog
\f0\fs20  is 
\f1\fs18 0.0
\f0\fs20  and 
\f1\fs18 sdlog
\f0\fs20  is 
\f1\fs18 1.0
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)rnorm(integer$
\f2 \'a0
\f1 n, [numeric\'a0mean], [numeric\'a0sd])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a normal distribution
\b0  with mean 
\f1\fs18 mean
\f0\fs20  and standard deviation 
\f1\fs18 sd
\f0\fs20 .  The 
\f1\fs18 mean
\f0\fs20  and 
\f1\fs18 sd
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.  By default, 
\f1\fs18 mean
\f0\fs20  is 
\f1\fs18 0.0
\f0\fs20  and 
\f1\fs18 sd
\f0\fs20  is 
\f1\fs18 1.0
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)rpois(integer$
\f2 \'a0
\f1 n, numeric\'a0lambda)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a Poisson distribution
\b0  with parameter 
\f1\fs18 lambda
\f0\fs20  (not to be confused with the language concept of a \'93lambda\'94; 
\f1\fs18 lambda
\f0\fs20  here is just the name of a parameter, because the symbol typically used for the parameter of a Poisson distribution is the Greek letter 
\f4 \uc0\u955 
\f0 ).  The 
\f1\fs18 lambda
\f0\fs20  parameter may either be a singleton, specifying a single value to be used for all of the draws, or it may be a vector of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)runif(integer$\'a0n, [numeric\'a0min], [numeric\'a0max])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a uniform distribution
\b0  from 
\f1\fs18 min
\f0\fs20  to 
\f1\fs18 max
\f0\fs20 , inclusive.  The 
\f1\fs18 min
\f0\fs20  and 
\f1\fs18 max
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.  By default, 
\f1\fs18 min
\f0\fs20  is 
\f1\fs18 0.0
\f0\fs20  and 
\f1\fs18 max
\f0\fs20  is 
\f1\fs18 1.0
\f2\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)rweibull(integer$
\f2 \'a0
\f1 n, numeric\'a0lambda, numeric\'a0k)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 n
\f0\fs20  
\b random draws from a Weibull distribution
\b0  with scale parameter 
\f1\fs18 lambda
\f0\fs20  and shape parameter 
\f1\fs18 k
\f0\fs20 , both greater than zero.  The 
\f1\fs18 lambda
\f0\fs20  and 
\f1\fs18 k
\f0\fs20  parameters may either be singletons, specifying a single value to be used for all of the draws, or they may be vectors of length 
\f1\fs18 n
\f0\fs20 , specifying a value for each draw.  Draws are made from a Weibull distribution with probability distribution 
\f2\i P
\i0 (
\i s
\i0 \'a0|\'a0
\f4\i \uc0\u955 
\f2\i0 ,
\i k
\i0 )\'a0=\'a0(
\i k
\i0  / 
\f4\i \uc0\u955 
\f2 \super k
\i0 \nosupersub )\'a0
\i s\super k
\i0 \uc0\u8722 1\nosupersub \'a0exp(-(
\i s
\i0 /
\f4\i \uc0\u955 
\f2\i0 )
\i \super k
\i0 \nosupersub ).\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.4.  Vector construction functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (*)c(...)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b concatenation
\b0  of all of its parameters into a single vector.  The parameters will be promoted to the highest type represented among them, and that type will be the return type.  
\f1\fs18 NULL
\f0\fs20  values are ignored; they have no effect on the result.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (float)float(integer$
\f2 \'a0
\f1 length)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b new 
\f5\fs18 float
\f0\fs20  vector
\b0  of the length specified by 
\f1\fs18 length
\f0\fs20 , filled with 
\f1\fs18 0.0
\f0\fs20  values.  This can be useful for pre-allocating a vector which you then fill with values by subscripting.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)integer(integer$
\f2 \'a0
\f1 length)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b new 
\f5\fs18 integer
\f0\fs20  vector
\b0  of the length specified by 
\f1\fs18 length
\f0\fs20 , filled with 
\f1\fs18 0
\f0\fs20  values.  This can be useful for pre-allocating a vector which you then fill with values by subscripting.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical)logical(integer$
\f2 \'a0
\f1 length)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b new 
\f5\fs18 logical
\f0\fs20  vector
\b0  of the length specified by 
\f1\fs18 length
\f0\fs20 , filled with 
\f1\fs18 F
\f0\fs20  values.  This can be useful for pre-allocating a vector which you then fill with values by subscripting.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (object<undefined>)object(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b new empty 
\f5\fs18 object
\f0\fs20  vector
\b0 .  Unlike 
\f1\fs18 float()
\f0\fs20 , 
\f1\fs18 integer()
\f0\fs20 , 
\f1\fs18 logical()
\f0\fs20 , and 
\f1\fs18 string()
\f0\fs20 , a length cannot be specified and the new vector contains no elements.  This is because there is no default value for the object type.  Adding to such a vector is typically done with 
\f1\fs18 c()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)rep(*
\f2 \'a0
\f1 x, integer$
\f2 \'a0
\f1 count)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b repetition
\b0  of 
\f1\fs18 x
\f0\fs20 : the entirety of 
\f1\fs18 x
\f0\fs20  is repeated 
\f1\fs18 count
\f0\fs20  times.  The return type matches the type of 
\f1\fs18 x
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)repEach(*
\f2 \'a0
\f1 x, integer
\f2 \'a0
\f1 count)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b repetition of elements
\b0  of 
\f1\fs18 x
\f0\fs20 : each element of 
\f1\fs18 x
\f0\fs20  is repeated.  If 
\f1\fs18 count
\f0\fs20  is a singleton, it specifies the number of times that each element of 
\f1\fs18 x
\f0\fs20  will be repeated.  Otherwise, the length of 
\f1\fs18 count
\f0\fs20  must be equal to the length of 
\f1\fs18 x
\f0\fs20 ; in this case, each element of 
\f1\fs18 x
\f0\fs20  is repeated a number of times specified by the corresponding value of 
\f1\fs18 count
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)sample(*\'a0x, integer$\'a0size, [logical$
\f2 \'a0
\f1 replace], [numeric\'a0weights])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of 
\f1\fs18 size
\f0\fs20  containing a 
\b sample from the elements of 
\f5\fs18 x
\f0\b0\fs20 .  If 
\f1\fs18 replace
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , sampling is conducted with replacement (the same element may be drawn more than once); if it is 
\f1\fs18 F
\f0\fs20  sampling is done without replacement.  If 
\f1\fs18 replace
\f0\fs20  is not specified, it is 
\f1\fs18 F
\f0\fs20  by default.  A vector of weights may be supplied in 
\f1\fs18 weights
\f0\fs20 ; if supplied, it must be equal in size to 
\f1\fs18 x
\f0\fs20 , all weights must be non-negative, and the sum of the weights must be greater than 
\f1\fs18 0
\f0\fs20 .  If 
\f1\fs18 weights
\f0\fs20  is not supplied, equal weights are used for all elements of 
\f1\fs18 x
\f0\fs20 .  An error occurs if 
\f1\fs18 sample()
\f0\fs20  runs out of viable elements from which to draw; most notably, if sampling is done without replacement then 
\f1\fs18 size
\f0\fs20  must be at most equal to the size of 
\f1\fs18 x
\f0\fs20 , but if weights of zero are supplied then the restriction on 
\f1\fs18 size
\f0\fs20  will be even more stringent.  The draws are obtained from the standard Eidos random number generator, which might be shared with the Context.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (numeric)seq(numeric$
\f2 \'a0
\f1 from, numeric$
\f2 \'a0
\f1 to, [numeric$
\f2 \'a0
\f1 by])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b sequence
\b0 , starting at 
\f1\fs18 from
\f0\fs20  and proceeding in the direction of 
\f1\fs18 to
\f0\fs20  until the next value in the sequence would fall beyond 
\f1\fs18 to
\f0\fs20 .  By default, the sequence steps by values of 
\f1\fs18 1
\f0\fs20  or 
\f1\fs18 -1
\f0\fs20  (as needed to proceed in the direction of 
\f1\fs18 to
\f0\fs20 ); a different step value may optionally be supplied in 
\f1\fs18 by
\f2\fs20 .
\f0   If 
\f1\fs18 from
\f0\fs20 , 
\f1\fs18 to
\f0\fs20 , and 
\f1\fs18 by
\f0\fs20  are all 
\f1\fs18 integer
\f0\fs20  then the return type will be 
\f1\fs18 integer
\f0\fs20 , otherwise it will be 
\f1\fs18 float
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)seqAlong(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns an 
\b index sequence
\b0 , from 
\f1\fs18 0
\f0\fs20  to 
\f1\fs18 size(x) - 1
\f0\fs20 , with a step of 
\f1\fs18 1
\f0\fs20 .  This is a convenience function for easily obtaining a set of indices to address or iterate through a vector.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string)string(integer$
\f2 \'a0
\f1 length)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b new 
\f5\fs18 string
\f0\fs20  vector
\b0  of the length specified by 
\f1\fs18 length
\f0\fs20 , filled with 
\f1\fs18 ""
\f0\fs20  values.  This can be useful for pre-allocating a vector which you then fill with values by subscripting.
\f2 \
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.5.  Value inspection & manipulation functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (logical$)all(logical
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\b all values are 
\f5\fs18 T
\f0\b0\fs20  in 
\f1\fs18 x
\f0\fs20 ; if any value is 
\f1\fs18 F
\f0\fs20 , returns 
\f1\fs18 F
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  is zero-length, 
\f1\fs18 T
\f0\fs20  is returned.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)any(logical
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\b any value is 
\f5\fs18 T
\f0\b0\fs20  in 
\f1\fs18 x
\f0\fs20 ; if all values are 
\f1\fs18 F
\f0\fs20 , returns 
\f1\fs18 F
\f2\fs20 .
\f0   If 
\f1\fs18 x
\f0\fs20  is zero-length, 
\f1\fs18 F
\f0\fs20  is returned.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)cat(*
\f2 \'a0
\f1 x, [string$
\f2 \'a0
\f1 sep])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Concatenates output
\b0  to Eidos\'92s output stream, joined together by 
\f1\fs18 sep
\f0\fs20 .  The value 
\f1\fs18 x
\f0\fs20  that is output may be of any type.  By default, sep is a single space, 
\f1\fs18 " "
\f0\fs20 .  A newline is not appended to the output, unlike the behavior of 
\f1\fs18 print()
\f2\fs20 .
\f0   Also unlike 
\f1\fs18 print()
\f0\fs20 , 
\f1\fs18 cat()
\f0\fs20  tends to emit very literal output; 
\f1\fs18 print(logical(0))
\f0\fs20  will emit \'93
\f1\fs18 logical(0)
\f0\fs20 \'94, for example \'96 showing a semantic interpretation of the value \'96 whereas 
\f1\fs18 cat(logical(0))
\f0\fs20  will emit nothing at all, since there are no elements in the value (it is zero-length).  Similarly, 
\f1\fs18 print(NULL)
\f0\fs20  will emit \'93
\f1\fs18 NULL
\f0\fs20 \'94, but 
\f1\fs18 cat(NULL)
\f0\fs20  will emit nothing.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)identical(*\'a0x, *\'a0y)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\f1\fs18 logical
\f0\fs20  value indicating 
\b whether two values are identical
\b0 .  If 
\f1\fs18 x
\f0\fs20  and 
\f1\fs18 y
\f0\fs20  have exactly the same type and size, and all of their corresponding elements are exactly the same, this will return 
\f1\fs18 T
\f0\fs20 , otherwise it will return 
\f1\fs18 F
\f0\fs20 .  The test here is for 
\i exact
\i0  equality; an 
\f1\fs18 integer
\f0\fs20  value of 
\f1\fs18 1
\f0\fs20  is not considered identical to a 
\f1\fs18 float
\f0\fs20  value of 
\f1\fs18 1.0
\f0\fs20 , for example.  Elements in 
\f1\fs18 object
\f0\fs20  values must be literally the same element, not simply identical in all of their properties.  Type promotion is never done.  For testing whether two values are the same, this is generally preferable to the use of operator\'a0
\f1\fs18 ==
\f0\fs20  or operator\'a0
\f1\fs18 !=
\f0\fs20 ; see the discussion at section 2.5.1.  Note that 
\f1\fs18 identical(NULL,NULL)
\f0\fs20  is 
\f1\fs18 T
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)ifelse(logical\'a0test, *\'a0trueValues, *\'a0falseValues)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the result of a 
\b vector conditional
\b0  operation: a vector composed of values from 
\f1\fs18 trueValues
\f0\fs20 , for indices where 
\f1\fs18 test
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , and values from 
\f1\fs18 falseValues
\f0\fs20 , for indices where 
\f1\fs18 test
\f0\fs20  is 
\f1\fs18 F
\f0\fs20 .  The lengths of 
\f1\fs18 trueValues
\f0\fs20  and 
\f1\fs18 falseValues
\f0\fs20  must either be equal to 
\f1\fs18 1
\f0\fs20  or to the length of 
\f1\fs18 test
\f0\fs20 ; however, 
\f1\fs18 trueValues
\f0\fs20  and 
\f1\fs18 falseValues
\f0\fs20  don\'92t need to be the same length as each other.  Furthermore, the type of 
\f1\fs18 trueValues
\f0\fs20  and 
\f1\fs18 falseValues
\f0\fs20  must be the same (including, if they are 
\f1\fs18 object
\f0\fs20  type, their element type).  The return will be of the same length as 
\f1\fs18 test
\f0\fs20 , and of the same type as 
\f1\fs18 trueValues
\f0\fs20  and 
\f1\fs18 falseValues
\f0\fs20 .  Each element of the return vector will be taken from the corresponding element of 
\f1\fs18 trueValues
\f0\fs20  if the corresponding element of 
\f1\fs18 test
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , or from the corresponding element of 
\f1\fs18 falseValues
\f0\fs20  if the corresponding element of 
\f1\fs18 test
\f0\fs20  is 
\f1\fs18 F
\f0\fs20 ; if the vector from which the value is to be taken (i.e., 
\f1\fs18 trueValues
\f0\fs20  or 
\f1\fs18 falseValues
\f0\fs20 ) has a length of 
\f1\fs18 1
\f0\fs20 , that single value is used repeatedly, recycling the vector.\
This is quite similar to a function in R of the same name; note, however, that Eidos evaluates all arguments to functions calls immediately, so 
\f1\fs18 trueValues
\f0\fs20  and 
\f1\fs18 falseValues
\f0\fs20  will be evaluated fully regardless of the values in 
\f1\fs18 test
\f0\fs20 , unlike in R.  Value expressions without side effects are therefore recommended.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)match(*\'a0x, *\'a0table)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of the 
\b positions of (first) matches
\b0  of 
\f1\fs18 x
\f0\fs20  in 
\f1\fs18 table
\f0\fs20 .  Type promotion is not performed; x and 
\f1\fs18 table
\f0\fs20  must be of the same type.  For each element of 
\f1\fs18 x
\f0\fs20 , the corresponding element in the result will give the position of the first match for that element of 
\f1\fs18 x
\f0\fs20  in 
\f1\fs18 table
\f0\fs20 ; if the element has no match in 
\f1\fs18 table
\f0\fs20 , the element in the result vector will be 
\f1\fs18 -1
\f0\fs20 .  The result is therefore a vector of the same length as 
\f1\fs18 x
\f0\fs20 .  If a 
\f1\fs18 logical
\f0\fs20  result is desired, with 
\f1\fs18 T
\f0\fs20  indicating that a match was found for the corresponding element of 
\f1\fs18 x
\f0\fs20 , use 
\f1\fs18 (match(x, table) >= 0)
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)nchar(string
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of the 
\b number of characters
\b0  in the string-elements of 
\f1\fs18 x
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)paste(*\'a0x, [string$
\f2 \'a0
\f1 sep])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b joined string
\b0  composed from the 
\f1\fs18 string
\f0\fs20  representations of the elements of 
\f1\fs18 x
\f0\fs20 , joined together by 
\f1\fs18 sep
\f0\fs20 .  By default, sep is a single space, 
\f1\fs18 " "
\f0\fs20 .  Although this function is based upon the R function of the same name, note that it is much simpler and less powerful; in particular, only the elements of a single vector may be joined, rather than the var-args functionality of the R 
\f1\fs18 paste()
\f2\fs20 .
\f0   The string representation used by 
\f1\fs18 paste()
\f0\fs20  is the same as that emitted by 
\f1\fs18 cat()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)print(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints output
\b0  to Eidos\'92s output stream.  The value 
\f1\fs18 x
\f0\fs20  that is output may be of any type.  A newline is appended to the output.  See 
\f1\fs18 cat()
\f0\fs20  for a discussion of the differences between 
\f1\fs18 print()
\f0\fs20  and 
\f1\fs18 cat()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)rev(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b reverse
\b0  of 
\f1\fs18 x
\f0\fs20 : a new vector with the same elements as 
\f1\fs18 x
\f0\fs20 , but in the opposite order.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer$)size(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b size
\b0  of 
\f1\fs18 x
\f0\fs20 : the number of elements contained in 
\f1\fs18 x
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (+)sort(+\'a0x, [logical$
\f2 \'a0
\f1 ascending])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b sorted copy
\b0  of x: a new vector with the same elements as x, but in ascending sorted order.  If the optional 
\f1\fs18 logical
\f0\fs20  value 
\f1\fs18 ascending
\f0\fs20  is 
\f1\fs18 F
\f0\fs20 , the sorted order will be descending.  The ordering is determined according to the same logic as the 
\f1\fs18 <
\f0\fs20  and 
\f1\fs18 >
\f0\fs20  operators in Eidos.  To sort an object vector, use 
\f1\fs18 sortBy()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (object)sortBy(object\'a0x, string$
\f2 \'a0
\f1 property, [logical$
\f2 \'a0
\f1 ascending])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b sorted copy
\b0  of x: a new vector with the same elements as x, but in ascending sorted order.  If the optional 
\f1\fs18 logical
\f0\fs20  value 
\f1\fs18 ascending
\f0\fs20  is 
\f1\fs18 F
\f0\fs20 , the sorted order will be descending.  The ordering is determined according to the same logic as the 
\f1\fs18 <
\f0\fs20  and 
\f1\fs18 >
\f0\fs20  operators in Eidos.  The 
\f1\fs18 property
\f0\fs20  argument gives the name of the property within the elements of 
\f1\fs18 x
\f0\fs20  according to which sorting should be done.  This must be a simple property name; it cannot be a property path.  For example, to sort a 
\f1\fs18 Mutation
\f0\fs20  vector by the selection coefficients of the mutations, you would simply pass 
\f1\fs18 "selectionCoeff"
\f0\fs20 , including the quotes, for 
\f1\fs18 property
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)str(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints the structure
\b0  of 
\f1\fs18 x
\f0\fs20 : a summary of its type and the values it contains.  If 
\f1\fs18 x
\f0\fs20  is an 
\f1\fs18 object
\f2\fs20 ,
\f0  note that 
\f1\fs18 str()
\f0\fs20  produces different results from the 
\f1\fs18 str()
\f0\fs20  method of 
\f1\fs18 x
\f0\fs20 ; the 
\f1\fs18 str()
\f0\fs20  function prints the external structure of 
\f1\fs18 x
\f0\fs20  (the fact that it is an object, and the number and type of its elements), whereas the 
\f1\fs18 str()
\f0\fs20  method prints the internal structure of 
\f1\fs18 x
\f0\fs20  (the external structure of all the properties contained by 
\f1\fs18 x
\f0\fs20 ).
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string)strsplit(string$
\f2 \'a0
\f1 x, [string$
\f2 \'a0
\f1 sep])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\b substrings
\b0  of 
\f1\fs18 x
\f0\fs20  that were separated by the separator string 
\f1\fs18 sep
\f0\fs20 .  By default, 
\f1\fs18 sep
\f0\fs20  is a single space, 
\f1\fs18 " "
\f0\fs20 .  Every substring defined by an occurrence of the separator is included, and thus zero-length substrings may be returned.  For example, 
\f1\fs18 strsplit(".foo..bar.", ".")
\f0\fs20  returns a string vector containing 
\f1\fs18 ""
\f0\fs20 , 
\f1\fs18 "foo"
\f0\fs20 , 
\f1\fs18 ""
\f0\fs20 , 
\f1\fs18 "bar"
\f0\fs20 , 
\f1\fs18 ""
\f0\fs20 .  In that example, the empty string between 
\f1\fs18 "foo"
\f0\fs20  and 
\f1\fs18 "bar"
\f0\fs20  in the returned vector is present because there were two periods between 
\f1\fs18 foo
\f0\fs20  and 
\f1\fs18 bar
\f0\fs20  in the input string \'96 the empty string is the substring between those two separators.  Note that 
\f1\fs18 paste()
\f0\fs20  performs the inverse operation of 
\f1\fs18 strsplit()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string)substr(string\'a0x, integer\'a0first, [integer\'a0last])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\b substrings
\b0  extracted from the elements of 
\f1\fs18 x,
\f0\fs20  spanning character position 
\f1\fs18 first
\f0\fs20  to character position 
\f1\fs18 last
\f0\fs20  (inclusive).  Character positions are numbered from 
\f1\fs18 0
\f0\fs20  to 
\f1\fs18 nchar(x)-1
\f0\fs20 .  Positions that fall outside of that range are legal; a substring range that encompasses no characters will produce an empty string.  If 
\f1\fs18 first
\f0\fs20  is greater than 
\f1\fs18 last
\f0\fs20 , an empty string will also result.  If 
\f1\fs18 last
\f0\fs20  is omitted, the substring will extend to the end of the string.  The parameters 
\f1\fs18 first
\f0\fs20  and 
\f1\fs18 last
\f0\fs20  may either be singletons, specifying a single value to be used for all of the substrings, or they may be vectors of the same length as 
\f1\fs18 x
\f0\fs20 , specifying a value for each substring.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)unique(*\'a0x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b unique values
\b0  in 
\f1\fs18 x
\f0\fs20 .  In other words, for each value 
\f1\fs18 k
\f0\fs20  in 
\f1\fs18 x
\f0\fs20  that occurs at least once, the vector returned will contain 
\f1\fs18 k
\f0\fs20  exactly once.  The order of values in 
\f1\fs18 x
\f0\fs20  is preserved, taking the first instance of each value.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)which(logical
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b indices of 
\f5\fs18 T
\f0\fs20  values
\b0  in 
\f1\fs18 x
\f0\fs20 .  In other words, if an index 
\f1\fs18 k
\f0\fs20  in 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , then the vector returned will contain 
\f1\fs18 k
\f0\fs20 ; if index 
\f1\fs18 k
\f0\fs20  in 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 F
\f0\fs20 , the vector returned will omit 
\f1\fs18 k
\f0\fs20 .  One way to look at this is that it converts from a 
\f1\fs18 logical
\f0\fs20  subsetting vector to an 
\f1\fs18 integer
\f0\fs20  (index-based) subsetting vector, without changing which subset positions would be selected.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)whichMax(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b index of the (first) maximum value
\b0  in 
\f1\fs18 x
\f0\fs20 .  In other words, if 
\f1\fs18 k
\f0\fs20  is equal to the maximum value in 
\f1\fs18 x
\f0\fs20 , then the vector returned will contain the index of the first occurrence of 
\f1\fs18 k
\f0\fs20  in 
\f1\fs18 x
\f2\fs20 .
\f0   If the maximum value is unique, the result is the same as (but more efficient than) the expression 
\f1\fs18 which(x==max(x))
\f0\fs20 , which returns the indices of 
\i all
\i0  of the occurrences of the maximum value in 
\f1\fs18 x
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)whichMin(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b index of the (first) minimum value
\b0  in 
\f1\fs18 x
\f0\fs20 .  In other words, if 
\f1\fs18 k
\f0\fs20  is equal to the minimum value in 
\f1\fs18 x
\f0\fs20 , then the vector returned will contain the index of the first occurrence of 
\f1\fs18 k
\f0\fs20  in 
\f1\fs18 x
\f0\fs20 .  If the minimum value is unique, the result is the same as (but more efficient than) the expression 
\f1\fs18 which(x==min(x))
\f0\fs20 , which returns the indices of 
\i all
\i0  of the occurrences of the minimum value in 
\f1\fs18 x
\f2\fs20 .\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.6.  Value type testing and coercion functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (float)asFloat(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b conversion to 
\f5\fs18 float
\f0\b0\fs20  of 
\f1\fs18 x
\f0\fs20 .  If 
\f1\fs18 x
\f0\fs20  is 
\f1\fs18 string
\f0\fs20  and cannot be converted to 
\f1\fs18 float
\f0\fs20 , Eidos will throw an error.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer)asInteger(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b conversion to 
\f5\fs18 integer
\f0\b0\fs20  of 
\f1\fs18 x
\f0\fs20 .  If 
\f1\fs18 x
\f0\fs20  is of type 
\f1\fs18 string
\f0\fs20  or 
\f1\fs18 float
\f0\fs20  and cannot be converted to 
\f1\fs18 integer
\f0\fs20 , Eidos will throw an error.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical)asLogical(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b conversion to 
\f5\fs18 logical
\f0\b0\fs20  of 
\f1\fs18 x
\f0\fs20 .  Recall that in Eidos the empty 
\f1\fs18 string
\f0\fs20  
\f1\fs18 ""
\f0\fs20  is considered 
\f1\fs18 F
\f0\fs20 , and all other 
\f1\fs18 string
\f0\fs20  values are considered 
\f1\fs18 T
\f2\fs20 .
\f0   Converting 
\f1\fs18 INF
\f0\fs20  or 
\f1\fs18 -INF
\f0\fs20  to 
\f1\fs18 logical
\f0\fs20  yields 
\f1\fs18 T
\f0\fs20  (since those values are not equal to zero); converting 
\f1\fs18 NAN
\f0\fs20  to 
\f1\fs18 logical
\f0\fs20  throws an error.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string)asString(+
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b conversion to 
\f5\fs18 string
\f0\b0\fs20  of 
\f1\fs18 x
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)elementType(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b element type
\b0  of 
\f1\fs18 x
\f0\fs20 , as a 
\f1\fs18 string
\f0\fs20 .  For the non-
\f1\fs18 object
\f0\fs20  types, the element type is the same as the type: 
\f1\fs18 "NULL"
\f0\fs20 , 
\f1\fs18 "logical"
\f0\fs20 , 
\f1\fs18 "integer"
\f0\fs20 , 
\f1\fs18 "float"
\f0\fs20 , or 
\f1\fs18 "string"
\f0\fs20 .  For 
\f1\fs18 object
\f0\fs20  type, however, 
\f1\fs18 elementType()
\f0\fs20  returns the name of the type of element contained by the object, such as 
\f1\fs18 "SLiMSim"
\f0\fs20  or 
\f1\fs18 "Mutation"
\f0\fs20  in the Context of SLiM.  Contrast this with 
\f1\fs18 type()
\f2\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isFloat(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f5\fs18 float
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isInteger(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f5\fs18 integer
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isLogical(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f5\fs18 logical
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isNULL(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f5\fs18 NULL
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isObject(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f5\fs18 object
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)isString(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f1\fs18 T
\f0\fs20  if 
\f1\fs18 x
\f0\fs20  
\b is 
\f5\fs18 string
\f0\fs20  type
\b0 , 
\f1\fs18 F
\f0\fs20  otherwise.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)type(*
\f2 \'a0
\f1 x)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b type
\b0  of 
\f1\fs18 x
\f0\fs20 , as a 
\f1\fs18 string
\f0\fs20 : 
\f1\fs18 "NULL"
\f0\fs20 , 
\f1\fs18 "logical"
\f0\fs20 , 
\f1\fs18 "integer"
\f0\fs20 , 
\f1\fs18 "float"
\f0\fs20 , 
\f1\fs18 "string"
\f0\fs20 , or 
\f1\fs18 "object"
\f0\fs20 .  Contrast this with 
\f1\fs18 elementType()
\f2\fs20 .\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 3.7.  Filesystem access functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (string)filesAtPath(string$\'a0path, [logical$\'a0fullPaths])
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\f1\fs18 string
\f0\fs20  vector containing the 
\b names of all files in a directory
\b0  specified by 
\f1\fs18 path
\f2\fs20 .
\f0   If 
\f1\fs18 fullPaths
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , full filesystem paths are returned for each file; if 
\f1\fs18 fullPaths
\f0\fs20  is 
\f1\fs18 F
\f0\fs20  or omitted, only the filenames relative to the specified directory are returned.  This list includes directories (i.e. subfolders), including the 
\f1\fs18 "."
\f0\fs20  and 
\f1\fs18 ".."
\f0\fs20  directories on Un*x systems.  The list also includes invisible files, such as those that begin with a 
\f1\fs18 "."
\f0\fs20  on Un*x systems.  This function does not descend recursively into subdirectories.  If an error occurs during the read, 
\f1\fs18 NULL
\f0\fs20  will be returned.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string)readFile(string$\'a0filePath)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Reads in the contents of a file
\b0  specified by 
\f1\fs18 filePath
\f0\fs20  and returns a 
\f1\fs18 string
\f0\fs20  vector containing the lines (separated by 
\f1\fs18 \\n
\f0\fs20  and 
\f1\fs18 \\r
\f0\fs20  characters) of the file.  Reading files other than text files is not presently supported.  If an error occurs during the read, 
\f1\fs18 NULL
\f0\fs20  will be returned.
\f2 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (logical$)writeFile(string$\'a0filePath, string\'a0contents, [logical$ append])
\f2 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Writes or appends to a file
\b0  specified by 
\f1\fs18 filePath
\f0\fs20  with contents specified by 
\f1\fs18 contents
\f0\fs20 , a 
\f1\fs18 string
\f0\fs20  vector of lines.  If 
\f1\fs18 append
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , the write will be appended to the existing file (if any) at 
\f1\fs18 filePath
\f0\fs20 ; if it is 
\f1\fs18 F
\f0\fs20  or omitted, the write will replace an existing file at that path.  Note that newline characters will be added at the ends of the lines in 
\f1\fs18 contents
\f0\fs20 .  If you do not wish to have newlines added, you should use 
\f1\fs18 paste()
\f0\fs20  to assemble the elements of 
\f1\fs18 contents
\f0\fs20  together into a singleton 
\f1\fs18 string
\f2\fs20 .
\f0   If the write is successful, 
\f1\fs18 T
\f0\fs20  will be returned; if not, 
\f1\fs18 F
\f0\fs20  will be returned.\
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\b\fs22 \cf0 3.8.  Miscellaneous functions\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\b0\fs18 \cf0 (*)apply(*\'a0x, string$\'a0lambdaSource)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Applies a block of Eidos code to the elements of a vector
\b0 .  This function is sort of a hybrid between 
\f1\fs18 c()
\f0\fs20  and 
\f1\fs18 executeLambda()
\f0\fs20 ; it might be useful to consult the documentation for both of those functions to better understand what 
\f1\fs18 apply()
\f0\fs20  does.  For each element in 
\f1\fs18 x
\f0\fs20 , the lambda defined by 
\f1\fs18 lambdaSource
\f0\fs20  will be called.  For the duration of that callout, a variable named 
\f1\fs18 applyValue
\f0\fs20  will be defined to have as its value the element of 
\f1\fs18 x
\f0\fs20  currently being processed.  The expectation is that the lambda will use 
\f1\fs18 applyValue
\f0\fs20  in some way, and will return either NULL or a new value (which need not be a singleton, and need not be of the same type as 
\f1\fs18 x
\f0\fs20 ).  The return value of 
\f1\fs18 apply()
\f0\fs20  is generated by concatenating together all of the individual vectors returned by the lambda, in exactly the same manner as the 
\f1\fs18 c()
\f0\fs20  function (including the possibility of type promotion).\
Since this function can be hard to understand at first, here is an example:\
\pard\tx990\tx1260\tx1530\tx1800\tx2070\tx2340\pardeftab397\li547\ri1440\sb180\sa180\partightenfactor0

\f1\fs18 \cf0 apply(1:10, "if (applyValue % 2) applyValue ^ 2;");
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 This produces the output 
\f1\fs18 1 9 25 49 81
\f0\fs20 .  The 
\f1\fs18 apply()
\f0\fs20  operation begins with the vector 
\f1\fs18 1:10
\f0\fs20 .  For each element of that vector, the lambda is called and 
\f1\fs18 applyValue
\f0\fs20  is defined with the element value.  In this respect, 
\f1\fs18 apply()
\f0\fs20  is actually very much like a 
\f1\fs18 for
\f0\fs20  loop.  If 
\f1\fs18 applyValue
\f0\fs20  is even (as evaluated by the modulo operator, 
\f1\fs18 %
\f0\fs20 ), the condition of the 
\f1\fs18 if
\f0\fs20  statement is 
\f1\fs18 F
\f0\fs20  and so 
\f1\fs18 NULL
\f0\fs20  is implicitly returned by the lambda (since the 
\f1\fs18 if
\f0\fs20  has no 
\f1\fs18 else
\f0\fs20  clause).  If 
\f1\fs18 applyValue
\f0\fs20  is odd, on the other hand, the lambda returns its square (as calculated by the exponential operator, 
\f1\fs18 ^
\f0\fs20 ).  Just as with the 
\f1\fs18 c()
\f0\fs20  function, 
\f1\fs18 NULL
\f0\fs20  values are dropped during concatenation, so the final result contains only the squares of the odd values.\
This example illustrates that the lambda can \'93drop\'94 values by returning 
\f1\fs18 NULL
\f0\fs20 , so 
\f1\fs18 apply()
\f0\fs20  can be used to select particular elements of a vector that satisfy some condition, much like the subscript operator, 
\f1\fs18 []
\f0\fs20 .  The example also illustrates that input and result types do not have to match; the vector passed in is 
\f1\fs18 integer
\f0\fs20 , whereas the result vector is 
\f1\fs18 float
\f2\fs20 .\

\f0 There is no scoping in Eidos, so as with 
\f1\fs18 executeLambda()
\f0\fs20 , all defined variables are accessible within the lambda, and changes made to variables inside the lambda will persist beyond the end of the 
\f1\fs18 apply()
\f0\fs20  call; the lambda is executing in the same scope as the rest of your code.\
The 
\f1\fs18 apply()
\f0\fs20  function can seem daunting at first, but it is an essential tool in the Eidos toolbox.  It combines the iteration of a 
\f1\fs18 for
\f0\fs20  loop, the ability to select elements like operator 
\f1\fs18 []
\f0\fs20 , and the ability to assemble results of mixed type together into a single vector like 
\f1\fs18 c()
\f0\fs20 , all with the power of arbitrary Eidos code execution like 
\f1\fs18 executeLambda()
\f0\fs20 .  It is much faster than calling 
\f1\fs18 executeLambda()
\f0\fs20  on each element of a vector using a 
\f1\fs18 for
\f0\fs20  loop; if the alternative to using 
\f1\fs18 apply()
\f0\fs20  is a 
\f1\fs18 for
\f0\fs20  loop that adds new values to a result vector one at a time, apply() is also likely to be much faster.  Like 
\f1\fs18 executeLambda()
\f0\fs20 , 
\f1\fs18 apply()
\f0\fs20  is most efficient if it is called multiple times with a single 
\f1\fs18 string
\f0\fs20  script variable, rather than with a newly constructed 
\f1\fs18 string
\f0\fs20  for 
\f1\fs18 lambdaSource
\f0\fs20  each time.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)date(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b standard date string
\b0  for the current date in the local time of the executing machine.  The format is 
\f1\fs18 %d-%m-%Y
\f0\fs20  (day in two digits, then month in two digits, then year in four digits, zero-padded and separated by dashes) regardless of the localization of the executing machine, for predictability and consistency.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)doCall(string$\'a0function, ...)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the results from a 
\b call to a specified function
\b0 .  The function named by the parameter 
\f1\fs18 function
\f0\fs20  is called, and the remaining parameters to 
\f1\fs18 doCall()
\f0\fs20  are forwarded on to that function verbatim.  This can be useful for calling one of a set of similar functions, such as 
\f1\fs18 sin()
\f0\fs20 , 
\f1\fs18 cos()
\f0\fs20 , etc., to perform a math function determined at runtime, or one of the 
\f1\fs18 as...()
\f0\fs20  family of functions to convert to a type determined at runtime.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (*)executeLambda(string$\'a0lambdaSource, [logical$\'a0timed])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Executes a block of Eidos code
\b0  defined by 
\f1\fs18 lambdaSource
\f0\fs20 .  It has been said at various points in this manual that Eidos does not allow you to define your own functions.  That is, strictly speaking, true.  However, it does allow you to execute 
\i lambdas
\i0 : blocks of Eidos code which can be called.  Eidos lambdas do not take arguments; for this reason, they are not first-class functions.  (They share the scope of the caller, however, so you may effectively pass values in and out of a lambda using global variables.)  The 
\f1\fs18 string
\f0\fs20  argument 
\f1\fs18 lambdaSource
\f0\fs20  may contain one or many Eidos statements as a single 
\f1\fs18 string
\f0\fs20  value.  Lambdas are represented, to the caller, only as the source code 
\f1\fs18 string
\f0\fs20  
\f1\fs18 lambdaSource
\f0\fs20 ; the executable code is not made available programmatically.  If an error occurs during the tokenization, parsing, or execution of the lambda, that error is raised as usual; executing code inside a lambda does not provide any additional protection against exceptions raised.  The return value produced by the code in the lambda is returned by 
\f1\fs18 executeLambda()
\f2\fs20 .
\f0   If the optional parameter 
\f1\fs18 timed
\f0\fs20  is 
\f1\fs18 T
\f0\fs20 , the total (user clock) execution time for the lambda will be printed after the lambda has completed; the default for 
\f1\fs18 timed
\f0\fs20  is 
\f1\fs18 F
\f2\fs20 .\

\f0 The current implementation of 
\f1\fs18 executeLambda()
\f0\fs20  caches a tokenized and parsed version of 
\f1\fs18 lambdaSource
\f0\fs20 , so calling 
\f1\fs18 executeLambda()
\f0\fs20  repeatedly on a single source 
\f1\fs18 string
\f0\fs20  is much more efficient than calling 
\f1\fs18 executeLambda()
\f0\fs20  with a newly constructed 
\f1\fs18 string
\f0\fs20  each time.  If you can use a 
\f1\fs18 string
\f0\fs20  literal for 
\f1\fs18 lambdaSource
\f0\fs20 , or reuse a constructed source 
\f1\fs18 string
\f0\fs20  stored a variable, that will improve performance considerably.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)function([string$
\f2 \'a0
\f1 functionName])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints function signatures
\b0  for all functions, or for the function named by 
\f1\fs18 functionName
\f0\fs20 , to Eidos\'92s output stream.  See section 2.7.3 for more information.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (integer$)getSeed(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the 
\b random number seed
\b0 .  This is the last seed value set using 
\f1\fs18 setSeed()
\f0\fs20 ; if 
\f1\fs18 setSeed()
\f0\fs20  has not been called, it will be a seed value chosen based on the process-id and the current time when Eidos was initialized, unless the Context has set a different seed value.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)license(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints Eidos\'92s license terms
\b0  to Eidos\'92s output stream.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)ls(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints all currently defined variables
\b0  to Eidos\'92s output stream.  See section 2.4.1 for more information.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)rm([string
\f2 \'a0
\f1 variableNames])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Removes global variables
\b0  from the Eidos namespace; in other words, it causes the variables to become undefined.  Variables are specified by their 
\f1\fs18 string
\f0\fs20  name in the 
\f1\fs18 variableNames
\f0\fs20  parameter.  If the optional 
\f1\fs18 variableNames
\f0\fs20  parameter is omitted, 
\i all
\i0  variables will be removed (be careful!).  Attempting to remove a constant is an error.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)setSeed(integer$\'a0seed)
\f2 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Set the random number seed
\b0 .  Future random numbers will be based upon the seed value set, and the random number sequence generated from a particular seed value is guaranteed to be reproducible.  The last seed set can be recovered with the 
\f1\fs18 getSeed()
\f0\fs20  function.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)stop([string$
\f2 \'a0
\f1 message])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Stops execution
\b0  of Eidos (and of the Context, such as the running SLiM simulation, if applicable), in the event of an error.  If the optional 
\f1\fs18 message
\f0\fs20  parameter is supplied it will be printed to Eidos\'92s output stream prior to stopping.
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (string$)time(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\b standard time string
\b0  for the current time in the local time of the executing machine.  The format is 
\f1\fs18 %H:%M:%S
\f0\fs20  (hour in two digits, then minute in two digits, then seconds in two digits, zero-padded and separated by dashes) regardless of the localization of the executing machine, for predictability and consistency.  The 24-hour clock time is used (i.e., no AM/PM).
\f2 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f1\fs18 \cf0 (void)version(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\b\fs20 \cf0 Prints Eidos\'92s version 
\b0 to Eidos\'92s output stream.}