{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Optima-Regular;\f1\fnil\fcharset0 Menlo-Italic;\f2\fnil\fcharset0 Menlo-Regular;
\f3\froman\fcharset0 TimesNewRomanPSMT;\f4\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww9000\viewh19740\viewkind0
\deftab720
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.2  Class Chromosome\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 5.2.1  
\f1\fs18 Chromosome
\f0\fs22  properties\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 colorSubstitution <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The color used to display substitutions in SLiMgui when both mutations and substitutions are being displayed in the chromosome view.  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f2\fs18 "#RRGGBB"
\f0\fs20 .  If 
\f2\fs18 colorSubstitution
\f0\fs20  is the empty string, 
\f2\fs18 ""
\f0\fs20 , SLiMgui will defer to the color scheme of each 
\f2\fs18 MutationType
\f0\fs20 , just as it does when only substitutions are being displayed.  The default, 
\f2\fs18 "3333FF"
\f0\fs20 , causes all substitutions to be shown as dark blue when displayed in conjunction with mutations, to prevent the view from becoming too noisy.  Note that when substitutions are displayed without mutations also being displayed, this value is ignored by SLiMgui and the substitutions use the color scheme of each 
\f2\fs18 MutationType
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 geneConversionFraction <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The fraction of crossover events that result in gene conversion; see SLiM\'92s manual for details.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 geneConversionMeanLength <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The mean length of a gene conversion event (in base positions).
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 genomicElements => (object<GenomicElement>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 All of the 
\f2\fs18 GenomicElement
\f0\fs20  objects that comprise the chromosome.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 lastPosition => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The last valid position in the chromosome; its length, essentially.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 mutationEndPositions => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for mutation rate regions along the chromosome.  Each mutation rate region is assumed to start at the position following the end of the previous mutation rate region; in other words, the regions are assumed to be contiguous.  When using sex-specific mutation rate maps, this property will unavailable; see 
\f2\fs18 mutationEndPositionsF
\f0\fs20  and 
\f2\fs18 mutationEndPositionsM
\f0\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationEndPositionsF => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for mutation rate regions for females, when using sex-specific mutation rate maps; unavailable otherwise.  See 
\f2\fs18 mutationEndPositions
\f0\fs20  for further explanation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationEndPositionsM => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for mutation rate regions for males, when using sex-specific mutation rate maps; unavailable otherwise.  See 
\f2\fs18 mutationEndPositions
\f0\fs20  for further explanation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationRates => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The mutation rate for each of the mutation rate regions specified by 
\f2\fs18 mutationEndPositions
\f0\fs20 .  When using sex-specific mutation rate maps, this property will be unavailable; see 
\f2\fs18 mutationRatesF
\f0\fs20  and 
\f2\fs18 mutationRatesM
\f0\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationRatesF => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The mutation rate for each of the mutation rate regions specified by 
\f2\fs18 mutationEndPositionsF
\f0\fs20 , when using sex-specific mutation rate maps; unavailable otherwise.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationRatesM => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The mutation rate for each of the mutation rate regions specified by 
\f2\fs18 mutationEndPositionsM
\f0\fs20 , when using sex-specific mutation rate maps; unavailable otherwise.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 overallMutationRate => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall mutation rate across the whole chromosome determining the overall number of mutation events that will occur anywhere in the chromosome, as calculated from the individual mutation ranges and rates as well as the coverage of the chromosome by genomic elements (since mutations are only generated within genomic elements, regardless of the mutation rate map).  When using sex-specific mutation rate maps, this property will unavailable; see 
\f2\fs18 overallMutationRateF
\f0\fs20  and 
\f2\fs18 overallMutationRateM
\f0\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 overallMutationRateF => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall mutation rate for females, when using sex-specific mutation rate maps; unavailable otherwise.  See 
\f2\fs18 overallMutationRate
\f0\fs20  for further explanation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 overallMutationRateM => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall mutation rate for males, when using sex-specific mutation rate maps; unavailable otherwise.  See 
\f2\fs18 overallMutationRate
\f0\fs20  for further explanation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 overallRecombinationRate => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall recombination rate across the whole chromosome determining the overall number of recombination events that will occur anywhere in the chromosome, as calculated from the individual recombination ranges and rates.  When using sex-specific recombination maps, this property will unavailable; see 
\f2\fs18 overallRecombinationRateF
\f0\fs20  and 
\f2\fs18 overallRecombinationRateM
\f0\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 overallRecombinationRateF => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall recombination rate for females, when using sex-specific recombination maps; unavailable otherwise.  See 
\f2\fs18 overallRecombinationRate
\f0\fs20  for further explanation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 overallRecombinationRateM => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The overall recombination rate for males, when using sex-specific recombination maps; unavailable otherwise.  See 
\f2\fs18 overallRecombinationRate
\f0\fs20  for further explanation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationEndPositions => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for recombination regions along the chromosome.  Each recombination region is assumed to start at the position following the end of the previous recombination region; in other words, the regions are assumed to be contiguous.  When using sex-specific recombination maps, this property will unavailable; see 
\f2\fs18 recombinationEndPositionsF
\f0\fs20  and 
\f2\fs18 recombinationEndPositionsM
\f0\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationEndPositionsF => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for recombination regions for females, when using sex-specific recombination maps; unavailable otherwise.  See 
\f2\fs18 recombinationEndPositions
\f0\fs20  for further explanation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationEndPositionsM => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The end positions for recombination regions for males, when using sex-specific recombination maps; unavailable otherwise.  See 
\f2\fs18 recombinationEndPositions
\f0\fs20  for further explanation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationRates => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The recombination rate for each of the recombination regions specified by 
\f2\fs18 recombinationEndPositions
\f0\fs20 .  When using sex-specific recombination maps, this property will unavailable; see 
\f2\fs18 recombinationRatesF
\f0\fs20  and 
\f2\fs18 recombinationRatesM
\f0\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationRatesF => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The recombination rate for each of the recombination regions specified by 
\f2\fs18 recombinationEndPositionsF
\f0\fs20 , when using sex-specific recombination maps; unavailable otherwise.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 recombinationRatesM => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The recombination rate for each of the recombination regions specified by 
\f2\fs18 recombinationEndPositionsM
\f0\fs20 , when using sex-specific recombination maps; unavailable otherwise.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value.  The value of 
\f2\fs18 tag
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.
\f3 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f0\i\fs22 \cf0 5.2.2  
\f1\fs18 Chromosome
\f0\fs22  methods\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 \'96\'a0(void)setMutationRate(numeric\'a0rates, [Ni\'a0ends\'a0=\'a0NULL], [string$\'a0sex\'a0=\'a0"*"])
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the mutation rate per base position per generation along the chromosome.  There are two ways to call this method.  If the optional 
\f2\fs18 ends
\f0\fs20  parameter is 
\f2\fs18 NULL
\f0\fs20  (the default), then 
\f2\fs18 rates
\f0\fs20  must be a singleton value that specifies a single mutation rate to be used along the entire chromosome.  If, on the other hand, 
\f2\fs18 ends
\f0\fs20  is supplied, then 
\f2\fs18 rates
\f0\fs20  and 
\f2\fs18 ends
\f0\fs20  must be the same length, and the values in 
\f2\fs18 ends
\f0\fs20  must be specified in ascending order.  In that case, 
\f2\fs18 rates
\f0\fs20  and 
\f2\fs18 ends
\f0\fs20  taken together specify the mutation rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in 
\f2\fs18 ends
\f0\fs20  should extend to the end of the chromosome (as previously determined, during simulation initialization).  See the 
\f2\fs18 initializeMutationRate()
\f0\fs20  function for further discussion of precisely how these rates and positions are interpreted.\
If the optional 
\f2\fs18 sex
\f0\fs20  parameter is 
\f2\fs18 "*"
\f0\fs20  (the default), then the supplied mutation rate map will be used for both sexes (which is the only option for hermaphroditic simulations).  In sexual simulations 
\f2\fs18 sex
\f0\fs20  may be 
\f2\fs18 "M"
\f0\fs20  or 
\f2\fs18 "F"
\f0\fs20  instead, in which case the supplied mutation rate map is used only for that sex.  Note that whether sex-specific mutation rate maps will be used is set by the way that the simulation is initially configured with 
\f2\fs18 initializeMutationRate()
\f0\fs20 , and cannot be changed with this method; so if the simulation was set up to use sex-specific mutation rate maps then sex must be 
\f2\fs18 "M"
\f0\fs20  or 
\f2\fs18 "F"
\f0\fs20  here, whereas if it was set up not to, then sex must be 
\f2\fs18 "*"
\f0\fs20  or unsupplied here.  If a simulation needs sex-specific mutation rate maps only some of the time, the male and female maps can simply be set to be identical the rest of the time.\
The mutation rate intervals are normally a constant in simulations, so be sure you know what you are doing.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)setRecombinationRate(numeric\'a0rates, [Ni\'a0ends\'a0=\'a0NULL], [string$\'a0sex\'a0=\'a0"*"])
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the recombination rate per base position per generation along the chromosome.  \cf2 \expnd0\expndtw0\kerning0
All rates must be in the interval [
\f2\fs18 0.0
\f0\fs20 , 
\f2\fs18 0.5
\f0\fs20 ].  \cf0 \kerning1\expnd0\expndtw0 There are two ways to call this method.  If the optional 
\f2\fs18 ends
\f0\fs20  parameter is 
\f2\fs18 NULL
\f0\fs20  (the default), then 
\f2\fs18 rates
\f0\fs20  must be a singleton value that specifies a single recombination rate to be used along the entire chromosome.  If, on the other hand, 
\f2\fs18 ends
\f0\fs20  is supplied, then 
\f2\fs18 rates
\f0\fs20  and 
\f2\fs18 ends
\f0\fs20  must be the same length, and the values in 
\f2\fs18 ends
\f0\fs20  must be specified in ascending order.  In that case, 
\f2\fs18 rates
\f0\fs20  and 
\f2\fs18 ends
\f0\fs20  taken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in 
\f2\fs18 ends
\f0\fs20  should extend to the end of the chromosome (as previously determined, during simulation initialization).  See the 
\f2\fs18 initializeRecombinationRate()
\f0\fs20  function for further discussion of precisely how these rates and positions are interpreted.\
If the optional 
\f2\fs18 sex
\f0\fs20  parameter is 
\f2\fs18 "*"
\f0\fs20  (the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations).  In sexual simulations 
\f2\fs18 sex
\f0\fs20  may be 
\f2\fs18 "M"
\f0\fs20  or 
\f2\fs18 "F"
\f0\fs20  instead, in which case the supplied recombination map is used only for that sex.  Note that whether sex-specific recombination maps will be used is set by the way that the simulation is initially configured with 
\f2\fs18 initializeRecombinationRate()
\f0\fs20 , and cannot be changed with this method; so if the simulation was set up to use sex-specific recombination maps then sex must be 
\f2\fs18 "M"
\f0\fs20  or 
\f2\fs18 "F"
\f0\fs20  here, whereas if it was set up not to, then sex must be 
\f2\fs18 "*"
\f0\fs20  or unsupplied here.  If a simulation needs sex-specific recombination maps only some of the time, the male and female maps can simply be set to be identical the rest of the time.\
The recombination intervals are normally a constant in simulations, so be sure you know what you are doing.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\b\fs22 \cf0 5.3  Class Genome\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 5.3.1  
\f1\fs18 Genome
\f0\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 genomeType => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The type of chromosome represented by this genome; one of 
\f2\fs18 "A"
\f0\fs20 , 
\f2\fs18 "X"
\f0\fs20 , or 
\f2\fs18 "Y"
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 isNullGenome => (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 T
\f0\fs20  if the genome is a \'93null\'94 genome, 
\f2\fs18 F
\f0\fs20  if it is an ordinary genome object.  When a sex chromosome (X or Y) is simulated, the other sex chromosome also exists in the simulation, but it is a \'93null\'94 genome that does not carry any mutations.  Instead, it is a placeholder, present to allow SLiM\'92s code to operate in much the same way as it does when an autosome is simulated.  Null genomes should not be accessed or manipulated.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 mutations => (object<Mutation>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 All of the 
\f2\fs18 Mutation
\f0\fs20  objects present in this genome.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value.  The value of 
\f2\fs18 tag
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.\
Note that the 
\f2\fs18 Genome
\f0\fs20  objects used by SLiM are new with every generation, so the 
\f2\fs18 tag
\f0\fs20  value of each new offspring generated in each generation will be initially undefined.  If you set a 
\f2\fs18 tag
\f0\fs20  value for an offspring genome inside a 
\f2\fs18 modifyChild()
\f0\fs20  callback, that 
\f2\fs18 tag
\f0\fs20  value will be preserved as the offspring individual becomes a parent (across the generation boundary, in other words).  If you take advantage of this, however, you should be careful to set up initial values for the tag values of 
\i all
\i0  offspring, otherwise undefined initial values might happen to match the values that you are trying to use to tag particular individuals.  A rule of thumb in programming: undefined values should always be assumed to take on the most inconvenient value possible.
\f3 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f0\i\fs22 \cf0 5.3.2  
\f1\fs18 Genome
\f0\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 +\'a0(void)addMutations(object<Mutation>\'a0mutations)
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Add the existing mutations in 
\f2\fs18 mutations
\f0\fs20  to the genome, if they are not already present (if they are already present, they will be ignored), and if the addition is not prevented by the mutation stacking policy (see the 
\f2\fs18 mutationStackPolicy
\f0\fs20  property of 
\f2\fs18 MutationType
\f0\fs20 ).\
Calling this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call 
\f2\fs18 SLiMSim
\f0\fs20 \'92s method 
\f2\fs18 recalculateFitness()
\f0\fs20  \'96 but see the documentation of that method for caveats.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 +\'a0(object<Mutation>)addNewDrawnMutation(io<MutationType>\'a0mutationType, integer\'a0position, [Ni\'a0originGeneration\'a0=\'a0NULL], [Nio<Subpopulation>\'a0originSubpop\'a0=\'a0NULL])
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Add new mutations to the target genome(s) with the specified 
\f2\fs18 mutationType
\f0\fs20  (specified by the 
\f2\fs18 MutationType
\f0\fs20  object or by 
\f2\fs18 integer
\f0\fs20  identifier), 
\f2\fs18 position
\f0\fs20 , 
\f2\fs18 originGeneration
\f0\fs20  (which may be 
\f2\fs18 NULL
\f0\fs20 , the default, to specify the current generation), and 
\f2\fs18 originSubpop
\f0\fs20  (specified by the 
\f2\fs18 Subpopulation
\f0\fs20  object or by 
\f2\fs18 integer
\f0\fs20  identifier, or by 
\f2\fs18 NULL
\f0\fs20 , the default, to specify the subpopulation to which the first target genome belongs).  If 
\f2\fs18 originSubpop
\f0\fs20  is supplied as an 
\f2\fs18 integer
\f0\fs20 , it is intentionally not checked for validity; you may use arbitrary values of 
\f2\fs18 originSubpop
\f0\fs20  to \'93tag\'94 the mutations that you create.  The selection coefficients of the mutations are drawn from their mutation types; 
\f2\fs18 addNewMutation()
\f0\fs20  may be used instead if you wish to specify selection coefficients.\
Beginning in SLiM 2.5 this method is vectorized, so all of these parameters may be singletons (in which case that single value is used for all mutations created by the call) or non-singleton vectors (in which case one element is used for each corresponding mutation created).  Non-singleton parameters must match in length, since their elements need to be matched up one-to-one.\
The new mutations created by this method are returned, even if their actual addition is prevented by the mutation stacking policy (see the 
\f2\fs18 mutationStackPolicy
\f0\fs20  property of 
\f2\fs18 MutationType
\f0\fs20 ).  However, the order of the mutations in the returned vector is not guaranteed to be the same as the order in which the values are specified in parameter vectors, unless the 
\f2\fs18 position
\f0\fs20  parameter is specified in ascending order.  In other words, pre-sorting the parameters to this method into ascending order by position, using 
\f2\fs18 order()
\f0\fs20  and subsetting, will guarantee that the order of the returned vector of mutations corresponds to the order of elements in the parameters to this method; otherwise, no such guarantee exists.\
Beginning in SLiM 2.1, this is a class method, not an instance method.  This means that it does not get multiplexed out to all of the elements of the receiver (which would add a different new mutation to each element); instead, it is performed as a single operation, adding the same new mutation objects to all of the elements of the receiver.  Before SLiM 2.1, to add the same mutations to multiple genomes, it was necessary to call 
\f2\fs18 addNewDrawnMutation()
\f0\fs20  on one of the genomes, and then add the returned 
\f2\fs18 Mutation
\f0\fs20  object to all of the other genomes using 
\f2\fs18 addMutations()
\f3\fs20 .
\f0   That is not necessary in SLiM 2.1 and later, because of this change (although doing it the old way does no harm and produces identical behavior).  Pre-2.1 code that actually relied upon the old multiplexing behavior will no longer work correctly (but this is expected to be an extremely rare pattern of usage).\
Calling this will normally affect the fitness values calculated at the end of the current generation (but not sooner); if you want current fitness values to be affected, you can call 
\f2\fs18 SLiMSim
\f0\fs20 \'92s method 
\f2\fs18 recalculateFitness()
\f0\fs20  \'96 but see the documentation of that method for caveats.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 +\'a0(object<Mutation>)addNewMutation(io<MutationType>\'a0mutationType, numeric\'a0selectionCoeff, integer\'a0position, [Ni\'a0originGeneration\'a0=\'a0NULL], [Nio<Subpopulation>\'a0originSubpop\'a0=\'a0NULL])
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Add new mutations to the target genome(s) with the specified 
\f2\fs18 mutationType
\f0\fs20  (specified by the 
\f2\fs18 MutationType
\f0\fs20  object or by 
\f2\fs18 integer
\f0\fs20  identifier), 
\f2\fs18 selectionCoeff
\f0\fs20 , 
\f2\fs18 position
\f0\fs20 , 
\f2\fs18 originGeneration
\f0\fs20  (which may be 
\f2\fs18 NULL
\f0\fs20 , the default, to specify the current generation), and 
\f2\fs18 originSubpop
\f0\fs20  (specified by the 
\f2\fs18 Subpopulation
\f0\fs20  object or by 
\f2\fs18 integer
\f0\fs20  identifier, or by 
\f2\fs18 NULL
\f0\fs20 , the default, to specify the subpopulation to which the first target genome belongs).  If 
\f2\fs18 originSubpop
\f0\fs20  is supplied as an 
\f2\fs18 integer
\f0\fs20 , it is intentionally not checked for validity; you may use arbitrary values of 
\f2\fs18 originSubpop
\f0\fs20  to \'93tag\'94 the mutations that you create.  The 
\f2\fs18 addNewDrawnMutation()
\f0\fs20  method may be used instead if you wish selection coefficients to be drawn from the mutation types of the mutations.\
The new mutations created by this method are returned, even if their actual addition is prevented by the mutation stacking policy (see the 
\f2\fs18 mutationStackPolicy
\f0\fs20  property of 
\f2\fs18 MutationType
\f0\fs20 ).  However, the order of the mutations in the returned vector is not guaranteed to be the same as the order in which the values are specified in parameter vectors, unless the 
\f2\fs18 position
\f0\fs20  parameter is specified in ascending order.  In other words, pre-sorting the parameters to this method into ascending order by position, using 
\f2\fs18 order()
\f0\fs20  and subsetting, will guarantee that the order of the returned vector of mutations corresponds to the order of elements in the parameters to this method; otherwise, no such guarantee exists.\
Beginning in SLiM 2.1, this is a class method, not an instance method.  This means that it does not get multiplexed out to all of the elements of the receiver (which would add a different new mutation to each element); instead, it is performed as a single operation, adding the same new mutation object to all of the elements of the receiver.  Before SLiM 2.1, to add the same mutation to multiple genomes, it was necessary to call 
\f2\fs18 addNewMutation()
\f0\fs20  on one of the genomes, and then add the returned 
\f2\fs18 Mutation
\f0\fs20  object to all of the other genomes using 
\f2\fs18 addMutations()
\f3\fs20 .
\f0   That is not necessary in SLiM 2.1 and later, because of this change (although doing it the old way does no harm and produces identical behavior).  Pre-2.1 code that actually relied upon the old multiplexing behavior will no longer work correctly (but this is expected to be an extremely rare pattern of usage).\
Calling this will normally affect the fitness values calculated at the end of the current generation (but not sooner); if you want current fitness values to be affected, you can call 
\f2\fs18 SLiMSim
\f0\fs20 \'92s method 
\f2\fs18 recalculateFitness()
\f0\fs20  \'96 but see the documentation of that method for caveats.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (logical$)containsMarkerMutation(io<MutationType>$\'a0mutType, integer$
\f3 \'a0
\f2 position)
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns 
\f2\fs18 T
\f0\fs20  if the genome contains a mutation of type 
\f2\fs18 mutType
\f0\fs20  at 
\f2\fs18 position
\f0\fs20 , 
\f2\fs18 F
\f0\fs20  otherwise.  This method is, as its name suggests, intended for checking for \'93marker mutations\'94: mutations of a special mutation type that are not literally mutations in the usual sense, but instead are added in to particular genomes to mark them as possessing some property.  Marker mutations are not typically added by SLiM\'92s mutation-generating machinery; instead they are added explicitly with 
\f2\fs18 addNewMutation()
\f0\fs20  or 
\f2\fs18 addNewDrawnMutation()
\f0\fs20  at a known, constant position in the genome.  This method provides a check for whether a marker mutation of a given type exists in a particular genome; because the position to check is known in advance, that check can be done much faster than the equivalent check with 
\f2\fs18 containsMutations()
\f0\fs20  or 
\f2\fs18 countOfMutationsOfType()
\f0\fs20 , using a binary search of the genome.
\f3 \
\pard\pardeftab529\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(logical)containsMutations(object<Mutation>\'a0mutations)
\f3 \
\pard\pardeftab529\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\f2\fs18 logical
\f0\fs20  vector indicating whether each of the mutations in 
\f2\fs18 mutations
\f0\fs20  is present in the genome; each element in the returned vector indicates whether the corresponding mutation is present (
\f2\fs18 T
\f0\fs20 ) or absent (
\f2\fs18 F
\f0\fs20 ).  This method is provided for speed; it is much faster than the corresponding Eidos code.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (integer$)countOfMutationsOfType(io<MutationType>$\'a0mutType)
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the number of mutations that are of the type specified by 
\f2\fs18 mutType
\f0\fs20 , out of all of the mutations in the genome.  If you need a vector of the matching 
\f2\fs18 Mutation
\f0\fs20  objects, rather than just a count, use 
\f2\fs18 -mutationsOfType()
\f3\fs20 .
\f0   This method is provided for speed; it is much faster than the corresponding Eidos code.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (object<Mutation>)mutationsOfType(io<MutationType>$\'a0mutType)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns an 
\f2\fs18 object
\f0\fs20  vector of all the mutations that are of the type specified by 
\f2\fs18 mutType
\f0\fs20 , out of all of the mutations in the genome.  If you just need a count of the matching 
\f2\fs18 Mutation
\f0\fs20  objects, rather than a vector of the matches, use 
\f2\fs18 -countOfMutationsOfType()
\f0\fs20 ; if you need just the positions of matching 
\f2\fs18 Mutation
\f0\fs20  objects, use 
\f2\fs18 -positionsOfMutationsOfType()
\f0\fs20 ; and if you are aiming for a sum of the selection coefficients of matching 
\f2\fs18 Mutation
\f0\fs20  objects, use 
\f2\fs18 -sumOfMutationsOfType()
\f3\fs20 .
\f0   This method is provided for speed; it is much faster than the corresponding Eidos code.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 +\'a0(void)output([Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F])
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Output the target genomes in SLiM\'92s native format.  This low-level output method may be used to output any sample of 
\f2\fs18 Genome
\f0\fs20  objects (the Eidos function 
\f2\fs18 sample()
\f0\fs20  may be useful for constructing custom samples, as may the SLiM class 
\f2\fs18 Individual
\f0\fs20 ).  For output of a sample from a single 
\f2\fs18 Subpopulation
\f0\fs20 , the 
\f2\fs18 outputSample()
\f0\fs20  of 
\f2\fs18 Subpopulation
\f0\fs20  may be more straightforward to use.  If the optional parameter 
\f2\fs18 filePath
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20  (the default), output is directed to SLiM\'92s standard output.  Otherwise, the output is sent to the file specified by 
\f2\fs18 filePath
\f0\fs20 , overwriting that file if 
\f2\fs18 append
\f0\fs20  if 
\f2\fs18 F
\f0\fs20 , or appending to the end of it if 
\f2\fs18 append
\f0\fs20  is 
\f2\fs18 T
\f3\fs20 .\

\f0 See 
\f2\fs18 outputMS()
\f0\fs20  and 
\f2\fs18 outputVCF()
\f0\fs20  for other output formats.  Output is generally done in a 
\f2\fs18 late()
\f0\fs20  event, so that the output reflects the state of the simulation at the end of a generation.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 +\'a0(void)outputMS([Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F])
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Output the target genomes in MS format.  This low-level output method may be used to output any sample of 
\f2\fs18 Genome
\f0\fs20  objects (the Eidos function 
\f2\fs18 sample()
\f0\fs20  may be useful for constructing custom samples, as may the SLiM class 
\f2\fs18 Individual
\f0\fs20 ).  For output of a sample from a single 
\f2\fs18 Subpopulation
\f0\fs20 , the 
\f2\fs18 outputMSSample()
\f0\fs20  of 
\f2\fs18 Subpopulation
\f0\fs20  may be more straightforward to use.  If the optional parameter 
\f2\fs18 filePath
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20  (the default), output is directed to SLiM\'92s standard output.  Otherwise, the output is sent to the file specified by 
\f2\fs18 filePath
\f0\fs20 , overwriting that file if 
\f2\fs18 append
\f0\fs20  if 
\f2\fs18 F
\f0\fs20 , or appending to the end of it if 
\f2\fs18 append
\f0\fs20  is 
\f2\fs18 T
\f3\fs20 .
\f0   Positions in the output will span the interval [0,1].\
See 
\f2\fs18 output()
\f0\fs20  and 
\f2\fs18 outputVCF()
\f0\fs20  for other output formats.  Output is generally done in a 
\f2\fs18 late()
\f0\fs20  event, so that the output reflects the state of the simulation at the end of a generation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 +\'a0(void)outputVCF([Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0outputMultiallelics\'a0=\'a0T], [logical$\'a0append\'a0=\'a0F])
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Output the target genomes in VCF format.  The target genomes are treated as pairs comprising individuals for purposes of structuring the VCF output, so an even number of genomes is required.  This low-level output method may be used to output any sample of 
\f2\fs18 Genome
\f0\fs20  objects (the Eidos function 
\f2\fs18 sample()
\f0\fs20  may be useful for constructing custom samples, as may the SLiM class 
\f2\fs18 Individual
\f0\fs20 ).  For output of a sample from a single 
\f2\fs18 Subpopulation
\f0\fs20 , the 
\f2\fs18 outputVCFSample()
\f0\fs20  of 
\f2\fs18 Subpopulation
\f0\fs20  may be more straightforward to use.  If the optional parameter 
\f2\fs18 filePath
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20  (the default), output is directed to SLiM\'92s standard output.  Otherwise, the output is sent to the file specified by 
\f2\fs18 filePath
\f0\fs20 , overwriting that file if 
\f2\fs18 append
\f0\fs20  if 
\f2\fs18 F
\f0\fs20 , or appending to the end of it if 
\f2\fs18 append
\f0\fs20  is 
\f2\fs18 T
\f3\fs20 .\

\f0 In SLiM, it is often possible for a single individual to have multiple mutations at a given base position.  Because the VCF format is an explicit-nucleotide format, this property of SLiM does not fit well into VCF.  Since there are only four possible nucleotides at a given base position in VCF, at most one \'93reference\'94 state and three \'93alternate\'94 states could be represented at that base position.  SLiM, on the other hand, can represent any number of alternative possibilities at a given base; in general, if 
\i N
\i0  different mutations are segregating at a given position, there are 2
\i \super N
\i0 \nosupersub  different allelic states at that position in SLiM.  For this reason, SLiM does not attempt to represent multiple mutations at a single site as being alternative alleles in a single output line, as is typical in VCF format.  Instead, SLiM produces a separate line of VCF output for each segregating mutation at a given position.  SLiM always declares base positions as having a \'93reference base\'94 of 
\f2\fs18 A
\f0\fs20  (representing the state in individuals that do not carry a given mutation) and an \'93alternate base\'94 of 
\f2\fs18 T
\f0\fs20  (representing the state in individuals that do carry the given mutation).  Multiallelic positions will thus produce VCF output showing multiple 
\f2\fs18 A
\f0\fs20 -to-
\f2\fs18 T
\f0\fs20  changes at the same position, possessed by different but possibly overlapping sets of individuals.  Many programs that process VCF output may not behave correctly with this style of output.  SLiM therefore provides a choice, using the 
\f2\fs18 outputMultiallelics
\f0\fs20  flag; if that flag is 
\f2\fs18 T
\f0\fs20  (the default), SLiM will produce multiple lines of output for multiallelic base positions, but will mark those lines with a 
\f2\fs18 MULTIALLELIC
\f0\fs20  flag in the 
\f2\fs18 INFO
\f0\fs20  field of the VCF output so that those lines can be filtered or processed in a special manner.  If 
\f2\fs18 outputMultiallelics
\f0\fs20  is 
\f2\fs18 F
\f0\fs20 , on the other hand, SLiM will completely suppress output of all mutations at multiallelic sites \'96 often the simplest option, if doing so does not lead to bias in the subsequent analysis.  This flag has no effect upon the output of sites with only a single mutation present.  Assessment of whether a site is multiallelic is done only within the sample; segregating mutations that are not part of the sample are ignored.\
See 
\f2\fs18 outputMS()
\f0\fs20  and 
\f2\fs18 output()
\f0\fs20  for other output formats.  Output is generally done in a 
\f2\fs18 late()
\f0\fs20  event, so that the output reflects the state of the simulation at the end of a generation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(integer)positionsOfMutationsOfType(io<MutationType>$\'a0mutType)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the positions of mutations that are of the type specified by 
\f2\fs18 mutType
\f0\fs20 , out of all of the mutations in the genome.  If you need a vector of the matching 
\f2\fs18 Mutation
\f0\fs20  objects, rather than just positions, use 
\f2\fs18 -mutationsOfType()
\f0\fs20 .  This method is provided for speed; it is much faster than the corresponding Eidos code.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \expnd0\expndtw0\kerning0
+\'a0(void)removeMutations([No<Mutation>\'a0mutations\'a0=\'a0NULL], [logical$\'a0substitute\'a0=\'a0F])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Remove the mutations in 
\f2\fs18 mutations
\f0\fs20  from the target genome(s), if they are present (if they are not present, they will be ignored).  If 
\f2\fs18 NULL
\f0\fs20  is passed for 
\f2\fs18 mutations
\f0\fs20  (which is the default), then all mutations will be removed from the target genomes; in this case, 
\f2\fs18 substitute
\f0\fs20  must be 
\f2\fs18 F
\f0\fs20  (a specific vector of mutations to be substituted is required).  Note that the 
\f2\fs18 Mutation
\f0\fs20  objects removed remain valid, and will still be in the simulation\'92s mutation registry (i.e. will be returned by 
\f2\fs18 SLiMSim
\f0\fs20 \'92s 
\f2\fs18 mutations
\f0\fs20  property), until the next generation.\
\cf2 Changing this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call 
\f2\fs18 SLiMSim
\f0\fs20 \'92s method 
\f2\fs18 recalculateFitness()
\f0\fs20  \'96 but see the documentation of that method for caveats.\
The optional parameter 
\f2\fs18 substitute
\f0\fs20  was added in SLiM 2.2, with a default of 
\f2\fs18 F
\f0\fs20  for backward compatibility.  If 
\f2\fs18 substitute
\f0\fs20  is 
\f2\fs18 T
\f0\fs20 , 
\f2\fs18 Substitution
\f0\fs20  objects will be created for all of the removed mutations so that they are recorded in the simulation as having fixed, just as if they had reached fixation and been removed by SLiM\'92s own internal machinery.  This will occur regardless of whether the mutations have in fact fixed, regardless of the 
\f2\fs18 convertToSubstitution
\f0\fs20  property of the relevant mutation types, and regardless of whether all copies of the mutations have even been removed from the simulation (making it possible to create 
\f2\fs18 Substitution
\f0\fs20  objects for mutations that are still segregating).  It is up to the caller to perform whatever checks are necessary to preserve the integrity of the simulation\'92s records.  Typically 
\f2\fs18 substitute
\f0\fs20  will only be set to 
\f2\fs18 T
\f0\fs20  in the context of calls like 
\f2\fs18 sim.subpopulations.genomes.removeMutations(muts, T)
\f0\fs20 , such that the substituted mutations are guaranteed to be entirely removed from circulation.  As mentioned above, 
\f2\fs18 substitute
\f0\fs20  may not be 
\f2\fs18 T
\f0\fs20  if 
\f2\fs18 mutations
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96
\f3 \'a0
\f2 (float$)sumOfMutationsOfType(io<MutationType>$\'a0mutType)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the sum of the selection coefficients of all mutations that are of the type specified by 
\f2\fs18 mutType
\f0\fs20 , out of all of the mutations in the genome.  This is often useful in models that use a particular mutation type to represent QTLs with additive effects; in that context, 
\f2\fs18 sumOfMutationsOfType()
\f0\fs20  will provide the sum of the additive effects of the QTLs for the given mutation type.  This method is provided for speed; it is much faster than the corresponding Eidos code.  Note that this method also exists on 
\f2\fs18 Individual
\f0\fs20 , for cases in which the sum across both genomes of an individual is desired.
\f3 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.4  Class GenomicElement\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 5.4.1  
\f1\fs18 GenomicElement
\f0\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 endPosition => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The last position in the chromosome contained by this genomic element.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 genomicElementType => (object<GenomicElementType>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The 
\f2\fs18 GenomicElementType
\f0\fs20  object that defines the behavior of this genomic element.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 startPosition => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The first position in the chromosome contained by this genomic element.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value.  The value of 
\f2\fs18 tag
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.
\f3 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f0\i\fs22 \cf0 5.4.2  
\f1\fs18 GenomicElement
\f0\fs22  methods\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 \'96\'a0(void)setGenomicElementType(io<GenomicElementType>$\'a0genomicElementType)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the genomic element type used for a genomic element.  The genomicElementType parameter should supply the new genomic element type for the element, either as a 
\f2\fs18 GenomicElementType
\f0\fs20  object or as an 
\f2\fs18 integer
\f0\fs20  identifier.  The genomic element type for a genomic element is normally a constant in simulations, so be sure you know what you are doing.
\f3 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.5  Class GenomicElementType\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 5.5.1  
\f1\fs18 GenomicElementType
\f0\fs22  properties\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 color <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The color used to display genomic elements of this type in SLiMgui.  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f2\fs18 "#RRGGBB"
\f0\fs20 .  If 
\f2\fs18 color
\f0\fs20  is the empty string, 
\f2\fs18 ""
\f0\fs20 , SLiMgui\'92s default color scheme is used; this is the default for new 
\f2\fs18 GenomicElementType
\f0\fs20  objects.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The identifier for this genomic element type; for genomic element type 
\f2\fs18 g3
\f0\fs20 , for example, this is 
\f2\fs18 3
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 mutationFractions => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 For each 
\f2\fs18 MutationType
\f0\fs20  represented in this genomic element type, this property has the corresponding fraction of all mutations that will be drawn from that 
\f2\fs18 MutationType
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 mutationTypes => (object<MutationType>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The 
\f2\fs18 MutationType
\f0\fs20  instances used by this genomic element type.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value.  The value of 
\f2\fs18 tag
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f2\fs18 getValue()
\f0\fs20  and 
\f2\fs18 setValue()
\f0\fs20  methods, for another way of attaching state to genomic element types.
\f3 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f0\i\fs22 \cf0 5.5.2  
\f1\fs18 GenomicElementType
\f0\fs22  methods\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 \'96
\f3 \'a0
\f2 (+)getValue(string$\'a0key)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the value previously set for the dictionary entry identifier 
\f2\fs18 key
\f0\fs20  using 
\f2\fs18 setValue()
\f0\fs20 , or 
\f2\fs18 NULL
\f0\fs20  if no value has been set.  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 GenomicElementType
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)setMutationFractions(io<MutationType>\'a0mutationTypes, numeric\'a0proportions)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the mutation type fractions contributing to a genomic element type.  The 
\f2\fs18 mutationTypes
\f0\fs20  vector should supply the mutation types used by the genomic element (either as 
\f2\fs18 MutationType
\f0\fs20  objects or as 
\f2\fs18 integer
\f0\fs20  identifiers), and the 
\f2\fs18 proportions
\f0\fs20  vector should be of equal length, specifying the relative proportion of mutations that will be draw from each corresponding type.  This is normally a constant in simulations, so be sure you know what you are doing.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (void)setValue(string$\'a0key, +\'a0value)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Sets a value for the dictionary entry identifier 
\f2\fs18 key
\f0\fs20 .  The value, which may be of any type other than 
\f2\fs18 object
\f0\fs20 , can be fetched later using 
\f2\fs18 getValue()
\f0\fs20 .  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 GenomicElementType
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab397\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.6  Class Individual\
\pard\pardeftab397\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 5.6.1  
\f1\fs18 Individual
\f0\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 age \cf2 \expnd0\expndtw0\kerning0
<\'96>\cf0 \kerning1\expnd0\expndtw0  (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The age of the individual, measured in generation \'93ticks\'94.  A newly generated offspring individual will have an age of 
\f2\fs18 0
\f0\fs20  in the same generation in which is was created.  The age of every individual is incremented by one at the same point that the generation counter is incremented.  The age of individuals may be changed; usually this only makes sense when setting up the initial state of a model, however.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 color <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The color used to display the individual in SLiMgui.  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f2\fs18 "#RRGGBB"
\f0\fs20 .  If 
\f2\fs18 color
\f0\fs20  is the empty string, 
\f2\fs18 ""
\f0\fs20 , SLiMgui\'92s default (fitness-based) color scheme is used; this is the default for new 
\f2\fs18 Individual
\f0\fs20  objects.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \expnd0\expndtw0\kerning0
fitnessScaling <\'96> (float$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 A 
\f2\fs18 float
\f0\fs20  scaling factor applied to the individual\'92s fitness (i.e., the fitness value computed for the individual will be multiplied by this value).  This provides a simple, fast way to modify the fitness of an individual; conceptually it is similar to returning a fitness effect for the individual from a 
\f2\fs18 fitness(NULL)
\f0\fs20  callback, but without the complexity and performance overhead of implementing such a callback.  To scale the fitness of all individuals in a subpopulation by the same factor, see the 
\f2\fs18 fitnessScaling
\f0\fs20  property of 
\f2\fs18 Subpopulation
\f0\fs20 .\
The value of 
\f2\fs18 fitnessScaling
\f0\fs20  is reset to 
\f2\fs18 1.0
\f0\fs20  every generation, so that any scaling factor set lasts for only a single generation.  This reset occurs immediately after fitness values are calculated, in both WF and nonWF models.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 genomes => (object<Genome>)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The pair of 
\f2\fs18 Genome
\f0\fs20  objects associated with this individual.\cf2 \expnd0\expndtw0\kerning0
  If only one of the two genomes is desired, the 
\f2\fs18 genome1
\f0\fs20  or 
\f2\fs18 genome2
\f0\fs20  property may be used.
\f3 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \expnd0\expndtw0\kerning0
genome1 => (object<Genome>$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 The first 
\f2\fs18 Genome
\f0\fs20  object associated with this individual.  This property is particularly useful when you want the first genome from each of a vector of individuals, as often arises in haploid models.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 genome2 => (object<Genome>$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 The second 
\f2\fs18 Genome
\f0\fs20  object associated with this individual.  This property is particularly useful when you want the second genome from each of a vector of individuals, as often arises in haploid models.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 index => (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The index of the individual in the 
\f2\fs18 individuals
\f0\fs20  vector of its 
\f2\fs18 Subpopulation
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 pedigreeID => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 If pedigree tracking is turned on with 
\f2\fs18 initializeSLiMOptions(keepPedigrees=T)
\f0\fs20 , 
\f2\fs18 pedigreeID
\f0\fs20  is a unique non-negative identifier for each individual in a simulation, never re-used throughout the duration of the simulation run.  If pedigree tracking is not on, the value of 
\f2\fs18 pedigreeID
\f0\fs20  will be a singleton 
\f2\fs18 -1
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 pedigreeParentIDs => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 If pedigree tracking is turned on with 
\f2\fs18 initializeSLiMOptions(keepPedigrees=T)
\f0\fs20 , 
\f2\fs18 pedigreeParentIDs
\f0\fs20  contains the values of 
\f2\fs18 pedigreeID
\f0\fs20  that were possessed by the parents of an individual; it is thus a vector of two values.  If pedigree tracking is not on, 
\f2\fs18 pedigreeParentIDs
\f0\fs20  will contain two 
\f2\fs18 -1
\f0\fs20  values.  Parental values may also be 
\f2\fs18 -1
\f0\fs20  if insufficient generations have elapsed for that information to be available (because the simulation just started, or because a subpopulation is new).
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 pedigreeGrandparentIDs => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 If pedigree tracking is turned on with 
\f2\fs18 initializeSLiMOptions(keepPedigrees=T)
\f0\fs20 , 
\f2\fs18 pedigreeGrandparentIDs
\f0\fs20  contains the values of 
\f2\fs18 pedigreeID
\f0\fs20  that were possessed by the grandparents of an individual; it is thus a vector of four values.  If pedigree tracking is not on, 
\f2\fs18 pedigreeGrandparentIDs
\f0\fs20  will contain four 
\f2\fs18 -1
\f0\fs20  values.  Grandparental values may also be 
\f2\fs18 -1
\f0\fs20  if insufficient generations have elapsed for that information to be available (because the simulation just started, or because a subpopulation is new).
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 sex => (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The sex of the individual.  This will be 
\f2\fs18 "H"
\f0\fs20  if sex is not enabled in the simulation (i.e., for hermaphrodites), otherwise 
\f2\fs18 "F"
\f0\fs20  or 
\f2\fs18 "M"
\f0\fs20  as appropriate.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 spatialPosition => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The spatial position of the individual.  The length of the 
\f2\fs18 spatialPosition
\f0\fs20  property (the number of coordinates in the spatial position of an individual) depends upon the spatial dimensionality declared with 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .  If the spatial dimensionality is zero (as it is by default), it is an error to access this property.  The elements of this property are identical to the values of the 
\f2\fs18 x
\f0\fs20 , 
\f2\fs18 y
\f0\fs20 , and 
\f2\fs18 z
\f0\fs20  properties (if those properties are encompassed by the spatial dimensionality of the simulation).  In other words, if the declared dimensionality is 
\f2\fs18 "xy"
\f3\fs20 ,
\f0  the 
\f2\fs18 individual.spatialPosition
\f0\fs20  property is equivalent to 
\f2\fs18 c(individual.x,\'a0individual.y)
\f0\fs20 ; 
\f2\fs18 individual.z
\f0\fs20  is not used since it is not encompassed by the simulation\'92s dimensionality.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 subpopulation => (object<Subpopulation>$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The 
\f2\fs18 Subpopulation
\f0\fs20  object to which the individual belongs.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value (as opposed to 
\f2\fs18 tagF
\f0\fs20 , which is of type 
\f2\fs18 float
\f0\fs20 ).  The value of 
\f2\fs18 tag
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f2\fs18 getValue()
\f0\fs20  and 
\f2\fs18 setValue()
\f0\fs20  methods, for another way of attaching state to individuals.\
Note that the 
\f2\fs18 Individual
\f0\fs20  objects used by SLiM are (conceptually) new with every generation, so the 
\f2\fs18 tag
\f0\fs20  value of each new offspring generated in each generation will be initially undefined.  If you set a 
\f2\fs18 tag
\f0\fs20  value for an offspring individual inside a 
\f2\fs18 modifyChild()
\f0\fs20  callback, that 
\f2\fs18 tag
\f0\fs20  value will be preserved as the offspring individual becomes a parent (across the generation boundary, in other words).  If you take advantage of this, however, you should be careful to set up initial values for the tag values of 
\i all
\i0  offspring, otherwise undefined initial values might happen to match the values that you are trying to use to tag particular individuals.  A rule of thumb in programming: undefined values should always be assumed to take on the most inconvenient value possible.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tagF <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 float
\f0\fs20  value (as opposed to 
\f2\fs18 tag
\f0\fs20 , which is of type 
\f2\fs18 integer
\f0\fs20 ).  The value of 
\f2\fs18 tagF
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tagF
\f0\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f2\fs18 getValue()
\f0\fs20  and 
\f2\fs18 setValue()
\f0\fs20  methods, for another way of attaching state to individuals.\
Note that at present, although many classes in SLiM have an 
\f2\fs18 integer
\f0\fs20 -type 
\f2\fs18 tag
\f0\fs20  property, only 
\f2\fs18 Individual
\f0\fs20  has a 
\f2\fs18 float
\f0\fs20 -type 
\f2\fs18 tagF
\f0\fs20  property, because attaching model state to individuals seems to be particularly common and useful.  If a 
\f2\fs18 tagF
\f0\fs20  property would be helpful on another class, it would be easy to add.\
See the description of the 
\f2\fs18 tag
\f0\fs20  property above for additional comments.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 uniqueMutations => (object<Mutation>)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 All of the 
\f2\fs18 Mutation
\f0\fs20  objects present in this individual.  Mutations present in both genomes will occur only once in this property, and the mutations will be given in sorted order by 
\f2\fs18 position
\f0\fs20 , so this property is similar to 
\f2\fs18 sortBy(unique(individual.genomes.mutations), "position")
\f3\fs20 .
\f0   It is not identical to that call, only because if multiple mutations exist at the exact same position, they may be sorted differently by this method than they would be by 
\f2\fs18 sortBy()
\f3\fs20 .
\f0   This method is provided primarily for speed; it executes much faster than the Eidos equivalent above.  Indeed, it is faster than just 
\f2\fs18 individual.genomes.mutations
\f0\fs20 , and gives uniquing and sorting on top of that, so it is advantageous unless duplicate entries for homozygous mutations are actually needed.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 x <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 float
\f0\fs20  value.  The value of 
\f2\fs18 x
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code, typically in a 
\f2\fs18 modifyChild()
\f0\fs20  callback.  The value of 
\f2\fs18 x
\f0\fs20  is not used by SLiM unless the optional \'93continuous space\'94 facility is enabled with the 
\f2\fs18 dimensionality
\f0\fs20  parameter to 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 , in which case 
\f2\fs18 x
\f0\fs20  will be understood to represent the 
\i x
\i0  coordinate of the individual in space.  If continuous space is not enabled, you may use 
\f2\fs18 x
\f0\fs20  as an additional tag value of type 
\f2\fs18 float
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 y <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 float
\f0\fs20  value.  The value of 
\f2\fs18 y
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code, typically in a 
\f2\fs18 modifyChild()
\f0\fs20  callback.  The value of 
\f2\fs18 y
\f0\fs20  is not used by SLiM unless the optional \'93continuous space\'94 facility is enabled with the 
\f2\fs18 dimensionality
\f0\fs20  parameter to 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 , in which case 
\f2\fs18 y
\f0\fs20  will be understood to represent the 
\i y
\i0  coordinate of the individual in space (if the dimensionality is 
\f2\fs18 "xy"
\f0\fs20  or 
\f2\fs18 "xyz"
\f0\fs20 ).  If continuous space is not enabled, or the dimensionality is not 
\f2\fs18 "xy"
\f0\fs20  or 
\f2\fs18 "xyz"
\f0\fs20 , you may use 
\f2\fs18 y
\f0\fs20  as an additional tag value of type 
\f2\fs18 float
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 z <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 float
\f0\fs20  value.  The value of 
\f2\fs18 z
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code, typically in a 
\f2\fs18 modifyChild()
\f0\fs20  callback.  The value of 
\f2\fs18 z
\f0\fs20  is not used by SLiM unless the optional \'93continuous space\'94 facility is enabled with the 
\f2\fs18 dimensionality
\f0\fs20  parameter to 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 , in which case 
\f2\fs18 z
\f0\fs20  will be understood to represent the 
\i z
\i0  coordinate of the individual in space (if the dimensionality is 
\f2\fs18 "xyz"
\f0\fs20 ).  If continuous space is not enabled, or the dimensionality is not 
\f2\fs18 "xyz"
\f0\fs20 , you may use 
\f2\fs18 z
\f0\fs20  as an additional tag value of type 
\f2\fs18 float
\f3\fs20 .\
\pard\pardeftab397\ri720\sb120\sa60\partightenfactor0

\f0\i\fs22 \cf0 5.6.2  
\f1\fs18 Individual
\f0\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 \'96\'a0(logical)containsMutations(object<Mutation>\'a0mutations)
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a 
\f2\fs18 logical
\f0\fs20  vector indicating whether each of the mutations in 
\f2\fs18 mutations
\f0\fs20  is present in the individual (in either of its genomes); each element in the returned vector indicates whether the corresponding mutation is present (
\f2\fs18 T
\f0\fs20 ) or absent (
\f2\fs18 F
\f0\fs20 ).  This method is provided for speed; it is much faster than the corresponding Eidos code.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (integer$)countOfMutationsOfType(io<MutationType>$\'a0mutType)
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the number of mutations that are of the type specified by 
\f2\fs18 mutType
\f0\fs20 , out of all of the mutations in the individual (in both of its genomes; a mutation that is present in both genomes counts twice).  If you need a vector of the matching 
\f2\fs18 Mutation
\f0\fs20  objects, rather than just a count, use the 
\f2\fs18 Genome
\f0\fs20  method 
\f2\fs18 -mutationsOfType()
\f3\fs20 .
\f0   This method is provided for speed; it is much faster than the corresponding Eidos code.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (+)getValue(string$\'a0key)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the value previously set for the dictionary entry identifier 
\f2\fs18 key
\f0\fs20  using 
\f2\fs18 setValue()
\f0\fs20 , or 
\f2\fs18 NULL
\f0\fs20  if no value has been set.  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 Individual
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (float)relatedness(object<Individual>
\f3 \'a0
\f2 individuals)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector containing the degrees of relatedness between the receiver and each of the individuals in 
\f2\fs18 individuals
\f3\fs20 .
\f0   The relatedness between 
\f2\fs18 A
\f0\fs20  and 
\f2\fs18 B
\f0\fs20  is always 
\f2\fs18 1.0
\f0\fs20  if 
\f2\fs18 A
\f0\fs20  and 
\f2\fs18 B
\f0\fs20  are actually the same individual; this facility works even if SLiM\'92s optional pedigree tracking is turned off (in which case all other relatedness values will be 
\f2\fs18 0.0
\f0\fs20 ).  Otherwise, if pedigree tracking is turned on with 
\f2\fs18 initializeSLiMOptions(keepPedigrees=T)
\f0\fs20 , this method will use the pedigree information to construct a relatedness estimate.  More specifically, if information about the grandparental generation is available, then each grandparent shared by 
\f2\fs18 A
\f0\fs20  and 
\f2\fs18 B
\f0\fs20  contributes 
\f2\fs18 0.125
\f0\fs20  towards the total relatedness, for a maximum value of 
\f2\fs18 0.5
\f0\fs20  with four shared grandparents.  If grandparental information in unavailable, then if parental information is available it is used, with each parent shared by 
\f2\fs18 A
\f0\fs20  and 
\f2\fs18 B
\f0\fs20  contributing 
\f2\fs18 0.25
\f0\fs20 , again for a maximum of 
\f2\fs18 0.5
\f0\fs20 .  If even parental information is unavailable, then the relatedness is assumed to be 
\f2\fs18 0.0
\f3\fs20 .
\f0   Again, however, if 
\f2\fs18 A
\f0\fs20  and 
\f2\fs18 B
\f0\fs20  are the same individual, the relatedness will be 
\f2\fs18 1.0
\f0\fs20  in all cases.\
Note that this relatedness is simply pedigree-based relatedness.  This does not necessarily correspond to genetic relatedness, because of the effects of factors like assortment and recombination.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \expnd0\expndtw0\kerning0
+\'a0(void)setSpatialPosition(float\'a0position)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Sets the spatial position of the individual (as accessed through the 
\f2\fs18 spatialPosition
\f0\fs20  property).  The length of 
\f2\fs18 position
\f0\fs20  (the number of coordinates in the spatial position of an individual) depends upon the spatial dimensionality declared with 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .  If the spatial dimensionality is zero (as it is by default), it is an error to call this method.  The elements of 
\f2\fs18 position
\f0\fs20  are set into the values of the 
\f2\fs18 x
\f0\fs20 , 
\f2\fs18 y
\f0\fs20 , and 
\f2\fs18 z
\f0\fs20  properties (if those properties are encompassed by the spatial dimensionality of the simulation).  In other words, if the declared dimensionality is 
\f2\fs18 "xy"
\f0\fs20 , calling 
\f2\fs18 individual.setSpatialPosition(c(1.0, 0.5))
\f0\fs20  property is equivalent to 
\f2\fs18 individual.x\'a0=\'a01.0; individual.y\'a0=\'a00.5
\f0\fs20 ; 
\f2\fs18 individual.z
\f0\fs20  is not set (even if a third value is supplied in 
\f2\fs18 position
\f0\fs20 ) since it is not encompassed by the simulation\'92s dimensionality in this example.\
Note that this is an Eidos class method, somewhat unusually, which allows it to work in a special way when called on a vector of individuals.  When the target vector of individuals is non-singleton, this method can do one of two things.  If 
\f2\fs18 position
\f0\fs20  contains just a single point (i.e., is equal in length to the spatial dimensionality of the model), the spatial position of all of the target individuals will be set to the given point.  Alternatively, if 
\f2\fs18 position
\f0\fs20  contains one point per target individual (i.e., is equal in length to the number of individuals multiplied by the spatial dimensionality of the model), the spatial position of each target individual will be set to the corresponding point from 
\f2\fs18 position
\f0\fs20  (where the point data is concatenated, not interleaved, just as it would be returned by accessing the 
\f2\fs18 spatialPosition
\f0\fs20  property on the vector of target individuals).  Calling this method with a 
\f2\fs18 position
\f0\fs20  vector of any other length is an error.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96
\f3 \'a0
\f2 (void)setValue(string$\'a0key, +\'a0value)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Sets a value for the dictionary entry identifier 
\f2\fs18 key
\f3\fs20 .
\f0   The value, which may be of any type other than 
\f2\fs18 object
\f0\fs20 , can be fetched later using 
\f2\fs18 getValue()
\f0\fs20 .  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 Individual
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (float$)sumOfMutationsOfType(io<MutationType>$\'a0mutType)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the sum of the selection coefficients of all mutations that are of the type specified by 
\f2\fs18 mutType
\f0\fs20 , out of all of the mutations in the genomes of the individual.  This is often useful in models that use a particular mutation type to represent QTLs with additive effects; in that context, 
\f2\fs18 sumOfMutationsOfType()
\f0\fs20  will provide the sum of the additive effects of the QTLs for the given mutation type.  This method is provided for speed; it is much faster than the corresponding Eidos code.  Note that this method also exists on 
\f2\fs18 Genome
\f0\fs20 , for cases in which the sum for just one genome is desired.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (object<Mutation>)uniqueMutationsOfType(io<MutationType>$\'a0mutType)
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns an 
\f2\fs18 object
\f0\fs20  vector of all the mutations that are of the type specified by 
\f2\fs18 mutType
\f0\fs20 , out of all of the mutations in the individual.  Mutations present in both genomes will occur only once in the result of this method, and the mutations will be given in sorted order by 
\f2\fs18 position
\f0\fs20 , so this method is similar to 
\f2\fs18 sortBy(unique(individual.genomes.mutationsOfType(mutType)), "position")
\f3\fs20 .
\f0   It is not identical to that call, only because if multiple mutations exist at the exact same position, they may be sorted differently by this method than they would be by 
\f2\fs18 sortBy()
\f3\fs20 .
\f0   If you just need a count of the matching 
\f2\fs18 Mutation
\f0\fs20  objects, rather than a vector of the matches, use 
\f2\fs18 -countOfMutationsOfType()
\f0\fs20 .  This method is provided for speed; it is much faster than the corresponding Eidos code.  Indeed, it is faster than just 
\f2\fs18 individual.genomes.mutationsOfType(mutType)
\f0\fs20 , and gives uniquing and sorting on top of that, so it is advantageous unless duplicate entries for homozygous mutations are actually needed.
\f3 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 17
\f3 .
\f0 7  Class InteractionType\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 17
\f3 .
\f0 7.1  
\f1\fs18 InteractionType
\f0\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The identifier for this interaction type; for interaction type 
\f2\fs18 i3
\f0\fs20 , for example, this is 
\f2\fs18 3
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 maxDistance <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The maximum distance over which this interaction will be evaluated.  For inter-individual distances greater than 
\f2\fs18 maxDistance
\f3\fs20 ,
\f0  the interaction strength will be zero.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 reciprocal => (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The reciprocality of the interaction, as specified in 
\f2\fs18 initializeInteractionType()
\f0\fs20 .  This will be 
\f2\fs18 T
\f0\fs20  for reciprocal interactions (those for which the interaction strength of B upon A is equal to the interaction strength of A upon B), and 
\f2\fs18 F
\f0\fs20  otherwise.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 sexSegregation => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The sex-segregation of the interaction, as specified in 
\f2\fs18 initializeInteractionType()
\f0\fs20 .  For non-sexual simulations, this will be 
\f2\fs18 "**"
\f3\fs20 .
\f0   For sexual simulations, this 
\f2\fs18 string
\f0\fs20  value indicates the sex of individuals feeling the interaction, and the sex of individuals exerting the interaction; see 
\f2\fs18 initializeInteractionType()
\f0\fs20  for details.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 spatiality => (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The spatial dimensions used by the interaction, as specified in 
\f2\fs18 initializeInteractionType()
\f0\fs20 .  This will be 
\f2\fs18 ""
\f0\fs20  (the empty string) for non-spatial interactions, or 
\f2\fs18 "x"
\f0\fs20 , 
\f2\fs18 "y"
\f0\fs20 , 
\f2\fs18 "z"
\f0\fs20 , 
\f2\fs18 "xy"
\f0\fs20 , 
\f2\fs18 "xz"
\f0\fs20 , 
\f2\fs18 "yz"
\f0\fs20 , or 
\f2\fs18 "xyz"
\f0\fs20 , for interactions using those spatial dimensions respectively.  The specified dimensions are used to calculate the distances between individuals for this interaction.  The value of this property is always the same as the value given to 
\f2\fs18 initializeInteractionType()
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value.  The value of 
\f2\fs18 tag
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f2\fs18 getValue()
\f0\fs20  and 
\f2\fs18 setValue()
\f0\fs20  methods, for another way of attaching state to interaction types.
\f3 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f0\i\fs22 \cf0 17
\f3 .
\f0 7.2  
\f1\fs18 InteractionType
\f0\fs22  methods\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 \'96\'a0(float)distance(object<Individual>\'a0individuals1, [No<Individual>\'a0individuals2\'a0=\'a0NULL])
\f3 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector containing distances between individuals in 
\f2\fs18 individuals1
\f0\fs20  and 
\f2\fs18 individuals2
\f0\fs20 .  At least one of 
\f2\fs18 individuals1
\f0\fs20  or 
\f2\fs18 individuals2
\f0\fs20  must be singleton, so that the distances evaluated are either from one individual to many, or from many to one (which are equivalent, in fact); evaluating distances for many to many individuals cannot be done in a single call.  If 
\f2\fs18 individuals2
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20  (the default), then 
\f2\fs18 individuals1
\f0\fs20  must be singleton, and a vector of the distances from that individual to all individuals in its subpopulation (including itself) is returned; this case may be handled by the k-d tree engine for greater speed, so supplying 
\f2\fs18 NULL
\f0\fs20  is preferable to supplying the vector of all individuals in the subpopulation explicitly even though that should produce identical results.\
Importantly, distances are calculated according to the spatiality of the 
\f2\fs18 InteractionType
\f0\fs20  (as declared in 
\f2\fs18 initializeInteractionType()
\f0\fs20 ) not the dimensionality of the model as a whole (as declared in 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 ).  The distances are therefore interaction distances: the distances that are used to calculate interaction strengths.  If the 
\f2\fs18 InteractionType
\f0\fs20  is non-spatial, this method may not be called.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(float)distanceToPoint(object<Individual>\'a0individuals1, float\'a0point)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns a vector containing distances between individuals in 
\f2\fs18 individuals1
\f0\fs20  and the point given by the spatial coordinates in 
\f2\fs18 point
\f0\fs20 .  The 
\f2\fs18 point
\f0\fs20  vector is interpreted as providing coordinates precisely as specified by the spatiality of the interaction type; if the interaction type\'92s spatiality is 
\f2\fs18 "xz"
\f0\fs20 , for example, then 
\f2\fs18 point[0]
\f0\fs20  is assumed to be an 
\i x
\i0  value, and 
\f2\fs18 point[1]
\f0\fs20  is assumed to be a 
\i z
\i0  value.  Be careful; this means that in general it is not safe to pass an individual\'92s 
\f2\fs18 spatialPosition
\f0\fs20  property for 
\f2\fs18 point
\f0\fs20 , for example (although it is safe if the spatiality of the interaction matches the dimensionality of the simulation).  A coordinate for a periodic spatial dimension must be within the spatial bounds for that dimension, since coordinates outside of periodic bounds are meaningless (
\f2\fs18 pointPeriodic()
\f0\fs20  may be used to ensure this); coordinates for non-periodic spatial dimensions are not restricted.\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 Importantly, distances are calculated according to the spatiality of the 
\f2\fs18 InteractionType
\f0\fs20  (as declared in 
\f2\fs18 initializeInteractionType()
\f0\fs20 ) not the dimensionality of the model as a whole (as declared in 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 ).  The distances are therefore interaction distances: the distances that are used to calculate interaction strengths.  If the 
\f2\fs18 InteractionType
\f0\fs20  is non-spatial, this method may not be called.  The vector 
\f2\fs18 point
\f0\fs20  must be exactly as long as the spatiality of the 
\f2\fs18 InteractionType
\f3\fs20 .\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<Individual>)drawByStrength(object<Individual>$\'a0individual, [integer$\'a0count\'a0=\'a01])
\f3 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns up to 
\f2\fs18 count
\f0\fs20  individuals drawn from the subpopulation of 
\f2\fs18 individual
\f3\fs20 .
\f0   The probability of drawing particular individuals is proportional to their strength of interaction with 
\f2\fs18 individual
\f0\fs20 .  This method may be used with either spatial or non-spatial interactions, but will be more efficient with spatial interactions that set a short maximum interaction distance.  Draws are done with replacement, so the same individual may be drawn more than once; sometimes using 
\f2\fs18 unique()
\f0\fs20  on the result of this call is therefore desirable.  If more than one draw will be needed, it is much more efficient to use a single call to 
\f2\fs18 drawByStrength()
\f0\fs20 , rather than drawing individuals one at a time.  Note that if no individuals have a non-zero interaction with 
\f2\fs18 individual
\f0\fs20 , the vector returned will be zero-length; it is important to consider this possibility.\
If the needed interaction strengths have already been calculated, those cached values are simply used.  Otherwise, calling this method triggers evaluation of the needed interactions, including calls to any applicable 
\f2\fs18 interaction()
\f0\fs20  callbacks.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)evaluate([No<Subpopulation>\'a0subpops\'a0=\'a0NULL], [logical$\'a0immediate\'a0=\'a0F])
\f3 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Triggers evaluation of the interaction for the subpopulations specified by 
\f2\fs18 subpops
\f0\fs20  (or for all subpopulations, if 
\f2\fs18 subpops
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20 ).  By default, the effects of this may be limited, however, since the underlying implementation may choose to postpone some computations lazily.  At a minimum, is it guaranteed that this method will discard all previously cached data for the subpopulation(s), and will cache the current positions of all individuals (so that individuals may then move without disturbing the state of the interaction at the moment of evaluation).  Notably, 
\f2\fs18 interaction()
\f0\fs20  callbacks may not be called in response to this method; instead, their evaluation may be deferred until required to satisfy queries (at which point the generation counter may have advanced by one, so be careful with the generation ranges used in defining such callbacks).\
If 
\f2\fs18 T
\f0\fs20  is passed for 
\f2\fs18 immediate
\f0\fs20 , the interaction will immediately and synchronously evaluate all interactions between all individuals in the subpopulation(s), calling any applicable 
\f2\fs18 interaction()
\f0\fs20  callbacks as necessary.  However, depending upon what queries are later executed, this may represent considerable wasted computation, since it is an O(N\super 2\nosupersub ) operation.  Immediate evaluation usually generates only a slight performance improvement even if the interactions between all pairs of individuals are eventually accessed; the main reason to choose immediate evaluation, then, is that deferred calculation of interactions would lead to incorrect results due to changes in model state.\
If an interaction is never evaluated for a given subpopulation, it is guaranteed that there will be essentially no memory or computational overhead associated with the interaction for that subpopulation.  Furthermore, attempting to query an interaction for an individual in a subpopulation that has not been evaluated is guaranteed to raise an error.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (+)getValue(string$\'a0key)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the value previously set for the dictionary entry identifier 
\f2\fs18 key
\f0\fs20  using 
\f2\fs18 setValue()
\f0\fs20 , or 
\f2\fs18 NULL
\f0\fs20  if no value has been set.  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 InteractionType
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<Individual>)nearestNeighbors(object<Individual>$\'a0individual, [integer$\'a0count\'a0=\'a01])
\f3 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns up to 
\f2\fs18 count
\f0\fs20  individuals that are spatially closest to 
\f2\fs18 individual
\f0\fs20 , according to the distance metric of the 
\f2\fs18 InteractionType
\f3\fs20 .
\f0   To obtain all of the individuals within the maximum interaction distance of 
\f2\fs18 individual
\f0\fs20 , simply pass a value for 
\f2\fs18 count
\f0\fs20  that is greater than or equal to the size of 
\f2\fs18 individual
\f0\fs20 \'92s subpopulation.  Note that if fewer than 
\f2\fs18 count
\f0\fs20  individuals are within the maximum interaction distance, the vector returned may be shorter than 
\f2\fs18 count
\f0\fs20 , or even zero-length; it is important to check for this possibility even when requesting a single neighbor.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<Individual>)nearestNeighborsOfPoint(object<Subpopulation>$\'a0subpop, float\'a0point, [integer$\'a0count\'a0=\'a01])
\f3 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns up to 
\f2\fs18 count
\f0\fs20  individuals in 
\f2\fs18 subpop
\f0\fs20  that are spatially closest to 
\f2\fs18 point
\f0\fs20 , according to the distance metric of the 
\f2\fs18 InteractionType
\f3\fs20 .
\f0   To obtain all of the individuals within the maximum interaction distance of 
\f2\fs18 point
\f0\fs20 , simply pass a value for 
\f2\fs18 count
\f0\fs20  that is greater than or equal to the size of 
\f2\fs18 subpop
\f0\fs20 .  Note that if fewer than 
\f2\fs18 count
\f0\fs20  individuals are within the maximum interaction distance, the vector returned may be shorter than 
\f2\fs18 count
\f0\fs20 , or even zero-length; it is important to check for this possibility even when requesting a single neighbor.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)setInteractionFunction(string$\'a0functionType, ...)
\f3 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the function used to translate spatial distances into interaction strengths for an interaction type.  The 
\f2\fs18 functionType
\f0\fs20  may be 
\f2\fs18 "f"
\f0\fs20 , in which case the ellipsis 
\f2\fs18 ...
\f0\fs20  should supply a 
\f2\fs18 numeric$
\f0\fs20  fixed interaction strength; 
\f2\fs18 "l"
\f0\fs20 , in which case the ellipsis should supply a 
\f2\fs18 numeric$
\f0\fs20  maximum strength for a linear function; 
\f2\fs18 "e"
\f0\fs20 , in which case the ellipsis should supply a 
\f2\fs18 numeric$
\f0\fs20  maximum strength and a 
\f2\fs18 numeric$
\f0\fs20  lambda (shape) parameter for a negative exponential function; \cf2 \expnd0\expndtw0\kerning0
; 
\f2\fs18 "n"
\f0\fs20 , in which case the ellipsis should supply a 
\f2\fs18 numeric$
\f0\fs20  maximum strength and a 
\f2\fs18 numeric$
\f0\fs20  sigma (standard deviation) parameter for a Gaussian function; or 
\f2\fs18 "c"
\f0\fs20 , in which case the ellipsis should supply a 
\f2\fs18 numeric$
\f0\fs20  maximum strength and a 
\f2\fs18 numeric$
\f0\fs20  scale parameter for a Cauchy distribution function\cf0 \kerning1\expnd0\expndtw0 .  Non-spatial interactions must use function type 
\f2\fs18 "f"
\f0\fs20 , since no distance values are available in that case.\
The interaction function for an interaction type is normally a constant in simulations; in any case, it cannot be changed when an interaction has already been evaluated for a given generation of individuals.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (void)setValue(string$\'a0key, +\'a0value)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Sets a value for the dictionary entry identifier 
\f2\fs18 key
\f0\fs20 .  The value, which may be of any type other than 
\f2\fs18 object
\f0\fs20 , can be fetched later using 
\f2\fs18 getValue()
\f0\fs20 .  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 InteractionType
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(float)strength(object<Individual>\'a0individuals1, [No<Individual>\'a0individuals2\'a0=\'a0NULL])
\f3 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector containing interaction strengths between individuals in 
\f2\fs18 individuals1
\f0\fs20  and 
\f2\fs18 individuals2
\f0\fs20 .  At least one of 
\f2\fs18 individuals1
\f0\fs20  or 
\f2\fs18 individuals2
\f0\fs20  must be singleton, so that the strengths evaluated are either from one individual to many, or from many to one (which are equivalent, in fact); evaluating strengths for many to many individuals cannot be done in a single call.  If 
\f2\fs18 individuals2
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20  (the default), then 
\f2\fs18 individuals1
\f0\fs20  must be singleton, and a vector of the interaction strengths from that individual to all individuals in its subpopulation (including itself) is returned; this case may be handled by the k-d tree engine for greater speed, so supplying 
\f2\fs18 NULL
\f0\fs20  is preferable to supplying the vector of all individuals in the subpopulation explicitly even though that should produce identical results.\
If the needed interaction strengths have already been calculated, those cached values are simply returned.  Otherwise, calling this method triggers evaluation of the needed interactions, including calls to any applicable 
\f2\fs18 interaction()
\f0\fs20  callbacks.\
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(float)totalOfNeighborStrengths(object<Individual>\'a0individuals)
\f3 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns a vector of the total interaction strength felt by each individual in 
\f2\fs18 individuals
\f0\fs20 , which does not need to be a singleton; indeed, it can be a vector of all of the individuals in a given subpopulation.  However, all of the individuals in 
\f2\fs18 individuals
\f0\fs20  must be in the same subpopulation.\
For one individual, this is essentially the same as calling 
\f2\fs18 nearestNeighbors()
\f0\fs20  with a large 
\f2\fs18 count
\f0\fs20  so as to obtain the complete vector of all neighbors, calling 
\f2\fs18 strength()
\f0\fs20  for each of those interactions to get each interaction strength, and adding those interaction strengths together with 
\f2\fs18 sum()
\f0\fs20 .  This method is much faster than that implementation, however, since all of that work is done as a single operation.  Also, 
\f2\fs18 totalOfNeighborStrengths()
\f0\fs20  can total up interactions for more than one focal individual in a single call.\
Similarly, for one individual this is essentially the same as calling 
\f2\fs18 strength()
\f0\fs20  to get the interaction strengths between the focal individual and all other individuals, and then calling 
\f2\fs18 sum()
\f0\fs20 .  Again, this method should be much faster, since this algorithm looks only at neighbors, whereas calling 
\f2\fs18 strength()
\f0\fs20  directly assesses interaction strengths with all other individuals.  This will make a particularly large difference when the subpopulation size is large and the maximum distance of the 
\f2\fs18 InteractionType
\f0\fs20  is small.\
If the needed interaction strengths have already been calculated, those cached values are simply used.  Otherwise, calling this method triggers evaluation of the needed interactions, including calls to any applicable 
\f2\fs18 interaction()
\f0\fs20  callbacks.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)unevaluate(void)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Discards all evaluation of this interaction, for all subpopulations.  The state of the 
\f2\fs18 InteractionType
\f0\fs20  is reset to a state prior to evaluation.  This can be useful if the model state has changed in such a way that the evaluation already conducted is no longer valid.  For example, if the maximum distance or the interaction function of the 
\f2\fs18 InteractionType
\f0\fs20  need to be changed with immediate effect, or if the data used by an interaction() callback has changed in such a way that previously calculated interaction strengths are no longer correct, 
\f2\fs18 unevaluate()
\f0\fs20  allows the interaction to begin again from scratch.\
Note that all interactions are automatically reset to an unevaluated state at the moment when the new offspring generation becomes the parental generation (at step 4 in the generation cycle).  Most simulations therefore never have any reason to call 
\f2\fs18 unevaluate()
\f3\fs20 .\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.8  Class Mutation\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 5.8.1  
\f1\fs18 Mutation
\f0\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The identifier for this mutation.  Each mutation created during a run receives an immutable identifier that will be unique across the duration of the run.  These identifiers are not re-used during a run, except that if a population file is loaded from disk, the loaded mutations will receive their original identifier values as saved in the population file.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 mutationType => (object<MutationType>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The 
\f2\fs18 MutationType
\f0\fs20  from which this mutation was drawn.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 originGeneration => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The generation in which this mutation arose.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 position => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The position in the chromosome of this mutation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 selectionCoeff => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The selection coefficient of the mutation, drawn from the distribution of fitness effects of its 
\f2\fs18 MutationType
\f3\fs20 .\

\f0 Note that this property has a quirk: it is stored internally in SLiM using a single-precision float, not the double-precision float type normally used by Eidos.  This means that if you set a mutation 
\f2\fs18 mut
\f0\fs20 \'92s selection coefficient to some number 
\f2\fs18 x
\f0\fs20 , 
\f2\fs18 mut.selectionCoeff==x
\f0\fs20  may be 
\f2\fs18 F
\f0\fs20  due to floating-point rounding error.  Comparisons of floating-point numbers for exact equality is often a bad idea, but this is one case where it may fail unexpectedly.  Instead, it is recommended to use the 
\f2\fs18 id
\f0\fs20  or 
\f2\fs18 tag
\f0\fs20  properties to identify particular mutations.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 subpopID <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The identifier of the subpopulation in which this mutation arose.  This property can be used to track the ancestry of mutations through their subpopulation of origin.\
If you don\'92t care which subpopulation a mutation originated in, the 
\f2\fs18 subpopID
\f0\fs20  may be used as an arbitrary 
\f2\fs18 integer
\f0\fs20  \'93tag\'94 value for any purpose you wish; SLiM does not do anything with the value of 
\f2\fs18 subpopID
\f0\fs20  except propagate it to 
\f2\fs18 Substitution
\f0\fs20  objects and report it in output.  (It must still be 
\f2\fs18 >= 0
\f0\fs20 , however, since SLiM object identifiers are limited to nonnegative integers).\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value.  The value of 
\f2\fs18 tag
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\fs22 \cf0 5.8.2  
\f1\fs18 Mutation
\f0\fs22  methods\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 \'96
\f3 \'a0
\f2 (+)getValue(string$\'a0key)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the value previously set for the dictionary entry identifier 
\f2\fs18 key
\f0\fs20  using 
\f2\fs18 setValue()
\f0\fs20 , or 
\f2\fs18 NULL
\f0\fs20  if no value has been set.  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 Mutation
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)setMutationType(io<MutationType>$\'a0mutType)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the mutation type of the mutation to 
\f2\fs18 mutType
\f0\fs20  (which may be specified as either an 
\f2\fs18 integer
\f0\fs20  identifier or a 
\f2\fs18 MutationType
\f0\fs20  object).  This implicitly changes the dominance coefficient of the mutation to that of the new mutation type, since the dominance coefficient is a property of the mutation type.  On the other hand, the selection coefficient of the mutation is not changed, since it is a property of the mutation object itself; it can be changed explicitly using the 
\f2\fs18 setSelectionCoeff()
\f0\fs20  method if so desired.\
The mutation type of a mutation is normally a constant in simulations, so be sure you know what you are doing.  Changing this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call 
\f2\fs18 SLiMSim
\f0\fs20 \'92s method 
\f2\fs18 recalculateFitness()
\f0\fs20  \'96 but see the documentation of that method for caveats.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)setSelectionCoeff(float$\'a0selectionCoeff)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the selection coefficient of the mutation to 
\f2\fs18 selectionCoeff
\f0\fs20 .  The selection coefficient will be changed for all individuals that possess the mutation, since they all share a single 
\f2\fs18 Mutation
\f0\fs20  object (note that the dominance coefficient will remain unchanged, as it is determined by the mutation type).\
This is normally a constant in simulations, so be sure you know what you are doing; often setting up a 
\f2\fs18 fitness()
\f0\fs20  callback is preferable, in order to modify the selection coefficient in a more limited and controlled fashion.  Changing this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call 
\f2\fs18 SLiMSim
\f0\fs20 \'92s method 
\f2\fs18 recalculateFitness()
\f0\fs20  \'96 but see the documentation of that method for caveats.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (void)setValue(string$\'a0key, +\'a0value)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Sets a value for the dictionary entry identifier 
\f2\fs18 key
\f0\fs20 .  The value, which may be of any type other than 
\f2\fs18 object
\f0\fs20 , can be fetched later using 
\f2\fs18 getValue()
\f0\fs20 .  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 Mutation
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.9  Class MutationType\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 5.9.1  
\f1\fs18 MutationType
\f0\fs22  properties\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 color <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The color used to display mutations of this type in SLiMgui.  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f2\fs18 "#RRGGBB"
\f0\fs20 .  If 
\f2\fs18 color
\f0\fs20  is the empty string, 
\f2\fs18 ""
\f0\fs20 , SLiMgui\'92s default (selection-coefficient\'96based) color scheme is used; this is the default for new 
\f2\fs18 MutationType
\f0\fs20  objects.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 colorSubstitution <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The color used to display substitutions of this type in SLiMgui (see the discussion for the 
\f2\fs18 colorSubstitution
\f0\fs20  property of the 
\f2\fs18 Chromosome
\f0\fs20  class for details).  Outside of SLiMgui, this property still exists, but is not used by SLiM.  Colors may be specified by name, or with hexadecimal RGB values of the form 
\f2\fs18 "#RRGGBB"
\f0\fs20 .  If 
\f2\fs18 colorSubstitution
\f0\fs20  is the empty string, 
\f2\fs18 ""
\f0\fs20 , SLiMgui\'92s default (selection-coefficient\'96based) color scheme is used; this is the default for new 
\f2\fs18 MutationType
\f0\fs20  objects.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 convertToSubstitution <\'96> (logical$)\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
This property governs whether mutations of this mutation type will be converted to 
\f2\fs18 Substitution
\f0\fs20  objects when they reach fixation.\
In WF models this property is 
\f2\fs18 T
\f0\fs20  by default, since conversion to 
\f2\fs18 Substitution
\f0\fs20  objects provides large speed benefits; it should be set to 
\f2\fs18 F
\f0\fs20  only if necessary, and only on the mutation types for which it is necessary.  This might be needed, for example, if you are using a 
\f2\fs18 fitness()
\f0\fs20  callback to implement an epistatic relationship between mutations; a mutation epistatically influencing the fitness of other mutations through a 
\f2\fs18 fitness()
\f0\fs20  callback would need to continue having that influence even after reaching fixation, but if the simulation were to replace the fixed mutation with a 
\f2\fs18 Substitution
\f0\fs20  object the mutation would no longer be considered in fitness calculations (unless the callback explicitly consulted the list of 
\f2\fs18 Substitution
\f0\fs20  objects kept by the simulation).  Other script-defined behaviors in 
\f2\fs18 fitness()
\f0\fs20 , 
\f2\fs18 interaction()
\f0\fs20 , 
\f2\fs18 mateChoice()
\f0\fs20 , 
\f2\fs18 modifyChild()
\f0\fs20 , and 
\f2\fs18 recombination()
\f0\fs20  callbacks might also necessitate the disabling of substitution for a given mutation type; this is an important consideration to keep in mind.\
In contrast, for nonWF models this property is 
\f2\fs18 F
\f0\fs20  by default, because even mutations with no epistatis or other indirect fitness effects will continue to influence the survival probabilities of individuals.  For nonWF models, only neutral mutation types with no epistasis or other side effects can safely be converted to substitutions upon fixation.  When such a pure-neutral mutation type is defined in a nonWF model, this property should be set to 
\f2\fs18 T
\f0\fs20  to tell SLiM that substitution is allowed; this may have very large positive effects on performance, so it is important to remember when modeling background neutral mutations.\
SLiM consults this flag at the end of each generation when deciding whether to substitute each fixed mutation.  If this flag is 
\f2\fs18 T
\f0\fs20 , all eligible fixed mutations will be converted at the end of the current generation, even if they were previously left unconverted because of the previous value of the flag.  Setting this flag to 
\f2\fs18 F
\f0\fs20  will prevent future substitutions, but will not cause any existing 
\f2\fs18 Substitution
\f0\fs20  objects to be converted back into 
\f2\fs18 Mutation
\f0\fs20  objects.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 distributionParams => (fs)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The parameters that configure the chosen distribution of fitness effects.  This will be of type 
\f2\fs18 string
\f0\fs20  for DFE type 
\f2\fs18 "s"
\f0\fs20 , and type 
\f2\fs18 float
\f0\fs20  for all other DFE types.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 distributionType => (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The type of distribution of fitness effects; one of 
\f2\fs18 "f"
\f0\fs20 , 
\f2\fs18 "g"
\f3\fs20 ,
\f0  
\f2\fs18 "e"
\f3\fs20 ,
\f0  
\f2\fs18 "n"
\f3\fs20 ,
\f0  
\f2\fs18 "w"
\f3\fs20 ,
\f0  or 
\f2\fs18 "s"
\f3\fs20 :\

\f2\fs18 "f"
\f0\fs22  \'96 A 
\b f
\b0 ixed fitness effect.  This DFE type has a single parameter, the selection coefficient 
\i s
\i0  to be used by all mutations of the mutation type.\

\f2\fs18 "g"
\f0\fs22  \'96 A 
\b g
\b0 amma-distributed fitness effect.  This DFE type is specified by two parameters, a shape parameter and a mean value.  The gamma distribution from which mutations are drawn is given by the probability density function 
\f3\i P
\i0 (
\i s
\i0 \'a0|\'a0
\f4\i \uc0\u945 
\f3\i0 ,
\f4\i \uc0\u946 
\f3\i0 )\'a0
\f4 = [\uc0\u915 (
\i \uc0\u945 
\f3\i0 )
\f4\i \uc0\u946 \u945 
\f3\i0 ]\super \uc0\u8722 1\nosupersub exp(\uc0\u8722 
\i s
\i0 /
\f4\i \uc0\u946 
\f3\i0 )
\f0 , where 
\f4\i \uc0\u945 
\f0\i0  is the shape parameter, and the specified mean for the distribution is equal to 
\f4\i \uc0\u945 \u946 
\f0\i0 .  Note that this parameterization is the same as for the Eidos function 
\f2\fs18 rgamma()
\f0\fs22 .  A gamma distribution is often used to model deleterious mutations at functional sites.\

\f2\fs18 "e"
\f0\fs22  \'96 An 
\b e
\b0 xponentially-distributed fitness effect.  This DFE type is specified by a single parameter, the mean of the distribution.  The exponential distribution from which mutations are drawn is given by the probability density function 
\f3\i P
\i0 (
\i s
\i0 \'a0|\'a0
\f4\i \uc0\u946 
\f3\i0 )\'a0= 
\f4\i \uc0\u946 
\f3\i0 \super \uc0\u8722 1\nosupersub exp(\uc0\u8722 
\i s
\i0 /
\f4\i \uc0\u946 
\f3\i0 )
\f0 , where 
\f4\i \uc0\u946 
\f0\i0  is the specified mean for the distribution.  This parameterization is the same as for the Eidos function 
\f2\fs18 rexp()
\f0\fs22 .  An exponential distribution is often used to model beneficial mutations.\

\f2\fs18 "n"
\f0\fs22  \'96 A 
\b n
\b0 ormally-distributed fitness effect.  This DFE type is specified by two parameters, a mean and a standard deviation.  The normal distribution from which mutations are drawn is given by the probability density function 
\f3\i P
\i0 (
\i s
\i0 \'a0|\'a0
\f4\i \uc0\u956 
\f3\i0 ,
\f4\i \uc0\u963 
\f3\i0 )\'a0= (2
\f4 \uc0\u960 
\i \uc0\u963 
\f3\i0 \super 2\nosupersub )\super \uc0\u8722 1/2\nosupersub exp(\uc0\u8722 (
\i s
\i0 \uc0\u8722 
\f4\i \uc0\u956 
\f3\i0 )\super 2\nosupersub /2
\f4\i \uc0\u963 
\f3\i0 \super 2\nosupersub )
\f0 , where 
\f4\i \uc0\u956 
\f0\i0  is the mean and 
\f4\i \uc0\u963 
\f0\i0  is the standard deviation.  This parameterization is the same as for the Eidos function 
\f2\fs18 rnorm()
\f0\fs22 .  A normal distribution is often used to model mutations that can be either beneficial or deleterious, since both tails of the distribution are unbounded.\

\f2\fs18 "w"
\f0\fs22  \'96 A 
\b W
\b0 eibull-distributed fitness effect.  This DFE type is specified by a scale parameter and a shape parameter.  The Weibull distribution from which mutations are drawn is given by the probability density function 
\f3\i P
\i0 (
\i s
\i0 \'a0|\'a0
\f4\i \uc0\u955 
\f3\i0 ,
\i k
\i0 )\'a0= (
\i k
\i0 /
\f4\i \uc0\u955 
\f3 \super k
\i0 \nosupersub )
\i s\super k
\i0 \uc0\u8722 1\nosupersub exp(\uc0\u8722 (
\i s
\i0 /
\f4\i \uc0\u955 
\f3\i0 )
\i \super k
\i0 \nosupersub )
\f0 , where 
\f4\i \uc0\u955 
\f0\i0  is the scale parameter and 
\f3\i k
\f0\i0  is the shape parameter.  This parameterization is the same as for the Eidos function 
\f2\fs18 rweibull()
\f0\fs22 .  A Weibull distribution is often used to model mutations following extreme-value theory.\

\f2\fs18 "s"
\f0\fs22  \'96 A 
\b s
\b0 cript-based fitness effect.  This DFE type is specified by a script parameter of type 
\f2\fs18 string
\f0\fs22 , specifying an Eidos script to be executed to produce each new selection coefficient.  For example, the script 
\f2\fs18 "return rbinom(1);"
\f0\fs22  could be used to generate selection coefficients drawn from a binomial distribution, using the Eidos function 
\f2\fs18 rbinom()
\f0\fs22 , even though that mutational distribution is not supported by SLiM directly.  The script must return a singleton float or integer.\
Note that these distributions can in principle produce selection coefficients smaller than 
\f2\fs18 -1.0. 
\f0\fs22 In that case
\f3 ,
\f0  the mutations will be evaluated as \'93lethal\'94 by SLiM, and the relative fitness of the individual will be set to 
\f2\fs18 0.0
\f3\fs22 .
\fs20 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 dominanceCoeff <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The dominance coefficient used for mutations of this type when heterozygous.  Changing this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call 
\f2\fs18 SLiMSim
\f0\fs20 \'92s method 
\f2\fs18 recalculateFitness()
\f0\fs20  \'96 but see the documentation of that method for caveats.\
Note that the dominance coefficient is not bounded.  A dominance coefficient greater than 
\f2\fs18 1.0
\f0\fs20  may be used to achieve an overdominance effect.  By making the selection coefficient very small and the dominance coefficient very large, an overdominance scenario in which both homozygotes have the same fitness may be approximated, to a nearly arbitrary degree of precision.\
Note that this property has a quirk: it is stored internally in SLiM using a single-precision float, not the double-precision float type normally used by Eidos.  This means that if you set a mutation type 
\f2\fs18 muttype
\f0\fs20 \'92s dominance coefficient to some number 
\f2\fs18 x
\f0\fs20 , 
\f2\fs18 muttype.dominanceCoeff==x
\f0\fs20  may be 
\f2\fs18 F
\f0\fs20  due to floating-point rounding error.  Comparisons of floating-point numbers for exact equality is often a bad idea, but this is one case where it may fail unexpectedly.  Instead, it is recommended to use the 
\f2\fs18 id
\f0\fs20  or 
\f2\fs18 tag
\f0\fs20  properties to identify particular mutation types.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The identifier for this mutation type; for mutation type 
\f2\fs18 m3
\f0\fs20 , for example, this is 
\f2\fs18 3
\f3\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 mutationStackGroup <\'96> (integer$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The group into which this mutation type belongs for purposes of mutation stacking policy.  This is equal to the mutation type\'92s 
\f2\fs18 id
\f0\fs20  by default.  See 
\f2\fs18 mutationStackPolicy
\f0\fs20 , below, for discussion.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 mutationStackPolicy <\'96> (string$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 This property and the 
\f2\fs18 mutationStackGroup
\f0\fs20  property together govern whether mutations of this mutation type\'92s stacking group can \'93stack\'94 \'96 can occupy the same position in a single individual.  A set of mutation types with the same value for 
\f2\fs18 mutationStackGroup
\f0\fs20  is called a \'93stacking group\'94, and all mutation types in a given stacking group must have the same 
\f2\fs18 mutationStackPolicy
\f0\fs20  value, which defines the stacking behavior of all mutations of the mutation types in the stacking group.  In other words, one stacking group might allow its mutations to stack, while another stacking group might not, but the policy within each stacking group must be unambiguous.\
This property is 
\f2\fs18 "s"
\f0\fs20  by default, indicating that mutations in this stacking group should be allowed to stack without restriction.  If the policy is set to 
\f2\fs18 "f"
\f0\fs20 , the 
\i first
\i0  mutation of stacking group at a given site is retained; further mutations of this stacking group at the same site are discarded with no effect.  This can be useful for modeling one-way changes to single nucleotides, for example; once a 
\f2\fs18 T
\f0\fs20  changes to an 
\f2\fs18 A
\f0\fs20 , further changes of the 
\f2\fs18 A
\f0\fs20  to an 
\f2\fs18 A
\f0\fs20  are not changes at all.  If the policy is set to 
\f2\fs18 "l"
\f0\fs20 , the 
\i last
\i0  mutation of this stacking group at a given site is retained; earlier mutation of this stacking group at the same site are discarded.  This can be useful for modeling an \'93infinite-alleles\'94 scenario in which every new mutation at a site generates a completely new allele, rather than retaining the previous mutations at the site.\
The mutation stacking policy applies only within the given mutation type\'92s stacking group; mutations of different stacking groups are always allowed to stack in SLiM.  The policy applies to all mutations added to the model after the policy is set, whether those mutations are introduced by calls such as 
\f2\fs18 addMutation()
\f0\fs20 , 
\f2\fs18 addNewMutation()
\f0\fs20 , or 
\f2\fs18 addNewDrawnMutation()
\f0\fs20 , or are added by SLiM\'92s own mutation-generation machinery.  However, no attempt is made to enforce the policy for mutations already existing at the time the policy is set; typically, therefore, the policy is set in an 
\f2\fs18 initialize()
\f0\fs20  callback so that it applies throughout the simulation.  The policy is also not enforced upon the mutations loaded from a file with 
\f2\fs18 readFromPopulationFile()
\f0\fs20 ; such mutations were governed by whatever stacking policy was in effect when the population file was generated.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value.  The value of 
\f2\fs18 tag
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f2\fs18 getValue()
\f0\fs20  and 
\f2\fs18 setValue()
\f0\fs20  methods, for another way of attaching state to mutation types.
\f3 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f0\i\fs22 \cf0 5.9.2  
\f1\fs18 MutationType
\f0\fs22  methods\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 \'96
\f3 \'a0
\f2 (+)getValue(string$\'a0key)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the value previously set for the dictionary entry identifier 
\f2\fs18 key
\f0\fs20  using 
\f2\fs18 setValue()
\f0\fs20 , or 
\f2\fs18 NULL
\f0\fs20  if no value has been set.  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 MutationType
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)setDistribution(string$\'a0distributionType, ...)
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the distribution of fitness effects for a mutation type.  The 
\f2\fs18 distributionType
\f0\fs20  may be 
\f2\fs18 "f"
\f0\fs20 , in which case the ellipsis 
\f2\fs18 ...
\f0\fs20  should supply a 
\f2\fs18 numeric$
\f0\fs20  fixed selection coefficient; 
\f2\fs18 "e"
\f0\fs20 , in which case the ellipsis should supply a 
\f2\fs18 numeric$
\f0\fs20  mean selection coefficient for the exponential distribution; 
\f2\fs18 "g"
\f0\fs20 , in which case the ellipsis should supply a 
\f2\fs18 numeric$
\f0\fs20  mean selection coefficient and a 
\f2\fs18 numeric$
\f0\fs20  alpha shape parameter for a gamma distribution; 
\f2\fs18 "n"
\f0\fs20 , in which case the ellipsis should supply a 
\f2\fs18 numeric$
\f0\fs20  mean selection coefficient and a 
\f2\fs18 numeric$
\f0\fs20  sigma (standard deviation) parameter for a normal distribution
\fs22 ; 
\f2\fs18 "w"
\f0\fs22 , in which case the ellipsis should supply a 
\f2\fs18 numeric$
\f0\fs22  
\f4 \uc0\u955 
\f0  scale parameter and a 
\f2\fs18 numeric$
\f0\fs22  k shape parameter for a Weibull distribution; or 
\f2\fs18 "s"
\f0\fs22 , in which case the ellipsis should supply a 
\f2\fs18 string$
\f0\fs22  Eidos script parameter.
\fs20   The DFE for a mutation type is normally a constant in simulations, so be sure you know what you are doing.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (void)setValue(string$\'a0key, +\'a0value)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Sets a value for the dictionary entry identifier 
\f2\fs18 key
\f0\fs20 .  The value, which may be of any type other than 
\f2\fs18 object
\f0\fs20 , can be fetched later using 
\f2\fs18 getValue()
\f0\fs20 .  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 MutationType
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.10  Class SLiMEidosBlock\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 5.10.1  
\f1\fs18 SLiMEidosBlock
\f0\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 active <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 If this evaluates to 
\f2\fs18 logical
\f0\fs20  
\f2\fs18 F
\f0\fs20  (i.e., is equal to 
\f2\fs18 0
\f0\fs20 ), the script block is inactive and will not be called.  The value of 
\f2\fs18 active
\f0\fs20  for all registered script blocks is reset to 
\f2\fs18 -1
\f0\fs20  at the beginning of each generation, prior to script events being called, thus activating all blocks.  Any 
\f2\fs18 integer
\f0\fs20  value other than 
\f2\fs18 -1
\f0\fs20  may be used instead of 
\f2\fs18 -1
\f0\fs20  to represent that a block is active; for example, 
\f2\fs18 active
\f0\fs20  may be used as a counter to make a block execute a fixed number of times in each generation.  This value is not cached by SLiM; if it is changed, the new value takes effect immediately.  For example, a callback might be activated and inactivated repeatedly during a single generation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 end => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The last generation in which the script block is active.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The identifier for this script block; for script 
\f2\fs18 s3
\f0\fs20 , for example, this is 
\f2\fs18 3
\f0\fs20 .  A script block for which no 
\f2\fs18 id
\f0\fs20  was given will have an 
\f2\fs18 id
\f0\fs20  of 
\f2\fs18 -1
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 source => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The source code string of the script block.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 start => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The first generation in which the script block is active.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value.  The value of 
\f2\fs18 tag
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 type => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The type of the script block; this will be 
\f2\fs18 "early"
\f0\fs20  or 
\f2\fs18 "late"
\f0\fs20  for the two types of Eidos events, or 
\f2\fs18 "initialize"
\f0\fs20 , 
\f2\fs18 "fitness"
\f0\fs20 , 
\f2\fs18 "mateChoice"
\f0\fs20 , 
\f2\fs18 "modifyChild"
\f0\fs20 , or 
\f2\fs18 "recombination"
\f0\fs20  for the respective types of Eidos callbacks.
\f2\fs18 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f0\i\fs22 \cf0 5.10.2  
\f1\fs18 SLiMEidosBlock
\f0\fs22  methods\
\pard\pardeftab397\fi274\ri720\sb40\sa40\partightenfactor0

\f3\i0 \cf0 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b \cf0 5.11  Class SLiMSim\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 5.11.1  
\f1\fs18 SLiMSim
\f0\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 chromosome => (object<Chromosome>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The 
\f2\fs18 Chromosome
\f0\fs20  
\f2\fs18 object
\f0\fs20  used by the simulation.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 chromosomeType => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The type of chromosome being simulated; this will be one of 
\f2\fs18 "A"
\f0\fs20 , 
\f2\fs18 "X"
\f0\fs20 , or 
\f2\fs18 "Y"
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 dimensionality => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The spatial dimensionality of the simulation, as specified in 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .  This will be 
\f2\fs18 ""
\f0\fs20  (the empty string) for non-spatial simulations (the default), or 
\f2\fs18 "x"
\f0\fs20 , 
\f2\fs18 "xy"
\f0\fs20 , or 
\f2\fs18 "xyz"
\f0\fs20 , for simulations using those spatial dimensions respectively.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 dominanceCoeffX <\'96> (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The dominance coefficient value used to modify the selection coefficients of mutations present on the single X chromosome of an XY male (see the SLiM manual for details).  Used only when simulating an X chromosome; setting a value for this property in other circumstances is an error.  Changing this will normally affect the fitness values calculated at the end of the current generation; if you want current fitness values to be affected, you can call 
\f2\fs18 SLiMSim
\f0\fs20 \'92s method 
\f2\fs18 recalculateFitness()
\f0\fs20  \'96 but see the documentation of that method for caveats.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 generation <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The current generation number.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 genomicElementTypes => (object<GenomicElementType>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The 
\f2\fs18 GenomicElementType
\f0\fs20  objects being used in the simulation.
\f3 \
\pard\pardeftab543\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 inSLiMgui => (logical$)\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 If 
\f2\fs18 T
\f0\fs20 , the simulation is presently running inside SLiMgui; if 
\f2\fs18 F
\f0\fs20 , it is running at the command line.  In general simulations should not care where they are running, but in special circumstances such as opening plot windows it may be necessary to know the runtime environment.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 interactionTypes => (object<InteractionType>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The 
\f2\fs18 InteractionType
\f0\fs20  objects being used in the simulation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 modelType => (string$)\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The type of model being simulated, as specified in 
\f2\fs18 initializeSLiMModelType()
\f0\fs20 .  This will be 
\f2\fs18 "WF"
\f0\fs20  for WF models (Wright-Fisher models, the default), or 
\f2\fs18 "nonWF"
\f0\fs20  for nonWF models (non-Wright-Fisher models).\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 mutationTypes => (object<MutationType>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The 
\f2\fs18 MutationType
\f0\fs20  objects being used in the simulation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 mutations => (object<Mutation>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The 
\f2\fs18 Mutation
\f0\fs20  objects that are currently active in the simulation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 periodicity => (string$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
The spatial periodicity of the simulation, as specified in 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .  This will be 
\f2\fs18 ""
\f0\fs20  (the empty string) for non-spatial simulations and simulations with no periodic spatial dimensions (the default).  Otherwise, it will be a string representing the subset of spatial dimensions that have been declared to be periodic, as specified to 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 scriptBlocks => (object<SLiMEidosBlock>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 All registered 
\f2\fs18 SLiMEidosBlock
\f0\fs20  objects in the simulation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 sexEnabled => (logical$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 If 
\f2\fs18 T
\f0\fs20 , sex is enabled in the simulation; if 
\f2\fs18 F
\f0\fs20 , individuals are hermaphroditic.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 subpopulations => (object<Subpopulation>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The 
\f2\fs18 Subpopulation
\f0\fs20  instances currently defined in the simulation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 substitutions => (object<Substitution>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A vector of 
\f2\fs18 Substitution
\f0\fs20  objects, representing all mutations that have been fixed.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value.  The value of 
\f2\fs18 tag
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f2\fs18 getValue()
\f0\fs20  and 
\f2\fs18 setValue()
\f0\fs20  methods, for another way of attaching state to the simulation.
\f3 \
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\f0\i\fs22 \cf0 5.11.2  
\f1\fs18 SLiMSim
\f0\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 \'96\'a0(object<Subpopulation>$)addSubpop(is$\'a0subpopID, integer$\'a0size, [float$\'a0sexRatio\'a0=\'a00.5])
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Add a new subpopulation with id 
\f2\fs18 subpopID
\f0\fs20  and 
\f2\fs18 size
\f0\fs20  individuals (see the SLiM manual for further details).  The 
\f2\fs18 subpopID
\f0\fs20  parameter may be either an 
\f2\fs18 integer
\f0\fs20  giving the ID of the new subpopulation, or a 
\f2\fs18 string
\f0\fs20  giving the name of the new subpopulation (such as 
\f2\fs18 "p5"
\f0\fs20  to specify an ID of 5).  Only if sex is enabled in the simulation, the initial sex ratio may optionally be specified as 
\f2\fs18 sexRatio
\f0\fs20 ; if it is not specified, a default of 
\f2\fs18 0.5
\f0\fs20  is used.  The new subpopulation will be defined as a global variable immediately by this method, and will also be returned by this method.  Subpopulations added by this method will initially consist of individuals with empty genomes. In order to model subpopulations that split from an already existing subpopulation, use 
\f2\fs18 addSubpopSplit()
\f3\fs20 .\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<Subpopulation>$)addSubpopSplit(is$\'a0subpopID, integer$\'a0size, io<Subpopulation>$\'a0sourceSubpop, [float$\'a0sexRatio\'a0=\'a00.5])
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Split off a new subpopulation with id 
\f2\fs18 subpopID
\f0\fs20  and 
\f2\fs18 size
\f0\fs20  individuals derived from subpopulation 
\f2\fs18 sourceSubpop
\f0\fs20  (see the SLiM manual for further details).  The 
\f2\fs18 subpopID
\f0\fs20  parameter may be either an 
\f2\fs18 integer
\f0\fs20  giving the ID of the new subpopulation, or a 
\f2\fs18 string
\f0\fs20  giving the name of the new subpopulation (such as 
\f2\fs18 "p5"
\f0\fs20  to specify an ID of 5).  The 
\f2\fs18 sourceSubpop
\f0\fs20  parameter may specify the source subpopulation either as a 
\f2\fs18 Subpopulation
\f0\fs20  object or by 
\f2\fs18 integer
\f0\fs20  identifier.  Only if sex is enabled in the simulation, the initial sex ratio may optionally be specified as 
\f2\fs18 sexRatio
\f0\fs20 ; if it is not specified, a default of 
\f2\fs18 0.5
\f0\fs20  is used.  The new subpopulation will be defined as a global variable immediately by this method, and will also be returned by this method.
\f3 \
\pard\pardeftab529\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (integer$)countOfMutationsOfType(io<MutationType>$\'a0mutType)
\f3 \
\pard\pardeftab529\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the number of mutations that are of the type specified by 
\f2\fs18 mutType
\f0\fs20 , out of all of the mutations that are currently active in the simulation.  If you need a vector of the matching 
\f2\fs18 Mutation
\f0\fs20  objects, rather than just a count, use 
\f2\fs18 -mutationsOfType()
\f3\fs20 .
\f0   This method is often used to determine whether an introduced mutation is still active (as opposed to being either lost or fixed).  This method is provided for speed; it is much faster than the corresponding Eidos code.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)deregisterScriptBlock(io<SLiMEidosBlock>\'a0scriptBlocks)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 All 
\f2\fs18 SLiMEidosBlock
\f0\fs20  objects specified by 
\f2\fs18 scriptBlocks
\f0\fs20  (either with 
\f2\fs18 SLiMEidosBlock
\f0\fs20  objects or with 
\f2\fs18 integer
\f0\fs20  identifiers) will be scheduled for deregistration.  The deregistered blocks remain valid, and may even still be executed in the current stage of the current generation; the blocks are not actually deregistered and deallocated until sometime after the currently executing script block has completed.  To immediately prevent a script block from executing, even when it is scheduled to execute in the current stage of the current generation, use the 
\f2\fs18 active
\f0\fs20  property of the script block.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (+)getValue(string$\'a0key)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the value previously set for the dictionary entry identifier 
\f2\fs18 key
\f0\fs20  using 
\f2\fs18 setValue()
\f0\fs20 , or 
\f2\fs18 NULL
\f0\fs20  if no value has been set.  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 SLiMSim
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(integer)mutationCounts(No<Subpopulation>\'a0subpops, [No<Mutation>\'a0mutations\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Return an 
\f2\fs18 integer
\f0\fs20  vector with the frequency counts of all of the 
\f2\fs18 Mutation
\f0\fs20  objects passed in 
\f2\fs18 mutations
\f0\fs20 , within the 
\f2\fs18 Subpopulation
\f0\fs20  objects in 
\f2\fs18 subpops
\f0\fs20 .  The 
\f2\fs18 subpops
\f0\fs20  argument is required, but you may pass 
\f2\fs18 NULL
\f0\fs20  to get population-wide frequency counts.  If the optional 
\f2\fs18 mutations
\f0\fs20  argument is 
\f2\fs18 NULL
\f0\fs20  (the default), frequency counts will be returned for all of the active 
\f2\fs18 Mutation
\f0\fs20  objects in the simulation \'96 the same 
\f2\fs18 Mutation
\f0\fs20  objects, and in the same order, as would be returned by the 
\f2\fs18 mutations
\f0\fs20  property of 
\f2\fs18 sim
\f0\fs20 , in other words.\
See the 
\f2\fs18 -mutationFrequencies()
\f0\fs20  method to obtain 
\f2\fs18 float
\f0\fs20  frequencies instead of 
\f2\fs18 integer
\f0\fs20  counts.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(float)mutationFrequencies(No<Subpopulation>\'a0subpops, [No<Mutation>\'a0mutations\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Return a 
\f2\fs18 float
\f0\fs20  vector with the frequencies of all of the 
\f2\fs18 Mutation
\f0\fs20  objects passed in 
\f2\fs18 mutations
\f0\fs20 , within the 
\f2\fs18 Subpopulation
\f0\fs20  objects in 
\f2\fs18 subpops
\f0\fs20 .  The 
\f2\fs18 subpops
\f0\fs20  argument is required, but you may pass 
\f2\fs18 NULL
\f0\fs20  to get population-wide frequencies.  If the optional 
\f2\fs18 mutations
\f0\fs20  argument is 
\f2\fs18 NULL
\f0\fs20  (the default), frequencies will be returned for all of the active 
\f2\fs18 Mutation
\f0\fs20  objects in the simulation \'96 the same 
\f2\fs18 Mutation
\f0\fs20  objects, and in the same order, as would be returned by the 
\f2\fs18 mutations
\f0\fs20  property of 
\f2\fs18 sim
\f0\fs20 , in other words.
\f3 \

\f0 See the 
\f2\fs18 -mutationCounts()
\f0\fs20  method to obtain 
\f2\fs18 integer
\f0\fs20  counts instead of 
\f2\fs18 float
\f0\fs20  frequencies.
\f3 \
\pard\pardeftab529\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (object<Mutation>)mutationsOfType(io<MutationType>$\'a0mutType)
\f3 \
\pard\pardeftab529\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns an 
\f2\fs18 object
\f0\fs20  vector of all the mutations that are of the type specified by 
\f2\fs18 mutType
\f0\fs20 , out of all of the mutations that are currently active in the simulation.  If you just need a count of the matching 
\f2\fs18 Mutation
\f0\fs20  objects, rather than a vector of the matches, use 
\f2\fs18 -countOfMutationsOfType()
\f3\fs20 .
\f0   This method is often used to look up an introduced mutation at a later point in the simulation, since there is no way to keep persistent references to objects in SLiM.  This method is provided for speed; it is much faster than the corresponding Eidos code.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)outputFixedMutations([Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F])
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Output all fixed mutations \'96 all 
\f2\fs18 Substitution
\f0\fs20  objects, in other words \'96 in a SLiM native format.  If the optional parameter 
\f2\fs18 filePath
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20  (the default), output will be sent to Eidos\'92s output stream.  Otherwise, output will be sent to the filesystem path specified by 
\f2\fs18 filePath
\f0\fs20 , overwriting that file if 
\f2\fs18 append
\f0\fs20  if 
\f2\fs18 F
\f0\fs20 , or appending to the end of it if 
\f2\fs18 append
\f0\fs20  is 
\f2\fs18 T
\f3\fs20 .
\f0   Mutations which have fixed but have not been turned into 
\f2\fs18 Substitution
\f0\fs20  objects \'96 typically because 
\f2\fs18 convertToSubstitution
\f0\fs20  has been set to 
\f2\fs18 F
\f0\fs20  for their mutation type \'96 are not output; they are still considered to be segregating mutations by SLiM.\
Output is generally done in a 
\f2\fs18 late()
\f0\fs20  event, so that the output reflects the state of the simulation at the end of a generation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)outputFull([Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0binary\'a0=\'a0F], [logical$\'a0append\'a0=\'a0F], [logical$\'a0spatialPositions\'a0=\'a0T]\cf2 \expnd0\expndtw0\kerning0
, [logical$\'a0ages\'a0=\'a0T]\cf0 \kerning1\expnd0\expndtw0 )
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Output the state of the entire population.  If the optional parameter 
\f2\fs18 filePath
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20  (the default), output will be sent to Eidos\'92s output stream.  Otherwise, output will be sent to the filesystem path specified by 
\f2\fs18 filePath
\f0\fs20 , overwriting that file if 
\f2\fs18 append
\f0\fs20  if 
\f2\fs18 F
\f0\fs20 , or appending to the end of it if 
\f2\fs18 append
\f0\fs20  is 
\f2\fs18 T
\f3\fs20 .
\f0   When writing to a file, a 
\f2\fs18 logical
\f0\fs20  flag, 
\f2\fs18 binary
\f0\fs20 , may be supplied as well.  If 
\f2\fs18 binary
\f0\fs20  is 
\f2\fs18 T
\f0\fs20 , the population state will be written as a binary file instead of a text file (binary data cannot be written to the standard output stream).  The binary file is usually smaller, and in any case will be read much faster than the corresponding text file would be read.  Binary files are not guaranteed to be portable between platforms; in other words, a binary file written on one machine may not be readable on a different machine (but in practice it usually will be, unless the platforms being used are fairly unusual).  If 
\f2\fs18 binary
\f0\fs20  is 
\f2\fs18 F
\f0\fs20  (the default), a text file will be written.\
Beginning with SLiM 2.3, the 
\f2\fs18 spatialPositions
\f0\fs20  parameter may be used to control the output of the spatial positions of individuals in simulations for which continuous space has been enabled using the 
\f2\fs18 dimensionality
\f0\fs20  option of 
\f2\fs18 initializeSLiMOptions()
\f3\fs20 .
\f0   If 
\f2\fs18 spatialPositions
\f0\fs20  is 
\f2\fs18 F
\f0\fs20 , the output will not contain spatial positions, and will be identical to the output generated by SLiM 2.1 and later.  If 
\f2\fs18 spatialPositions
\f0\fs20  is 
\f2\fs18 T
\f0\fs20 , spatial position information will be output if it is available.  If the simulation does not have continuous space enabled, the 
\f2\fs18 spatialPositions
\f0\fs20  parameter will be ignored.  Positional information may be output for all output destinations \'96 the Eidos output stream, a text file, or a binary file.
\f3 \
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
Beginning with SLiM 3.0, the 
\f2\fs18 ages
\f0\fs20  parameter may be used to control the output of the ages of individuals in nonWF simulations.  If 
\f2\fs18 ages
\f0\fs20  is 
\f2\fs18 F
\f0\fs20 , the output will not contain ages, preserving backward compatibility with the output format of SLiM 2.1 and later.  If 
\f2\fs18 ages
\f0\fs20  is 
\f2\fs18 T
\f0\fs20 , ages will be output for nonWF models.  In WF simulations, the ages parameter will be ignored.\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 Output is generally done in a 
\f2\fs18 late()
\f0\fs20  event, so that the output reflects the state of the simulation at the end of a generation.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)outputMutations(object<Mutation>\'a0mutations, [Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F])
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Output all of the given mutations.  This can be used to output all mutations of a given mutation type, for example.  If the optional parameter 
\f2\fs18 filePath
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20  (the default), output will be sent to Eidos\'92s output stream, overwriting that file if 
\f2\fs18 append
\f0\fs20  if 
\f2\fs18 F
\f0\fs20 , or appending to the end of it if 
\f2\fs18 append
\f0\fs20  is 
\f2\fs18 T
\f3\fs20 .
\f0   Otherwise, output will be sent to the filesystem path specified by 
\f2\fs18 filePath
\f3\fs20 .
\f0   If output is sent to a file, it will be 
\i appended
\i0  to that file, unlike all other SLiM output methods (which replace an existing file).  This is done because tracking mutations is generally done over many generations, with new tracking data being output in each generation; if appending is not desired, use the Eidos 
\f2\fs18 deleteFile()
\f0\fs20  function to remove any pre-existing file prior to output
\f3 .\

\f0 Output is generally done in a 
\f2\fs18 late()
\f0\fs20  event, so that the output reflects the state of the simulation at the end of a generation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(integer$)readFromPopulationFile(string$\'a0filePath)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Read from a population initialization file, whether in text or binary format as previously specified to 
\f2\fs18 outputFull()
\f3\fs20 ,
\f0  and return the generation counter value represented by the file\'92s contents (i.e., the generation at which the file was generated).  Although this is most commonly used to set up initial populations (often in an Eidos event set to run in generation 1, immediately after simulation initialization), it may be called in any Eidos event; the current state of all populations will be wiped and replaced by the state in the file at 
\f2\fs18 filePath
\f0\fs20 .  All Eidos variables that are of type 
\f2\fs18 object
\f0\fs20  and have element type 
\f2\fs18 Subpopulation
\f0\fs20 , 
\f2\fs18 Genome
\f0\fs20 , 
\f2\fs18 Mutation
\f0\fs20 , 
\f2\fs18 Individual
\f0\fs20 , or 
\f2\fs18 Substitution
\f0\fs20  will be removed as a side effect of this method, since all such variables would refer to objects that no longer exist in the SLiM simulation; if you want to preserve any of that state, you should output it or save it to a file prior to this call.  New symbols will be defined to refer to the new 
\f2\fs18 Subpopulation
\f0\fs20  objects loaded from the file.  Fitness values will be calculated immediately for any new subpopulations created by this call, which will trigger the calling of any activated and applicable 
\f2\fs18 fitness()
\f0\fs20  callbacks.  Note that it is likely to be better to call 
\f2\fs18 readFromPopulationFile()
\f0\fs20  in a 
\f2\fs18 late()
\f0\fs20  event, so that fitness values are being recalculated at the usual time in the generation life cycle.\
As of SLiM 2.1, this method changes the generation counter to the generation read from the file.  If you do not want the generation counter to be changed, you can change it back after reading, by setting 
\f2\fs18 sim.generation
\f0\fs20  to whatever value you wish.  Note that restoring a saved past state and running forward again will not yield the same simulation results, because the random number generator\'92s state will not be the same; to ensure reproducibility from a given time point, 
\f2\fs18 setSeed()
\f0\fs20  can be used to establish a new seed value.  Any changes made to the simulation\'92s structure (mutation types, genomic element types, etc.) will not be wiped and re-established by 
\f2\fs18 readFromPopulationFile()
\f0\fs20 ; this method loads only the population\'92s state, not the simulation configuration, so care should be taken to ensure that the simulation structure meshes coherently with the loaded data.\
As of SLiM 2.3, this method will read and restore the spatial positions of individuals if that information is present in the output file and the simulation has enabled continuous space (see 
\f2\fs18 outputFull()
\f0\fs20  for details).  If spatial positions are present in the output file but the simulation has not enabled continuous space (or the number of spatial dimensions does not match), an error will result.  If the simulation has enabled continuous space but spatial positions are not present in the output file, the spatial positions of the individuals read will be undefined, but an error is not raised.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(integer$)readFromPopulationFile(string$\'a0filePath)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Read from a population initialization file, whether in text or binary format as previously specified to 
\f2\fs18 outputFull()
\f3\fs20 ,
\f0  and return the generation counter value represented by the file\'92s contents (i.e., the generation at which the file was generated).  Although this is most commonly used to set up initial populations (often in an Eidos event set to run in generation 1, immediately after simulation initialization), it may be called in any Eidos event; the current state of all populations will be wiped and replaced by the state in the file at 
\f2\fs18 filePath
\f0\fs20 .  All Eidos variables that are of type 
\f2\fs18 object
\f0\fs20  and have element type 
\f2\fs18 Subpopulation
\f0\fs20 , 
\f2\fs18 Genome
\f0\fs20 , 
\f2\fs18 Mutation
\f0\fs20 , 
\f2\fs18 Individual
\f0\fs20 , or 
\f2\fs18 Substitution
\f0\fs20  will be removed as a side effect of this method, since all such variables would refer to objects that no longer exist in the SLiM simulation; if you want to preserve any of that state, you should output it or save it to a file prior to this call.  New symbols will be defined to refer to the new 
\f2\fs18 Subpopulation
\f0\fs20  objects loaded from the file.\
If the file being read was written by a version of SLiM prior to 2.3, then for backward compatibility fitness values will be calculated immediately for any new subpopulations created by this call, which will trigger the calling of any activated and applicable 
\f2\fs18 fitness()
\f0\fs20  callbacks.  When reading files written by SLiM 2.3 or later, fitness values are not calculated as a side effect of this call (because the simulation will often need to evaluate interactions or modify other state prior to doing so).\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
In SLiM 2.3 and later when using the WF model, calling 
\f2\fs18 readFromPopulationFile()
\f0\fs20  from any context other than a 
\f2\fs18 late()
\f0\fs20  event causes a warning; calling from a 
\f2\fs18 late()
\f0\fs20  event is almost always correct in WF models, so that fitness values can be automatically recalculated by SLiM at the usual time in the generation cycle without the need to force their recalculation (see chapter 18, and comments on 
\f2\fs18 recalculateFitness()
\f0\fs20 ).\
In SLiM 3.0 when using the nonWF model, calling 
\f2\fs18 readFromPopulationFile()
\f0\fs20  from any context other than an 
\f2\fs18 early()
\f0\fs20  event causes a warning; calling from an 
\f2\fs18 early()
\f0\fs20  event is almost always correct in nonWF models, so that fitness values can be automatically recalculated by SLiM at the usual time in the generation cycle without the need to force their recalculation (see chapter 19, and comments on 
\f2\fs18 recalculateFitness()
\f0\fs20 ).\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 As of SLiM 2.1, this method changes the generation counter to the generation read from the file.  If you do not want the generation counter to be changed, you can change it back after reading, by setting 
\f2\fs18 sim.generation
\f0\fs20  to whatever value you wish.  Note that restoring a saved past state and running forward again will not yield the same simulation results, because the random number generator\'92s state will not be the same; to ensure reproducibility from a given time point, 
\f2\fs18 setSeed()
\f0\fs20  can be used to establish a new seed value.  Any changes made to the simulation\'92s structure (mutation types, genomic element types, etc.) will not be wiped and re-established by 
\f2\fs18 readFromPopulationFile()
\f0\fs20 ; this method loads only the population\'92s state, not the simulation configuration, so care should be taken to ensure that the simulation structure meshes coherently with the loaded data.\
As of SLiM 2.3, this method will read and restore the spatial positions of individuals if that information is present in the output file and the simulation has enabled continuous space (see 
\f2\fs18 outputFull()
\f0\fs20  for details).  If spatial positions are present in the output file but the simulation has not enabled continuous space (or the number of spatial dimensions does not match), an error will result.  If the simulation has enabled continuous space but spatial positions are not present in the output file, the spatial positions of the individuals read will be undefined, but an error is not raised.\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
As of SLiM 3.0, this method will read and restore the ages of individuals if that information is present in the output file and the simulation is based upon the nonWF model.  If ages are present but the simulation uses a WF model, an error will result; the WF model does not use age information.  If ages are not present but the simulation uses a nonWF model, an error will also result; the nonWF model requires age information.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(void)recalculateFitness([Ni$\'a0generation\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Force an immediate recalculation of fitness values for all individuals in all subpopulations.  Normally fitness values are calculated at the end of each generation, and those values are cached and used throughout the following generation.  If simulation parameters are changed in script in a way that affects fitness calculations, and if you wish those changes to take effect immediately rather than taking effect at the end of the current generation, you may call 
\f2\fs18 recalculateFitness()
\f0\fs20  to force an immediate recalculation and recache.\
\pard\pardeftab543\li547\ri720\sb60\sa60\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
The optional parameter 
\f2\fs18 generation
\f0\fs20  provides the generation for which 
\f2\fs18 fitness()
\f0\fs20  callbacks should be selected; if it is 
\f2\fs18 NULL
\f0\fs20  (the default), the simulation\'92s current generation value, 
\f2\fs18 sim.generation
\f0\fs20 , is used.  If you call 
\f2\fs18 recalculateFitness()
\f0\fs20  in an 
\f2\fs18 early()
\f0\fs20  event in a WF model, you may wish this to be 
\f2\fs18 sim.generation - 1
\f0\fs20  in order to utilize the 
\f2\fs18 fitness()
\f0\fs20  callbacks for the previous generation, as if the changes that you have made to fitness-influencing parameters were already in effect at the end of the previous generation when the new generation was first created and evaluated (usually it is simpler to just make such changes in a 
\f2\fs18 late()
\f0\fs20  event instead, however, in which case calling 
\f2\fs18 recalculateFitness()
\f0\fs20  is probably not necessary at all since fitness values will be recalculated immediately afterwards).  Regardless of the value supplied for 
\f2\fs18 generation
\f0\fs20  here, 
\f2\fs18 sim.generation
\f0\fs20  inside 
\f2\fs18 fitness()
\f0\fs20  callbacks will report the true generation number, so if your callbacks consult that parameter in order to create generation-specific fitness effects you will need to handle the discrepancy somehow.  (Similar considerations apply for nonWF models that call 
\f2\fs18 recalculateFitness()
\f0\fs20  in a 
\f2\fs18 late()
\f0\fs20  event, which is also not advisable in general.)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 After this call, the fitness values used for all purposes in SLiM will be the newly calculated values.  Calling this method will trigger the calling of any enabled and applicable 
\f2\fs18 fitness()
\f0\fs20  callbacks, so this is quite a heavyweight operation; you should think carefully about what side effects might result (which is why fitness recalculation does not just occur automatically after changes that might affect fitness values).
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerEarlyEvent(Nis$\'a0id, string$\'a0source, [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f2\fs18 string
\f0\fs20  singleton 
\f2\fs18 source
\f0\fs20 , as an Eidos 
\f2\fs18 early()
\f0\fs20  event in the current simulation, with optional 
\f2\fs18 start
\f0\fs20  and 
\f2\fs18 end
\f0\fs20  generations limiting its applicability.  The script block will be given identifier 
\f2\fs18 id
\f0\fs20  (specified as an 
\f2\fs18 integer
\f0\fs20 , or as a 
\f2\fs18 string
\f0\fs20  symbolic name such as 
\f2\fs18 "s5"
\f0\fs20 ); this may be 
\f2\fs18 NULL
\f0\fs20  if there is no need to be able to refer to the block later.  The registered event is added to the end of the list of registered 
\f2\fs18 SLiMEidosBlock
\f0\fs20  objects, and is active immediately; it 
\i may
\i0  be eligible to execute in the current generation.  The new 
\f2\fs18 SLiMEidosBlock
\f0\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerFitnessCallback(Nis$\'a0id, string$\'a0source, Nio<MutationType>$\'a0mutType, [Nio<Subpopulation>$\'a0subpop
\f3 \'a0
\f2 =\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f2\fs18 string
\f0\fs20  singleton 
\f2\fs18 source
\f0\fs20 , as an Eidos 
\f2\fs18 fitness()
\f0\fs20  callback in the current simulation, with a required mutation type 
\f2\fs18 mutType
\f0\fs20  (which may be an 
\f2\fs18 integer
\f0\fs20  mutation type identifier, or 
\f2\fs18 NULL
\f0\fs20  to indicate a global 
\f2\fs18 fitness()
\f0\fs20  callback), optional subpopulation 
\f2\fs18 subpop
\f0\fs20  (which may also be an 
\f2\fs18 integer
\f0\fs20  identifier, or 
\f2\fs18 NULL
\f0\fs20 , the default, to indicate all subpopulations), and optional 
\f2\fs18 start
\f0\fs20  and 
\f2\fs18 end
\f0\fs20  generations all limiting its applicability.  The script block will be given identifier 
\f2\fs18 id
\f0\fs20  (specified as an 
\f2\fs18 integer
\f0\fs20 , or as a 
\f2\fs18 string
\f0\fs20  symbolic name such as 
\f2\fs18 "s5"
\f0\fs20 ); this may be 
\f2\fs18 NULL
\f0\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f2\fs18 SLiMEidosBlock
\f0\fs20  objects, and is active immediately; it 
\i may
\i0  be eligible to execute in the current generation.  The new 
\f2\fs18 SLiMEidosBlock
\f0\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerInteractionCallback(Nis$\'a0id, string$\'a0source, io<InteractionType>$\'a0intType, [Nio<Subpopulation>$\'a0subpop
\f3 \'a0
\f2 =\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f2\fs18 string
\f0\fs20  singleton 
\f2\fs18 source
\f0\fs20 , as an Eidos 
\f2\fs18 interaction()
\f0\fs20  callback in the current simulation, with a required interaction type 
\f2\fs18 intType
\f0\fs20  (which may be an 
\f2\fs18 integer
\f0\fs20  identifier), optional subpopulation 
\f2\fs18 subpop
\f0\fs20  (which may also be an 
\f2\fs18 integer
\f0\fs20  identifier, or 
\f2\fs18 NULL
\f0\fs20 , the default, to indicate all subpopulations), and optional 
\f2\fs18 start
\f0\fs20  and 
\f2\fs18 end
\f0\fs20  generations all limiting its applicability.  The script block will be given identifier 
\f2\fs18 id
\f0\fs20  (specified as an 
\f2\fs18 integer
\f0\fs20 , or as a 
\f2\fs18 string
\f0\fs20  symbolic name such as 
\f2\fs18 "s5"
\f0\fs20 ); this may be 
\f2\fs18 NULL
\f0\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f2\fs18 SLiMEidosBlock
\f0\fs20  objects, and is active immediately; it will be eligible to execute the next time an 
\f2\fs18 InteractionType
\f0\fs20  is evaluated.  The new 
\f2\fs18 SLiMEidosBlock
\f0\fs20  will be defined as a global variable immediately by this method (see section 18
\f3 .
\f0 10), and will also be returned by this method.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerLateEvent(Nis$\'a0id, string$\'a0source, [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f2\fs18 string
\f0\fs20  singleton 
\f2\fs18 source
\f0\fs20 , as an Eidos 
\f2\fs18 late()
\f0\fs20  event in the current simulation, with optional 
\f2\fs18 start
\f0\fs20  and 
\f2\fs18 end
\f0\fs20  generations limiting its applicability.  The script block will be given identifier 
\f2\fs18 id
\f0\fs20  (specified as an 
\f2\fs18 integer
\f0\fs20 , or as a 
\f2\fs18 string
\f0\fs20  symbolic name such as 
\f2\fs18 "s5"
\f0\fs20 ); this may be 
\f2\fs18 NULL
\f0\fs20  if there is no need to be able to refer to the block later.  The registered event is added to the end of the list of registered 
\f2\fs18 SLiMEidosBlock
\f0\fs20  objects, and is active immediately; it 
\i may
\i0  be eligible to execute in the current generation.  The new 
\f2\fs18 SLiMEidosBlock
\f0\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerMateChoiceCallback(Nis$\'a0id, string$\'a0source, [Nio<Subpopulation>$\'a0subpop\'a0=\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f2\fs18 string
\f0\fs20  singleton 
\f2\fs18 source
\f0\fs20 , as an Eidos 
\f2\fs18 mateChoice()
\f0\fs20  callback in the current simulation, with optional subpopulation 
\f2\fs18 subpop
\f0\fs20  (which may be an 
\f2\fs18 integer
\f0\fs20  identifier, or 
\f2\fs18 NULL
\f0\fs20 , the default, to indicate all subpopulations) and optional 
\f2\fs18 start
\f0\fs20  and 
\f2\fs18 end
\f0\fs20  generations all limiting its applicability.  The script block will be given identifier 
\f2\fs18 id
\f0\fs20  (specified as an 
\f2\fs18 integer
\f0\fs20 , or as a 
\f2\fs18 string
\f0\fs20  symbolic name such as 
\f2\fs18 "s5"
\f0\fs20 ); this may be 
\f2\fs18 NULL
\f0\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f2\fs18 SLiMEidosBlock
\f0\fs20  objects, and is active immediately; it 
\i may
\i0  be eligible to execute in the current generation.  The new 
\f2\fs18 SLiMEidosBlock
\f0\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerModifyChildCallback(Nis$\'a0id, string$\'a0source, [Nio<Subpopulation>$\'a0subpop
\f3 \'a0
\f2 =\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f2\fs18 string
\f0\fs20  singleton 
\f2\fs18 source
\f0\fs20 , as an Eidos 
\f2\fs18 modifyChild()
\f0\fs20  callback in the current simulation, with optional subpopulation 
\f2\fs18 subpop
\f0\fs20  (which may be an 
\f2\fs18 integer
\f0\fs20  identifier, or 
\f2\fs18 NULL
\f0\fs20 , the default, to indicate all subpopulations) and optional 
\f2\fs18 start
\f0\fs20  and 
\f2\fs18 end
\f0\fs20  generations all limiting its applicability.  The script block will be given identifier 
\f2\fs18 id
\f0\fs20  (specified as an 
\f2\fs18 integer
\f0\fs20 , or as a 
\f2\fs18 string
\f0\fs20  symbolic name such as 
\f2\fs18 "s5"
\f0\fs20 ); this may be 
\f2\fs18 NULL
\f0\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f2\fs18 SLiMEidosBlock
\f0\fs20  objects, and is active immediately; it 
\i may
\i0  be eligible to execute in the current generation.  The new 
\f2\fs18 SLiMEidosBlock
\f0\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerRecombinationCallback(Nis$\'a0id, string$\'a0source, [Nio<Subpopulation>$\'a0subpop
\f3 \'a0
\f2 =\'a0NULL], [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Register a block of Eidos source code, represented as the 
\f2\fs18 string
\f0\fs20  singleton 
\f2\fs18 source
\f0\fs20 , as an Eidos 
\f2\fs18 recombination()
\f0\fs20  callback in the current simulation, with optional subpopulation 
\f2\fs18 subpop
\f0\fs20  (which may be an 
\f2\fs18 integer
\f0\fs20  identifier, or 
\f2\fs18 NULL
\f0\fs20 , the default, to indicate all subpopulations) and optional 
\f2\fs18 start
\f0\fs20  and 
\f2\fs18 end
\f0\fs20  generations all limiting its applicability.  The script block will be given identifier 
\f2\fs18 id
\f0\fs20  (specified as an 
\f2\fs18 integer
\f0\fs20 , or as a 
\f2\fs18 string
\f0\fs20  symbolic name such as 
\f2\fs18 "s5"
\f0\fs20 ); this may be 
\f2\fs18 NULL
\f0\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f2\fs18 SLiMEidosBlock
\f0\fs20  objects, and is active immediately; it 
\i may
\i0  be eligible to execute in the current generation.  The new 
\f2\fs18 SLiMEidosBlock
\f0\fs20  will be defined as a global variable immediately by this method, and will also be returned by this method.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(object<SLiMEidosBlock>$)registerReproductionCallback(Nis$\'a0id, string$\'a0source, [Nio<Subpopulation>$\'a0subpop
\f3 \'a0
\f2 =\'a0NULL], \cf2 \expnd0\expndtw0\kerning0
[Ns$\'a0sex\'a0=\'a0NULL], \cf0 \kerning1\expnd0\expndtw0 [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
Register a block of Eidos source code, represented as the 
\f2\fs18 string
\f0\fs20  singleton 
\f2\fs18 source
\f0\fs20 , as an Eidos 
\f2\fs18 reproduction()
\f0\fs20  callback in the current simulation, with optional subpopulation 
\f2\fs18 subpop
\f0\fs20  (which may be an 
\f2\fs18 integer
\f0\fs20  identifier, or 
\f2\fs18 NULL
\f0\fs20 , the default, to indicate all subpopulations), optional sex-specificity 
\f2\fs18 sex
\f0\fs20  (which may be 
\f2\fs18 "M"
\f0\fs20  or 
\f2\fs18 "F"
\f0\fs20  in sexual simulations to make the callback specific to males or females respectively, or 
\f2\fs18 NULL
\f0\fs20  for no sex-specificity), and optional 
\f2\fs18 start
\f0\fs20  and 
\f2\fs18 end
\f0\fs20  generations all limiting its applicability.  The script block will be given identifier 
\f2\fs18 id
\f0\fs20  (specified as an 
\f2\fs18 integer
\f0\fs20 , or as a 
\f2\fs18 string
\f0\fs20  symbolic name such as 
\f2\fs18 "s5"
\f0\fs20 ); this may be 
\f2\fs18 NULL
\f0\fs20  if there is no need to be able to refer to the block later.  The registered callback is added to the end of the list of registered 
\f2\fs18 SLiMEidosBlock
\f0\fs20  objects, and is active immediately; it 
\i may
\i0  be eligible to execute in the current generation (see section 21.8 for details).  The new 
\f2\fs18 SLiMEidosBlock
\f0\fs20  will be defined as a global variable immediately by this method (see section 20.10), and will also be returned by this method.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(object<SLiMEidosBlock>)rescheduleScriptBlock(object<SLiMEidosBlock>$
\f3 \'a0
\f2 block, [Ni$\'a0start\'a0=\'a0NULL], [Ni$\'a0end\'a0=\'a0NULL], [Ni\'a0generations\'a0=\'a0NULL])
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Reschedule the target script block given by 
\f2\fs18 block
\f0\fs20  to execute in a specified set of generations.\
The first way to specify the generation set is with 
\f2\fs18 start
\f0\fs20  and 
\f2\fs18 end
\f0\fs20  parameter values; 
\f2\fs18 block
\f0\fs20  will then execute from 
\f2\fs18 start
\f0\fs20  to 
\f2\fs18 end
\f0\fs20 , inclusive.  In this case, 
\f2\fs18 block
\f0\fs20  is returned.\
The second way to specify the generation set is using the 
\f2\fs18 generations
\f0\fs20  parameter; this is more flexible but more complicated.  Since script blocks execute across a contiguous span of generations defined by their 
\f2\fs18 start
\f0\fs20  and 
\f2\fs18 end
\f0\fs20  properties, this may result in the duplication of 
\f2\fs18 block
\f0\fs20 ; one script block will be used for each contiguous span of generations in 
\f2\fs18 generations
\f3\fs20 .
\f0   The 
\f2\fs18 block
\f0\fs20  object itself will be rescheduled to cover the first such span, whereas duplicates of 
\f2\fs18 block
\f0\fs20  will be created to cover subsequent contiguous spans.  A vector containing all of the script blocks scheduled by this method, including 
\f2\fs18 block
\f0\fs20 , will be returned; this vector is guaranteed to be sorted by the (ascending) scheduled execution order of the blocks.  Any duplicates of 
\f2\fs18 block
\f0\fs20  created will be given values for the 
\f2\fs18 active
\f0\fs20 , 
\f2\fs18 source
\f0\fs20 , 
\f2\fs18 tag
\f0\fs20 , and 
\f2\fs18 type
\f0\fs20  properties equal to the current values for 
\f2\fs18 block
\f0\fs20 , but will be given an 
\f2\fs18 id
\f0\fs20  of 
\f2\fs18 -1
\f0\fs20  since script block identifiers must be unique; if it is necessary to find the duplicated blocks again later, their 
\f2\fs18 tag
\f0\fs20  property should be used.  The vector supplied for 
\f2\fs18 generations
\f0\fs20  does not need to be in sorted order, but it must not contain any duplicates.\
Because this method can create a large number of duplicate script blocks, it can sometimes be better to handle script block scheduling in other ways.  If an 
\f2\fs18 early()
\f0\fs20  event needs to execute every tenth generation over the whole duration of a long model run, for example, it would not be advisable to use a call like 
\f2\fs18 sim.rescheduleScriptBlock(s1, generations=seq(10, 100000, 10))
\f0\fs20  for that purpose, since that would result in thousands of duplicate script blocks.  Instead, it would be preferable to add a test such as 
\f2\fs18 if (sim.generation % 10 != 0) return;
\f0\fs20  at the beginning of the event.  It is legal to reschedule a script block while the block is executing; a call like 
\f2\fs18 sim.rescheduleScriptBlock(self, sim.generation + 10, sim.generation + 10);
\f0\fs20  made inside a given block would therefore also cause the block to execute every tenth generation, although this sort of self-rescheduling code is probably harder to read, maintain, and debug.\
Whichever way of specifying the generation set is used, the discussion in section 19.7 applies: 
\f2\fs18 block
\f0\fs20  may continue to be executed during the current life cycle stage even after it has been rescheduled, unless it is made inactive using its 
\f2\fs18 active
\f0\fs20  property, and similarly, the block may not execute during the current life cycle stage if it was not already scheduled to do so.  Rescheduling script blocks during the generation and life cycle stage in which they are executing, or in which they are intended to execute, should be avoided.\
Note that new script blocks can also be created and scheduled using the 
\f2\fs18 register...()
\f0\fs20  methods of 
\f2\fs18 SLiMSim
\f0\fs20 ; by using the same source as a template script block, the template can be duplicated and scheduled for different generations.  In fact, 
\f2\fs18 rescheduleScriptBlock()
\f0\fs20  does essentially that internally.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (void)setValue(string$\'a0key, +\'a0value)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Sets a value for the dictionary entry identifier 
\f2\fs18 key
\f3\fs20 .
\f0   The value, which may be of any type other than 
\f2\fs18 object
\f0\fs20 , can be fetched later using 
\f2\fs18 getValue()
\f0\fs20 .  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 SLiMSim
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)simulationFinished(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Declare the current simulation finished.  Normally SLiM ends a simulation when, at the end of a generation, there are no script events or callbacks registered for any future generation (excluding scripts with no declared end generation).  If you wish to end a simulation before this condition is met, a call to 
\f2\fs18 simulationFinished()
\f0\fs20  will cause the current simulation to end at the end of the current generation.  For example, a simulation might self-terminate if a test for a dynamic equilibrium condition is satisfied.  Note that the current generation will finish executing; if you want the simulation to stop immediately, you can use the Eidos method 
\f2\fs18 stop()
\f0\fs20 , which raises an error condition.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(void)treeSeqSimplify(void)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Triggers an immediate simplification of the tree sequence recording tables.  This method may only be called if tree sequence recording has been turned on with 
\f2\fs18 initializeTreeSeq()
\f0\fs20 .  A call to this method will free up memory being used by entries that are no longer in the ancestral path of any individual within the current sample (currently living individuals, in other words, plus those explicitly added to the sample with 
\f2\fs18 treeSeqRememberIndividuals()
\f0\fs20 ), but it can also take a significant amount of time.  Typically calling this method is not necessary; the automatic simplification performed occasionally by SLiM should be sufficient for most models.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \'96\'a0(void)treeSeqRememberIndividuals(object<Individual>\'a0individuals)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Permanently adds the individuals specified by 
\f2\fs18 individuals
\f0\fs20  to the sample retained across tree sequence table simplification.  This method may only be called if tree sequence recording has been turned on with 
\f2\fs18 initializeTreeSeq()
\f0\fs20 .  All currently living individuals are always retained across simplification; this method does not need to be called, and indeed should not be called, for that purpose.  Instead, 
\f2\fs18 treeSeqRememberIndividuals()
\f0\fs20  is for 
\i permanently
\i0  adding particular individuals to the retained sample.  Typically this would be used, for example, to retain the initial individuals created in new subpopulations with 
\f2\fs18 addSubpop()
\f0\fs20 , if you wanted the tree sequences recorded to include the ultimate ancestors that root the whole simulated tree.  However, this is not the typical usage pattern for the tree sequence recording; most models will not need to call this method.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \'96\'a0(void)treeSeqOutput(string$\'a0path, [logical$\'a0binary\'a0=\'a0T], [logical$\'a0simplify\'a0=\'a0T])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Outputs the current tree sequence recording tables to the path specified by path.  This method may only be called if tree sequence recording has been turned on with 
\f2\fs18 initializeTreeSeq()
\f0\fs20 .  If 
\f2\fs18 simplify
\f0\fs20  is 
\f2\fs18 T
\f0\fs20  (the default), simplification will be done immediately prior to output; this is almost always desirable, unless a model wishes to avoid simplification entirely.  If 
\f2\fs18 binary
\f0\fs20  is 
\f2\fs18 T
\f0\fs20  (the default), a single binary tree sequence file will be written to the specified path; if 
\f2\fs18 binary
\f0\fs20  is 
\f2\fs18 F
\f0\fs20 , the path should be a path to a directory, which will be created if it does not already exist, and the tree sequences recording tables will be written to text files within that directory.\
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\b\fs22 \cf0 \kerning1\expnd0\expndtw0 5.12  Class Subpopulation\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 5.12.1  
\f1\fs18 Subpopulation
\f0\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 cloningRate => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The fraction of children in the next generation that will be produced by cloning (as opposed to biparental mating).  In non-sexual (i.e. hermaphroditic) simulations, this property is a singleton 
\f2\fs18 float
\f0\fs20  representing the overall subpopulation cloning rate.  In sexual simulations, this property is a 
\f2\fs18 float
\f0\fs20  vector with two values: the cloning rate for females (at index 
\f2\fs18 0
\f0\fs20 ) and for males (at index 
\f2\fs18 1
\f0\fs20 ).
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 firstMaleIndex => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The index of the first male individual in the subpopulation.  The 
\f2\fs18 genomes
\f0\fs20  vector is sorted into females first and males second; 
\f2\fs18 firstMaleIndex
\f0\fs20  gives the position of the boundary between those sections.  Note, however, that there are two genomes per diploid individual, and the 
\f2\fs18 firstMaleIndex
\f0\fs20  is 
\i not
\i0  premultiplied by 
\f2\fs18 2
\f0\fs20 ; you must multiply it by 
\f2\fs18 2
\f0\fs20  before using it to decide whether a given index into 
\f2\fs18 genomes
\f0\fs20  is a genome for a male or a female.  The 
\f2\fs18 firstMaleIndex
\f0\fs20  property is also the number of females in the subpopulation, given this design.  For non-sexual (i.e. hermaphroditic) simulations, this property has an undefined value and should not be used.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \expnd0\expndtw0\kerning0
fitnessScaling <\'96> (float$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 A 
\f2\fs18 float
\f0\fs20  scaling factor applied to the fitness of all individuals in this subpopulation (i.e., the fitness value computed for each individual will be multiplied by this value).  This is primarily of use in nonWF models, where fitness is absolute, rather than in WF models, where fitness is relative (and thus a constant factor multiplied into the fitness of every individual will make no difference); however, it may be used in either type of model.  This provides a simple, fast way to modify the fitness of all individuals in a subpopulation; conceptually it is similar to returning the same fitness effect for all individuals in the subpopulation from a 
\f2\fs18 fitness(NULL)
\f0\fs20  callback, but without the complexity and performance overhead of implementing such a callback.  To scale the fitness of individuals by different (individual-specific) factors, see the 
\f2\fs18 fitnessScaling
\f0\fs20  property of 
\f2\fs18 Individual
\f0\fs20 .\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0
\cf2 The value of 
\f2\fs18 fitnessScaling
\f0\fs20  is reset to 
\f2\fs18 1.0
\f0\fs20  every generation, so that any scaling factor set lasts for only a single generation.  This reset occurs immediately after fitness values are calculated, in both WF and nonWF models.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 genomes => (object<Genome>)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 All of the genomes contained by the subpopulation; there are two genomes per diploid individual.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The identifier for this subpopulation; for subpopulation 
\f2\fs18 p3
\f0\fs20 , for example, this is 
\f2\fs18 3
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 immigrantSubpopFractions => (float)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The expected value of the fraction of children in the next generation that are immigrants arriving from particular subpopulations.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 immigrantSubpopIDs => (integer)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The identifiers of the particular subpopulations from which immigrants will arrive in the next generation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 individualCount => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The number of individuals in the subpopulation; one-half of the number of genomes.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 individuals => (object<Individual>)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 All of the individuals contained by the subpopulation.  Each individual is diploid and thus contains two 
\f2\fs18 Genome
\f0\fs20  objects.\cf2 \expnd0\expndtw0\kerning0
  See the 
\f2\fs18 sampleIndividuals()
\f0\fs20  and 
\f2\fs18 subsetIndividuals()
\f0\fs20  for fast ways to get a subset of the individuals in a subpopulation.
\f3 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 selfingRate => (float$)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The expected value of the fraction of children in the next generation that will be produced by selfing (as opposed to biparental mating).  Selfing is only possible in non-sexual (i.e. hermaphroditic) simulations; for sexual simulations this property always has a value of 
\f2\fs18 0.0
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 sexRatio => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 For sexual simulations, the sex ratio for the subpopulation.  This is defined, in SLiM, as the fraction of the subpopulation that is male; in other words, it is actually the M:(M+F) ratio.  For non-sexual (i.e. hermaphroditic) simulations, this property has an undefined value and should not be used.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 spatialBounds => (float)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The spatial boundaries of the subpopulation.  The length of the 
\f2\fs18 spatialBounds
\f0\fs20  property depends upon the spatial dimensionality declared with 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .  If the spatial dimensionality is zero (as it is by default), the value of this property is 
\f2\fs18 float(0)
\f0\fs20  (a zero-length 
\f2\fs18 float
\f0\fs20  vector).  Otherwise, minimums are supplied for each coordinate used by the dimensionality of the simulation, followed by maximums for each.  In other words, if the declared dimensionality is 
\f2\fs18 "xy"
\f0\fs20 , the 
\f2\fs18 spatialBounds
\f0\fs20  property will contain values 
\f2\fs18 (x0,\'a0y0,\'a0x1,\'a0y1)
\f0\fs20 ; bounds for the 
\i z
\i0  coordinate will not be included in that case, since that coordinate is not used in the simulation\'92s dimensionality.  This property cannot be set, but the 
\f2\fs18 setSpatialBounds()
\f0\fs20  method may be used to achieve the same thing.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value.  The value of 
\f2\fs18 tag
\f0\fs20  is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.  The value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.  See also the 
\f2\fs18 getValue()
\f0\fs20  and 
\f2\fs18 setValue()
\f0\fs20  methods, for another way of attaching state to subpopulations.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\fs22 \cf0 5.12.2  
\f1\fs18 Subpopulation
\f0\fs22  methods\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf2 \expnd0\expndtw0\kerning0
\'96\'a0(No<Individual>$)addCloned(object<Individual>$\'a0parent)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Generates a new offspring individual from the given parent by clonal reproduction, queues it for addition to the target subpopulation, and returns it.  The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation life cycle stage.  The subpopulation of 
\f2\fs18 parent
\f0\fs20  will be used to locate applicable 
\f2\fs18 recombination()
\f0\fs20  and 
\f2\fs18 modifyChild()
\f0\fs20  callbacks governing the generation of the offspring individual.\
Note that this method is only for use in nonWF models.  See 
\f2\fs18 addCrossed()
\f0\fs20  for further general notes on the addition of new offspring individuals.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \'96\'a0(No<Individual>$)addCrossed(object<Individual>$\'a0parent1, object<Individual>$\'a0parent2, [Nfs$\'a0sex\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Generates a new offspring individual from the given parents by biparental sexual reproduction, queues it for addition to the target subpopulation, and returns it.  The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation life cycle stage.  Attempting to use a newly generated offspring individual as a mate, or to reference it as a member of the target subpopulation in any other way, will result in an error.  In most models the returned individual is not used, but it is provided for maximal generality and flexibility.\
The new offspring individual is generated from 
\f2\fs18 parent1
\f0\fs20  and 
\f2\fs18 parent2
\f0\fs20  by crossing them.  In sexual models 
\f2\fs18 parent1
\f0\fs20  must be female and 
\f2\fs18 parent2
\f0\fs20  must be male; in hermaphroditic models, 
\f2\fs18 parent1
\f0\fs20  and 
\f2\fs18 parent2
\f0\fs20  are unrestricted.  If 
\f2\fs18 parent1
\f0\fs20  and 
\f2\fs18 parent2
\f0\fs20  are the same individual in a hermaphroditic model, that parent self-fertilizes, or \'93selfs\'94, to generate the offspring sexually (note this is not the same as clonal reproduction).  Such selfing is considered \'93incidental\'94 by 
\f2\fs18 addCrossed()
\f0\fs20 , however; if the 
\f2\fs18 preventIncidentalSelfing
\f0\fs20  flag of 
\f2\fs18 initializeSLiMOptions()
\f0\fs20  is 
\f2\fs18 T
\f0\fs20 , supplying the same individual for 
\f2\fs18 parent1
\f0\fs20  and 
\f2\fs18 parent2
\f0\fs20  is an error (you must check for and prevent incidental selfing if you set that flag in a nonWF model).  If non-incidental selfing is desired, 
\f2\fs18 addSelfed()
\f0\fs20  should be used instead.\
The 
\f2\fs18 sex
\f0\fs20  parameter specifies the sex of the offspring.  A value of 
\f2\fs18 NULL
\f0\fs20  means \'93make the default choice\'94; in non-sexual models it is the only legal value for 
\f2\fs18 sex
\f0\fs20 , and does nothing, whereas in sexual models it causes male or female to be chosen with equal probability.  A value of 
\f2\fs18 "M"
\f0\fs20  or 
\f2\fs18 "F"
\f0\fs20  for 
\f2\fs18 sex
\f0\fs20  specifies that the offspring should be male or female, respectively.  Finally, a 
\f2\fs18 float
\f0\fs20  value from 
\f2\fs18 0.0
\f0\fs20  to 
\f2\fs18 1.0
\f0\fs20  for 
\f2\fs18 sex
\f0\fs20  provides the probability that the offspring will be male; a value of 
\f2\fs18 0.0
\f0\fs20  will produce a female, a value of 
\f2\fs18 1.0
\f0\fs20  will produce a male, and for intermediate values SLiM will draw the sex of the offspring randomly according to the specified probability.  Unless you wish the bias the sex ratio of offspring, the default value of 
\f2\fs18 NULL
\f0\fs20  should generally be used.\
Note that any defined, active, and applicable 
\f2\fs18 recombination()
\f0\fs20  and 
\f2\fs18 modifyChild()
\f0\fs20  callbacks will be called as a side effect of calling this method, before this method even returns.  For 
\f2\fs18 recombination()
\f0\fs20  callbacks, the subpopulation of the parent that is generating a given gamete is used; for 
\f2\fs18 modifyChild()
\f0\fs20  callbacks the situation is more complex.  In most biparental mating events, 
\f2\fs18 parent1
\f0\fs20  and 
\f2\fs18 parent2
\f0\fs20  will belong to the same subpopulation, and 
\f2\fs18 modifyChild()
\f0\fs20  callbacks for that subpopulation will be used, just as in WF models.  In certain models (such as models of pollen flow and broadcast spawning), however, biparental mating may occur between parents that are not from the same subpopulation; that is legal in nonWF models, and in that case, 
\f2\fs18 modifyChild()
\f0\fs20  callbacks for the subpopulation of 
\f2\fs18 parent1
\f0\fs20  are used (since that is the maternal parent).\
If the 
\f2\fs18 modifyChild()
\f0\fs20  callback process results in rejection of the proposed child (see section 19.4), a new offspring individual will not be generated, and this method will return 
\f2\fs18 NULL
\f0\fs20 .  To force the generation of an offspring individual from a given pair of parents, you could loop until 
\f2\fs18 addCrossed()
\f0\fs20  succeeds, but note that if your 
\f2\fs18 modifyChild()
\f0\fs20  callback rejects all proposed children from those particular parents, your model will then hang, so care must be taken with this approach.  Usually, nonWF models do not force generation of offspring in this manner; rejection of a proposed offspring by a 
\f2\fs18 modifyChild()
\f0\fs20  callback typically represents a phenomenon such as post-mating reproductive isolation or lethal genetic incompatibilities that would reduce the expected litter size, so the default behavior is typically desirable.\
Note that this method is only for use in nonWF models, in which offspring generation is managed manually by the model script; in such models, 
\f2\fs18 addCrossed()
\f0\fs20  must be called only from 
\f2\fs18 reproduce()
\f0\fs20  callbacks, and may not be called at any other time.  In WF models, offspring generation is managed automatically by the SLiM core.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \'96\'a0(No<Individual>$)addEmpty([Nfs$\'a0sex\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Generates a new offspring individual with empty genomes (i.e., containing no mutations), queues it for addition to the target subpopulation, and returns it.  The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation life cycle stage.  No 
\f2\fs18 recombination()
\f0\fs20  callbacks will be called.  The target subpopulation will be used to locate applicable 
\f2\fs18 modifyChild()
\f0\fs20  callbacks governing the generation of the offspring individual (unlike the other 
\f2\fs18 addX()
\f0\fs20  methods, because there is no parental individual to reference).  The offspring is considered to have no parents for the purposes of pedigree tracking.  The 
\f2\fs18 sex
\f0\fs20  parameter is treated as in 
\f2\fs18 addCrossed()
\f0\fs20 .\
Note that this method is only for use in nonWF models.  See 
\f2\fs18 addCrossed()
\f0\fs20  for further general notes on the addition of new offspring individuals.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \'96\'a0(No<Individual>$)addSelfed(object<Individual>$\'a0parent)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Generates a new offspring individual from the given parent by selfing, queues it for addition to the target subpopulation, and returns it.  The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation life cycle stage.  The subpopulation of 
\f2\fs18 parent
\f0\fs20  will be used to locate applicable 
\f2\fs18 recombination()
\f0\fs20  and 
\f2\fs18 modifyChild()
\f0\fs20  callbacks governing the generation of the offspring individual.\
Since selfing requires that 
\f2\fs18 parent
\f0\fs20  act as a source of both a male and a female gamete, this method may be called only in hermaphroditic models; calling it in sexual models will result in an error.  This method represents a non-incidental selfing event, so the 
\f2\fs18 preventIncidentalSelfing
\f0\fs20  flag of 
\f2\fs18 initializeSLiMOptions()
\f0\fs20  has no effect on this method (in contrast to the behavior of 
\f2\fs18 addCrossed()
\f0\fs20 , where selfing is assumed to be incidental).\
Note that this method is only for use in nonWF models.  See 
\f2\fs18 addCrossed()
\f0\fs20  for further general notes on the addition of new offspring individuals.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(float)cachedFitness(Ni\'a0indices)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The fitness values calculated for the individuals at the indices given are returned.  If 
\f2\fs18 NULL
\f0\fs20  is passed, fitness values for all individuals in the subpopulation are returned.  The fitness values returned are cached values; 
\f2\fs18 fitness()
\f0\fs20  callbacks are therefore not called as a side effect of this method.\cf2 \expnd0\expndtw0\kerning0
  It is always an error to call 
\f2\fs18 cachedFitness()
\f0\fs20  from inside a 
\f2\fs18 fitness()
\f0\fs20  callback, since fitness values are in the middle of being set up.  In WF models, it is also an error to call 
\f2\fs18 cachedFitness()
\f0\fs20  from a 
\f2\fs18 late()
\f0\fs20  event, because fitness values for the new offspring generation have not yet been calculated and are undefined.  In nonWF models, the population may be a mixture of new and old individuals, so instead, 
\f2\fs18 NAN
\f0\fs20  will be returned as the fitness of any new individuals whose fitness has not yet been calculated.  When new subpopulations are first created with 
\f2\fs18 addSubpop()
\f0\fs20  or 
\f2\fs18 addSubpopSplit()
\f0\fs20 , the fitness of all of the newly created individuals is considered to be 
\f2\fs18 1.0
\f0\fs20  until fitness values are recalculated.
\f3 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)defineSpatialMap(string$\'a0name, string$\'a0spatiality, Ni
\f3 \'a0
\f2 gridSize, float\'a0values, [logical$\'a0interpolate\'a0=\'a0F], [Nf\'a0valueRange\'a0=\'a0NULL], [Ns\'a0colors\'a0=\'a0NULL])\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
Defines a spatial map for the subpopulation.  The map will henceforth be identified by 
\f2\fs18 name
\f0\fs20 .  The map uses the spatial dimensions referenced by spatiality, which must be a subset of the dimensions defined for the simulation in 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .  Spatiality 
\f2\fs18 "x"
\f0\fs20  is permitted for dimensionality 
\f2\fs18 "x"
\f0\fs20 ; spatiality 
\f2\fs18 "x"
\f0\fs20 , 
\f2\fs18 "y"
\f0\fs20 , or 
\f2\fs18 "xy"
\f0\fs20  for dimensionality 
\f2\fs18 "xy"
\f0\fs20 ; and spatiality 
\f2\fs18 "x"
\f0\fs20 , 
\f2\fs18 "y"
\f0\fs20 , 
\f2\fs18 "z"
\f0\fs20 , 
\f2\fs18 "xy"
\f0\fs20 , 
\f2\fs18 "yz"
\f0\fs20 , 
\f2\fs18 "xz"
\f0\fs20 , or 
\f2\fs18 "xyz"
\f0\fs20  for dimensionality 
\f2\fs18 "xyz"
\f0\fs20 .  The spatial map is defined by a grid of values of a size specified by 
\f2\fs18 gridSize
\f0\fs20 , which must have one value per spatial dimension (or 
\f2\fs18 gridSize
\f0\fs20  may be 
\f2\fs18 NULL
\f0\fs20 ; see below); for a spatiality of 
\f2\fs18 "xz"
\f0\fs20 , for example, 
\f2\fs18 gridSize
\f0\fs20  must be of length 
\f2\fs18 2
\f0\fs20 , specifying the size of the values grid in the 
\i x
\i0  and 
\i z
\i0  dimensions.  The parameter 
\f2\fs18 values
\f0\fs20  then gives the values of the grid; it must be of length equal to the product of the 
\f2\fs18 gridSize
\f0\fs20  elements, and specifies values varying first (i.e., fastest) in the 
\i x
\i0  dimension, then in 
\i y
\i0 , then in 
\i z
\i0 .\
Beginning in SLiM 2.6, the 
\f2\fs18 values
\f0\fs20  parameter may be a matrix/array with the number of dimensions appropriate for the declared spatiality of the map; for example, a map with spatiality 
\f2\fs18 "xy"
\f0\fs20  would require a (two-dimensional) matrix, whereas a map with spatiality of 
\f2\fs18 "xyz"
\f0\fs20  would require a three-dimensional array.  (See the Eidos manual for discussion of matrices and arrays.)  If a matrix/array argument is supplied for 
\f2\fs18 values
\f0\fs20 , 
\f2\fs18 gridSize
\f0\fs20  must either be 
\f2\fs18 NULL
\f0\fs20 , or (for backward compatibility) may match the dimensions of 
\f2\fs18 values
\f0\fs20  as they would be given by 
\f2\fs18 dim(values)
\f0\fs20 .  The data in 
\f2\fs18 values
\f0\fs20  is interpreted just as is described above for the vector case: varying first in 
\i x
\i0 , then in 
\i y
\i0 , then in 
\i z
\i0 .  BEWARE: since the values in Eidos matrices and arrays are stored in column-first order (following the convention established by R), this means that for a map with spatiality 
\f2\fs18 "xy"
\f0\fs20  each column of the 
\f2\fs18 values
\f0\fs20  matrix will provide map data as 
\i x
\i0  varies and 
\i y
\i0  remains constant.  This will be confusing if you think of matrix columns as being \'93
\i x
\i0 \'94 and matrix rows as being \'93
\i y
\i0 \'94, so try not to think that way; the opposite is true.  This behavior is actually simple, self-consistent, and backward-compatible; if you before created a spatial map with a vector 
\f2\fs18 values
\f0\fs20  before and a 
\f2\fs18 gridSize
\f0\fs20  of 
\f2\fs18 c(x, y)
\f0\fs20  specifying the dimensions of that vector, you can now supply 
\f2\fs18 matrix(values, nrow=x)
\f0\fs20  for 
\f2\fs18 values
\f0\fs20  to get exactly the same spatial map, and you can still supply the same value of 
\f2\fs18 c(x, y)
\f0\fs20  for 
\f2\fs18 gridSize
\f0\fs20  if you wish (or you may supply 
\f2\fs18 NULL
\f0\fs20 ).  If, however, you are looking at a matrix as printed in the Eidos console, and want that matrix to be used as a spatial map in SLiM in the same orientation, you should use the transpose of the matrix, as supplied by the 
\f2\fs18 t()
\f0\fs20  function.  Actually, since matrices are printed in the console with each successive row having a 
\i larger
\i0  index, whereas in Cartesian (
\i x
\i0 , 
\i y
\i0 ) coordinates 
\i y
\i0 -values increase as you go 
\i upward
\i0 , you may also wish to reverse the order of rows in your matrix prior to transposing (or the order of columns after transposing), with an expression such as 
\f2\fs18 t(map[(nrow(map)-1):0,])
\f0\fs20 , in order to make the spatial map display in SLiMgui as you expect (since SLiMgui displays everything in Cartesian coordinates).  Apologies if this is confusing; it would be nice if matrix notation, programming languages, and Descartes all agreed on such things, but they do not, so be very careful that your spatial maps are oriented as you wish them to be!\
Moving on to the other parameters of 
\f2\fs18 defineSpatialMap()
\f0\fs20 : if 
\f2\fs18 interpolate
\f0\fs20  is 
\f2\fs18 F
\f0\fs20 , values across the spatial map are not interpolated; the value at a given point is equal to the nearest value defined by the grid of values specified.  If 
\f2\fs18 interpolate
\f0\fs20  is 
\f2\fs18 T
\f0\fs20 , values across the spatial map will be interpolated (using linear, bilinear, or trilinear interpolation as appropriate) to produce spatially continuous variation in values.  In either case, the corners of the value grid are exactly aligned with the corners of the spatial boundaries of the subpopulation as specified by 
\f2\fs18 setSpatialBoundary()
\f0\fs20 , and the value grid is then stretched across the spatial extent of the subpopulation in such a manner as to produce equal spacing between the values along each dimension.  The setting of 
\f2\fs18 interpolation
\f0\fs20  only affects how values between these grid points are calculated: by nearest-neighbor, or by linear interpolation.  Interpolation of spatial maps with periodic boundaries is not handled specially; to ensure that the edges of a periodic spatial map join smoothly, simply ensure that the grid values at the edges of the map are identical, since they will be coincident after periodic wrapping.\
The 
\f2\fs18 valueRange
\f0\fs20  and 
\f2\fs18 colors
\f0\fs20  parameters travel together; either both are unspecified, or both are specified.  They control how map values will be transformed into colors, by SLiMgui and by the 
\f2\fs18 spatialMapColor()
\f0\fs20  method.  The 
\f2\fs18 valueRange
\f0\fs20  parameter establishes the color-mapped range of spatial map values, as a vector of length two specifying a minimum and maximum; this does not need to match the actual range of values in the map.  The 
\f2\fs18 colors
\f0\fs20  parameter then establishes the corresponding colors for values within the interval defined by 
\f2\fs18 valueRange
\f0\fs20 : values less than or equal to 
\f2\fs18 valueRange[0]
\f0\fs20  will map to 
\f2\fs18 colors[0]
\f0\fs20 , values greater than or equal to 
\f2\fs18 valueRange[1]
\f0\fs20  will map to the last 
\f2\fs18 colors
\f0\fs20  value, and intermediate values will shade continuously through the specified vector of colors, with interpolation between adjacent colors to produce a continuous spectrum.  This is much simpler than it sounds in this description; see the recipes in chapter 14 for an illustration of its use.\
Note that at present, SLiMgui will only display spatial maps of spatiality 
\f2\fs18 "x"
\f0\fs20 , 
\f2\fs18 "y"
\f0\fs20 , or 
\f2\fs18 "xy"
\f0\fs20 ; the color-mapping parameters will simply be ignored by SLiMgui for other spatiality values (even if the spatiality is a superset of these values; SLiMgui will not attempt to display an 
\f2\fs18 "xyz"
\f0\fs20  spatial map, for example, since it has no way to choose which 2D slice through the 
\i xyz
\i0  space it ought to display).  The 
\f2\fs18 spatialMapColor()
\f0\fs20  method will return translated color strings for any spatial map, however, even if SLiMgui is unable to display the spatial map.  If there are multiple spatial maps with color-mapping parameters defined, SLiMgui will choose just one for display; it will prefer an 
\f2\fs18 "xy"
\f0\fs20  map if one is available, but beyond that heuristic its choice will be arbitrary.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96
\f3 \'a0
\f2 (+)getValue(string$\'a0key)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Returns the value previously set for the dictionary entry identifier 
\f2\fs18 key
\f0\fs20  using 
\f2\fs18 setValue()
\f0\fs20 , or 
\f2\fs18 NULL
\f0\fs20  if no value has been set.  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 Subpopulation
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)outputMSSample(integer$\'a0sampleSize, [logical$\'a0replace\'a0=\'a0T], [string$\'a0requestedSex\'a0=\'a0"*"], [Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F])
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Output a random sample from the subpopulation in MS format.  Positions in the output will span the interval [0,1].  A sample of genomes (not entire individuals, note) of size 
\f2\fs18 sampleSize
\f0\fs20  from the subpopulation will be output.  The sample may be done either with or without replacement, as specified by 
\f2\fs18 replace
\f0\fs20 ; the default is to sample with replacement.  A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing 
\f2\fs18 "M"
\f0\fs20  or 
\f2\fs18 "F"
\f0\fs20  for 
\f2\fs18 requestedSex
\f0\fs20 ; passing 
\f2\fs18 "*"
\f0\fs20 , the default, indicates that genomes from individuals should be selected randomly, without respect to sex.  If the sampling options provided by this method are not adequate, see the 
\f2\fs18 outputMS()
\f0\fs20  method of 
\f2\fs18 Genome
\f0\fs20  for a more flexible low-level option.\
If the optional parameter 
\f2\fs18 filePath
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20  (the default), output will be sent to Eidos\'92s output stream.  Otherwise, output will be sent to the filesystem path specified by 
\f2\fs18 filePath
\f0\fs20 , overwriting that file if 
\f2\fs18 append
\f0\fs20  if 
\f2\fs18 F
\f0\fs20 , or appending to the end of it if 
\f2\fs18 append
\f0\fs20  is 
\f2\fs18 T
\f3\fs20 .\

\f0 See 
\f2\fs18 outputSample()
\f0\fs20  and 
\f2\fs18 outputVCFSample()
\f0\fs20  for other output formats.  Output is generally done in a 
\f2\fs18 late()
\f0\fs20  event, so that the output reflects the state of the simulation at the end of a generation.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)outputSample(integer$\'a0sampleSize, [logical$\'a0replace\'a0=\'a0T], [string$\'a0requestedSex\'a0=\'a0"*"], [Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F])
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Output a random sample from the subpopulation in SLiM\'92s native format.  A sample of genomes (not entire individuals, note) of size 
\f2\fs18 sampleSize
\f0\fs20  from the subpopulation will be output.  The sample may be done either with or without replacement, as specified by 
\f2\fs18 replace
\f0\fs20 ; the default is to sample with replacement.  A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing 
\f2\fs18 "M"
\f0\fs20  or 
\f2\fs18 "F"
\f0\fs20  for 
\f2\fs18 requestedSex
\f0\fs20 ; passing 
\f2\fs18 "*"
\f0\fs20 , the default, indicates that genomes from individuals should be selected randomly, without respect to sex.  If the sampling options provided by this method are not adequate, see the 
\f2\fs18 output()
\f0\fs20  method of 
\f2\fs18 Genome
\f0\fs20  for a more flexible low-level option.\
If the optional parameter 
\f2\fs18 filePath
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20  (the default), output will be sent to Eidos\'92s output stream.  Otherwise, output will be sent to the filesystem path specified by 
\f2\fs18 filePath
\f0\fs20 , overwriting that file if 
\f2\fs18 append
\f0\fs20  if 
\f2\fs18 F
\f0\fs20 , or appending to the end of it if 
\f2\fs18 append
\f0\fs20  is 
\f2\fs18 T
\f3\fs20 .\

\f0 See 
\f2\fs18 outputMSSample()
\f0\fs20  and 
\f2\fs18 outputVCFSample()
\f0\fs20  for other output formats.  Output is generally done in a 
\f2\fs18 late()
\f0\fs20  event, so that the output reflects the state of the simulation at the end of a generation.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)outputVCFSample(integer$\'a0sampleSize, [logical$\'a0replace\'a0=\'a0T], [string$\'a0requestedSex\'a0=\'a0"*"], [logical$\'a0outputMultiallelics\'a0=\'a0T], [Ns$\'a0filePath\'a0=\'a0NULL], [logical$\'a0append\'a0=\'a0F])
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Output a random sample from the subpopulation in VCF format.  A sample of individuals (not genomes, note \'96 unlike the 
\f2\fs18 outputSample()
\f0\fs20  and 
\f2\fs18 outputMSSample()
\f0\fs20  methods) of size 
\f2\fs18 sampleSize
\f0\fs20  from the subpopulation will be output.  The sample may be done either with or without replacement, as specified by 
\f2\fs18 replace
\f0\fs20 ; the default is to sample with replacement.  A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing 
\f2\fs18 "M"
\f0\fs20  or 
\f2\fs18 "F"
\f0\fs20  for 
\f2\fs18 requestedSex
\f0\fs20 ; passing 
\f2\fs18 "*"
\f0\fs20 , the default, indicates that genomes from individuals should be selected randomly, without respect to sex.  If the sampling options provided by this method are not adequate, see the 
\f2\fs18 outputVCF()
\f0\fs20  method of 
\f2\fs18 Genome
\f0\fs20  for a more flexible low-level option.\
In SLiM, it is often possible for a single individual to have multiple mutations at a given base position.  Because the VCF format is an explicit-nucleotide format, this property of SLiM does not fit well into VCF.  Since there are only four possible nucleotides at a given base position in VCF, at most one \'93reference\'94 state and three \'93alternate\'94 states could be represented at that base position.  SLiM, on the other hand, can represent any number of alternative possibilities at a given base; in general, if 
\i N
\i0  different mutations are segregating at a given position, there are 2
\i \super N
\i0 \nosupersub  different allelic states at that position in SLiM.  For this reason, SLiM does not attempt to represent multiple mutations at a single site as being alternative alleles in a single output line, as is typical in VCF format.  Instead, SLiM produces a separate line of VCF output for each segregating mutation at a given position.  SLiM always declares base positions as having a \'93reference base\'94 of 
\f2\fs18 A
\f0\fs20  (representing the state in individuals that do not carry a given mutation) and an \'93alternate base\'94 of 
\f2\fs18 T
\f0\fs20  (representing the state in individuals that do carry the given mutation).  Multiallelic positions will thus produce VCF output showing multiple 
\f2\fs18 A
\f0\fs20 -to-
\f2\fs18 T
\f0\fs20  changes at the same position, possessed by different but possibly overlapping sets of individuals.  Many programs that process VCF output may not behave correctly with this style of output.  SLiM therefore provides a choice, using the 
\f2\fs18 outputMultiallelics
\f0\fs20  flag; if that flag is 
\f2\fs18 T
\f0\fs20  (the default), SLiM will produce multiple lines of output for multiallelic base positions, but will mark those lines with a 
\f2\fs18 MULTIALLELIC
\f0\fs20  flag in the 
\f2\fs18 INFO
\f0\fs20  field of the VCF output so that those lines can be filtered or processed in a special manner.  If 
\f2\fs18 outputMultiallelics
\f0\fs20  is 
\f2\fs18 F
\f0\fs20 , on the other hand, SLiM will completely suppress output of all mutations at multiallelic sites \'96 often the simplest option, if doing so does not lead to bias in the subsequent analysis.  This flag has no effect upon the output of sites with only a single mutation present.  Assessment of whether a site is multiallelic is done only within the sample; segregating mutations that are not part of the sample are ignored.\
If the optional parameter 
\f2\fs18 filePath
\f0\fs20  is 
\f2\fs18 NULL
\f0\fs20  (the default), output will be sent to Eidos\'92s output stream.  Otherwise, output will be sent to the filesystem path specified by 
\f2\fs18 filePath
\f0\fs20 , overwriting that file if 
\f2\fs18 append
\f0\fs20  if 
\f2\fs18 F
\f0\fs20 , or appending to the end of it if 
\f2\fs18 append
\f0\fs20  is 
\f2\fs18 T
\f3\fs20 .\

\f0 See 
\f2\fs18 outputMSSample()
\f0\fs20  and 
\f2\fs18 outputSample()
\f0\fs20  for other output formats.  Output is generally done in a 
\f2\fs18 late()
\f0\fs20  event, so that the output reflects the state of the simulation at the end of a generation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(logical)pointInBounds(float\'a0point)
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns 
\f2\fs18 T
\f0\fs20  if 
\f2\fs18 point
\f0\fs20  is inside the spatial boundaries of the subpopulation, 
\f2\fs18 F
\f0\fs20  otherwise.  For example, for a simulation with 
\f2\fs18 "xy"
\f0\fs20  dimensionality, if 
\f2\fs18 point
\f0\fs20  contains exactly two values constituting an (
\i x
\i0 ,
\i y
\i0 ) point, the result will be 
\f2\fs18 T
\f0\fs20  if and only if 
\f2\fs18 ((point[0]>=x0) & (point[0]<=x1) & (point[1]>=y0) & (point[1]<=y1))
\f0\fs20  given spatial bounds 
\f2\fs18 (x0, y0, x1, y1)
\f0\fs20 .  This method is useful for implementing absorbing or reprising boundary conditions.  This may only be called in simulations for which continuous space has been enabled with 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .\
The length of 
\f2\fs18 point
\f0\fs20  must be an exact multiple of the dimensionality of the simulation; in other words, 
\f2\fs18 point
\f0\fs20  may contain values comprising more than one point.  In this case, a 
\f2\fs18 logical
\f0\fs20  vector will be returned in which each element is 
\f2\fs18 T
\f0\fs20  if the corresponding point in 
\f2\fs18 point
\f0\fs20  is inside the spatial boundaries of the subpopulation, 
\f2\fs18 F
\f0\fs20  otherwise.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \'96\'a0(float)pointPeriodic(float\'a0point)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns a revised version of 
\f2\fs18 point
\f0\fs20  that has been brought inside the periodic spatial boundaries of the subpopulation (as specified by the 
\f2\fs18 periodicity
\f0\fs20  parameter of 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 ) by wrapping around periodic spatial boundaries.  In brief, if a coordinate of 
\f2\fs18 point
\f0\fs20  lies beyond a periodic spatial boundary, that coordinate is wrapped around the boundary, so that it lies inside the spatial extent by the same magnitude that it previously lay outside, but on the opposite side of the space; in effect, the two edges of the periodic spatial boundary are seamlessly joined.  This is done iteratively until all coordinates lie inside the subpopulation\'92s periodic boundaries.  Note that non-periodic spatial boundaries are not enforced by this method; they should be enforced using 
\f2\fs18 pointReflected()
\f0\fs20 , 
\f2\fs18 pointStopped()
\f0\fs20 , or some other means of enforcing boundary constraints (which can be used after 
\f2\fs18 pointPeriodic()
\f0\fs20  to bring the remaining coordinates into bounds; coordinates already brought into bounds by 
\f2\fs18 pointPeriodic()
\f0\fs20  will be unaffected by those calls).  This method is useful for implementing periodic boundary conditions.  This may only be called in simulations for which continuous space  and at least one periodic spatial dimension have been enabled with 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .\
The length of 
\f2\fs18 point
\f0\fs20  must be an exact multiple of the dimensionality of the simulation; in other words, 
\f2\fs18 point
\f0\fs20  may contain values comprising more than one point.  In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \'96\'a0(float)pointReflected(float\'a0point)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns a revised version of 
\f2\fs18 point
\f0\fs20  that has been brought inside the spatial boundaries of the subpopulation by reflection.  In brief, if a coordinate of 
\f2\fs18 point
\f0\fs20  lies beyond a spatial boundary, that coordinate is reflected across the boundary, so that it lies inside the boundary by the same magnitude that it previously lay outside the boundary.  This is done iteratively until all coordinates lie inside the subpopulation\'92s boundaries.  This method is useful for implementing reflecting boundary conditions.  This may only be called in simulations for which continuous space has been enabled with 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .\
The length of 
\f2\fs18 point
\f0\fs20  must be an exact multiple of the dimensionality of the simulation; in other words, 
\f2\fs18 point
\f0\fs20  may contain values comprising more than one point.  In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \'96\'a0(float)pointStopped(float\'a0point)\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns a revised version of 
\f2\fs18 point
\f0\fs20  that has been brought inside the spatial boundaries of the subpopulation by clamping.  In brief, if a coordinate of 
\f2\fs18 point
\f0\fs20  lies beyond a spatial boundary, that coordinate is set to exactly the position of the boundary, so that it lies on the edge of the spatial boundary.  This method is useful for implementing stopping boundary conditions.  This may only be called in simulations for which continuous space has been enabled with 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .\
The length of 
\f2\fs18 point
\f0\fs20  must be an exact multiple of the dimensionality of the simulation; in other words, 
\f2\fs18 point
\f0\fs20  may contain values comprising more than one point.  In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \'96\'a0(float)pointUniform([integer$\'a0n\'a0=\'a01])\
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Returns a new point (or points, for 
\f2\fs18 n
\f0\fs20  > 1) generated from uniform draws for each coordinate, within the spatial boundaries of the subpopulation.  The returned vector will contain 
\f2\fs18 n
\f0\fs20  points, each comprised of a number of coordinates equal to the dimensionality of the simulation, so it will be of total length 
\f2\fs18 n
\f0\fs20 *dimensionality.  This may only be called in simulations for which continuous space has been enabled with 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(void)removeSubpopulation(void)
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
Removes this subpopulation from the model.  The subpopulation is immediately removed from the list of active subpopulations, and the symbol representing the subpopulation is undefined.  The subpopulation object itself remains unchanged until children are next generated (at which point it is deallocated), but it is no longer part of the simulation and should not be used.\
Note that this method is only for use in nonWF models, in which there is a distinction between a subpopulation being empty and a subpopulation being removed from the simulation; an empty subpopulation may be re-colonized by migrants, whereas as a removed subpopulation no longer exists at all.  WF models do not make this distinction; when a subpopulation is empty it is automatically removed.  WF models should therefore call 
\f2\fs18 setSubpopulationSize(0)
\f0\fs20  instead of this method; 
\f2\fs18 setSubpopulationSize()
\f0\fs20  is the standard way for WF models to change the subpopulation size, including to a size of 
\f2\fs18 0
\f0\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0\cf2 \expnd0\expndtw0\kerning0
(object<Individual>)sampleIndividuals(integer$\'a0size, [logical$\'a0replace\'a0=\'a0F], [No<Individual>$\'a0exclude\'a0=\'a0NULL], [Ns$\'a0sex\'a0=\'a0NULL], [Ni$\'a0tag\'a0=\'a0NULL], [Ni$\'a0minAge\'a0=\'a0NULL], [Ni$\'a0maxAge\'a0=\'a0NULL])
\f3 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns a vector of individuals, of size less than or equal to parameter 
\f2\fs18 size
\f0\fs20 , sampled from the individuals in the target subpopulation.  Sampling is done without replacement if 
\f2\fs18 replace
\f0\fs20  is 
\f2\fs18 F
\f0\fs20  (the default), or with replacement if 
\f2\fs18 replace
\f0\fs20  is 
\f2\fs18 T
\f0\fs20 .  The remaining parameters specify constraints upon the pool of individuals that will be considered candidates for the sampling.  Parameter 
\f2\fs18 exclude
\f0\fs20 , if non-
\f2\fs18 NULL
\f0\fs20 , may specify a specific individual that should not be considered a candidate (typically the focal individual in some operation).  Parameter 
\f2\fs18 sex
\f0\fs20 , if non-
\f2\fs18 NULL
\f0\fs20 , may specify a sex (
\f2\fs18 "M"
\f0\fs20  or 
\f2\fs18 "F"
\f0\fs20 ) for the individuals to be drawn, in sexual models.  Parameter 
\f2\fs18 tag
\f0\fs20 , if non-
\f2\fs18 NULL
\f0\fs20 , may specify a tag value for the individuals to be drawn; only individuals whose 
\f2\fs18 tag
\f0\fs20  property matches this value will be candidates.  Parameters 
\f2\fs18 minAge
\f0\fs20  and 
\f2\fs18 maxAge
\f0\fs20 , if non-
\f2\fs18 NULL
\f0\fs20 , may specify a minimum or maximum age for the individuals to be drawn, in nonWF models.  If the candidate pool is smaller than the requested sample size, all eligible candidates will be returned (in randomized order); the result will be a zero-length vector if no eligible candidates exist (unlike 
\f2\fs18 sample()
\f0\fs20 ).\
This method is similar to getting the 
\f2\fs18 individuals
\f0\fs20  property of the subpopulation, using operator 
\f2\fs18 []
\f0\fs20  to select only individuals with the desired properties, and then using 
\f2\fs18 sample()
\f0\fs20  to sample from that candidate pool.  However, besides being much simpler than the equivalent Eidos code, it is also much faster, and it does not fail if less than the full sample size is available.  See 
\f2\fs18 subsetIndividuals()
\f0\fs20  for a similar method that returns a full subset, rather than a sample.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0\cf2 \expnd0\expndtw0\kerning0
(object<Individual>)subsetIndividuals([No<Individual>$\'a0exclude\'a0=\'a0NULL], [Ns$\'a0sex\'a0=\'a0NULL], [Ni$\'a0tag\'a0=\'a0NULL], [Ni$\'a0minAge\'a0=\'a0NULL], [Ni$\'a0maxAge\'a0=\'a0NULL])
\f3 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
Returns a vector of individuals subset from the individuals in the target subpopulation.  The parameters specify constraints upon the subset of individuals that will be returned.  Parameter 
\f2\fs18 exclude
\f0\fs20 , if non-
\f2\fs18 NULL
\f0\fs20 , may specify a specific individual that should not be included (typically the focal individual in some operation).  Parameter 
\f2\fs18 sex
\f0\fs20 , if non-
\f2\fs18 NULL
\f0\fs20 , may specify a sex (
\f2\fs18 "M"
\f0\fs20  or 
\f2\fs18 "F"
\f0\fs20 ) for the individuals to be returned, in sexual models.  Parameter 
\f2\fs18 tag
\f0\fs20 , if non-
\f2\fs18 NULL
\f0\fs20 , may specify a tag value for the individuals to be returned; only individuals whose 
\f2\fs18 tag
\f0\fs20  property matches this value will be returned.  Parameters 
\f2\fs18 minAge
\f0\fs20  and 
\f2\fs18 maxAge
\f0\fs20 , if non-
\f2\fs18 NULL
\f0\fs20 , may specify a minimum or maximum age for the individuals to be returned, in nonWF models.\
This method is shorthand for getting the 
\f2\fs18 individuals
\f0\fs20  property of the subpopulation, and then using operator 
\f2\fs18 []
\f0\fs20  to select only individuals with the desired properties; besides being much simpler than the equivalent Eidos code, it is also much faster.  See 
\f2\fs18 sampleIndividuals()
\f0\fs20  for a similar method that returns a sample taken from a chosen subset of individuals.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \kerning1\expnd0\expndtw0 \'96\'a0(void)setCloningRate(numeric\'a0rate)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the cloning rate of this subpopulation.  The rate is changed to 
\f2\fs18 rate
\f0\fs20 , which should be between 0.0 and 1.0, inclusive (see the SLiM manual for further details).  Clonal reproduction can be enabled in both non-sexual (i.e. hermaphroditic) and sexual simulations.  In non-sexual simulations, 
\f2\fs18 rate
\f0\fs20  must be a singleton value representing the overall clonal reproduction rate for the subpopulation.  In sexual simulations, 
\f2\fs18 rate
\f0\fs20  may be either a singleton (specifying the clonal reproduction rate for both sexes) or a vector containing two numeric values (the female and male cloning rates specified separately, at indices 
\f2\fs18 0
\f0\fs20  and 
\f2\fs18 1
\f0\fs20  respectively).  During mating and offspring generation, the probability that any given offspring individual will be generated by cloning \'96 by asexual reproduction without gametes or meiosis \'96 will be equal to the cloning rate (for its sex, in sexual simulations) set in the parental (not the offspring!) subpopulation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)setMigrationRates(io<Subpopulation>\'a0sourceSubpops, numeric\'a0rates)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the migration rates to this subpopulation from the subpopulations in 
\f2\fs18 sourceSubpops
\f0\fs20  to the corresponding rates specified in 
\f2\fs18 rates
\f0\fs20 ; in other words, 
\f2\fs18 rates
\f0\fs20  gives the expected fractions of the children in this subpopulation that will subsequently be generated from parents in the subpopulations 
\f2\fs18 sourceSubpops
\f0\fs20  (see the SLiM manual for further details).  This method will only set the migration fractions from the subpopulations given; migration rates from other subpopulations will be left unchanged (explicitly set a zero rate to turn off migration from a given subpopulation).  The type of 
\f2\fs18 sourceSubpops
\f0\fs20  may be either 
\f2\fs18 integer
\f0\fs20 , specifying subpopulations by identifier, or 
\f2\fs18 object
\f0\fs20 , specifying subpopulations directly.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)setSelfingRate(numeric$\'a0rate)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the selfing rate of this subpopulation.  The rate is changed to 
\f2\fs18 rate
\f0\fs20 , which should be between 0.0 and 1.0, inclusive (see the SLiM manual for further details).  Selfing can only be enabled in non-sexual (i.e. hermaphroditic) simulations.  During mating and offspring generation, the probability that any given offspring individual will be generated by selfing \'96 by self-fertilization via gametes produced by meiosis by a single parent \'96 will be equal to the selfing rate set in the parental (not the offspring!) subpopulation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)setSexRatio(float$\'a0sexRatio)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the sex ratio of this subpopulation to 
\f2\fs18 sexRatio
\f0\fs20 .  As defined in SLiM, this is actually the fraction of the subpopulation that is male; in other words, the M:(M+F) ratio.  This will take effect when children are next generated; it does not change the current subpopulation state.  Unlike the selfing rate, the cloning rate, and migration rates, the sex ratio is deterministic: SLiM will generate offspring that exactly satisfy the requested sex ratio (within integer roundoff limits).
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)setSpatialBounds(float\'a0bounds)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
Set the spatial boundaries of the subpopulation to 
\f2\fs18 bounds
\f0\fs20 .  This method may be called only for simulations in which continuous space has been enabled with 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 .  The length of 
\f2\fs18 bounds
\f0\fs20  must be double the spatial dimensionality, so that it supplies both minimum and maximum values for each coordinate.  More specifically, for a dimensionality of 
\f2\fs18 "x"
\f0\fs20 , 
\f2\fs18 bounds
\f0\fs20  should supply 
\f2\fs18 (x0,\'a0x1)
\f0\fs20  values; for dimensionality 
\f2\fs18 "xy"
\f0\fs20  it should supply 
\f2\fs18 (x0,\'a0y0,\'a0x1,\'a0y1)
\f0\fs20  values; and for dimensionality 
\f2\fs18 "xyz"
\f0\fs20  it should supply 
\f2\fs18 (x0,\'a0y0,\'a0z0,\'a0x1,\'a0y1,\'a0z1)
\f0\fs20  (in that order).  These boundaries will be used by SLiMgui to calibrate the display of the subpopulation, and will be used by methods such as 
\f2\fs18 pointInBounds()
\f0\fs20 , 
\f2\fs18 pointReflected()
\f0\fs20 , 
\f2\fs18 pointStopped()
\f0\fs20 , and 
\f2\fs18 pointUniform()
\f0\fs20 .  The default spatial boundaries for all subpopulations span the interval 
\f2\fs18 [0,1]
\f0\fs20  in each dimension.  Spatial dimensions that are periodic (as established with the 
\f2\fs18 periodicity
\f0\fs20  parameter to 
\f2\fs18 initializeSLiMOptions()
\f0\fs20 ) must have a minimum coordinate value of 
\f2\fs18 0.0
\f0\fs20  (a restriction that allows the handling of periodicity to be somewhat more efficient).  The current spatial bounds for the subpopulation may be obtained through the 
\f2\fs18 spatialBounds
\f0\fs20  property.\cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96\'a0(void)setSubpopulationSize(integer$\'a0size)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Set the size of this subpopulation to 
\f2\fs18 size
\f0\fs20  individuals (see the SLiM manual for further details).  This will take effect when children are next generated; it does not change the current subpopulation state.  Setting a subpopulation to a size of 0 does have some immediate effects that serve to disconnect it from the simulation: the subpopulation is removed from the list of active subpopulations, the subpopulation is removed as a source of migration for all other subpopulations, and the symbol representing the subpopulation is undefined.  In this case, the subpopulation itself remains unchanged until children are next generated (at which point it is deallocated), but it is no longer part of the simulation and should not be used.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (void)setValue(string$\'a0key, +\'a0value)
\f3 \
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Sets a value for the dictionary entry identifier 
\f2\fs18 key
\f3\fs20 .
\f0   The value, which may be of any type other than 
\f2\fs18 object
\f0\fs20 , can be fetched later using 
\f2\fs18 getValue()
\f0\fs20 .  This dictionary-style functionality is actually provided by the superclass of 
\f2\fs18 Subpopulation
\f0\fs20 , 
\f2\fs18 SLiMEidosDictionary
\f0\fs20 , although that fact is not presently visible in Eidos since superclasses are not introspectable.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (string)spatialMapColor(string$\'a0name, float\'a0value)
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 Looks up the spatial map indicated by 
\f2\fs18 name
\f0\fs20 , and uses its color-translation machinery (as defined by the 
\f2\fs18 valueRange
\f0\fs20  and 
\f2\fs18 colors
\f0\fs20  parameters to 
\f2\fs18 defineSpatialMap()
\f0\fs20 ) to translate each element of 
\f2\fs18 value
\f0\fs20  into a corresponding color string.  If the spatial map does not have color-translation capabilities, an error will result.  See the documentation for 
\f2\fs18 defineSpatialMap()
\f0\fs20  for information regarding the details of color translation.  See the Eidos manual for further information on color strings.
\f3 \
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 \'96
\f3 \'a0
\f2 (float$)spatialMapValue(string$\'a0name, float\'a0point)
\f3 \
\pard\pardeftab397\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 \expnd0\expndtw0\kerning0
Looks up the spatial map indicated by 
\f2\fs18 name
\f0\fs20 , and uses its mapping machinery (as defined by the 
\f2\fs18 gridSize
\f0\fs20 , 
\f2\fs18 values
\f0\fs20 , and 
\f2\fs18 interpolate
\f0\fs20  parameters to 
\f2\fs18 defineSpatialMap()
\f0\fs20 ) to translate the coordinates of 
\f2\fs18 point
\f0\fs20  into a corresponding map value.  The length of 
\f2\fs18 point
\f0\fs20  must be equal to the spatiality of the spatial map; in other words, for a spatial map with spatiality 
\f2\fs18 "xz"
\f0\fs20 , 
\f2\fs18 point
\f0\fs20  must be of length 
\f2\fs18 2
\f0\fs20 , specifying the 
\i x
\i0  and 
\i z
\i0  coordinates of the point to be evaluated.  Interpolation will automatically be used if it was enabled for the spatial map.  Point coordinates are clamped into the range defined by the spatial boundaries, even if the spatial boundaries are periodic; use 
\f2\fs18 pointPeriodic()
\f0\fs20  to wrap the point coordinates first if desired.  See the documentation for 
\f2\fs18 defineSpatialMap()
\f0\fs20  for information regarding the details of value mapping.\
\pard\pardeftab397\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf2 \'96\'a0(void)takeMigrants(object<Individual>\'a0migrants)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf2 Immediately moves the individuals in 
\f2\fs18 migrants
\f0\fs20  to the target subpopulation (removing them from their previous subpopulation).  Individuals in 
\f2\fs18 migrants
\f0\fs20  that are already in the target subpopulation are unaffected.  Note that the indices and order of individuals and genomes in both the target and source subpopulations will change unpredictably as a side effect of this method.\
Note that this method is only for use in nonWF models, in which migration is managed manually by the model script.  In WF models, migration is managed automatically by the SLiM core based upon the migration rates set for each subpopulation with 
\f2\fs18 setMigrationRates()
\f0\fs20 .
\f3 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\ri720\sb360\sa60\partightenfactor0

\f0\b\fs22 \cf0 5.13  Class Substitution\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\b0 \cf0 5.13.1  
\f1\fs18 Substitution
\f0\fs22  properties\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\i0\fs18 \cf0 id => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The identifier for this mutation.  Each mutation created during a run receives an immutable identifier that will be unique across the duration of the run, and that identifier is carried over to the 
\f2\fs18 Substitution
\f0\fs20  object when the mutation fixes.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 fixationGeneration => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The generation in which this mutation fixed.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 mutationType => (object<MutationType>$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The 
\f2\fs18 MutationType
\f0\fs20  from which this mutation was drawn.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 originGeneration => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The generation in which this mutation arose.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 position => (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The position in the chromosome of this mutation.
\f3 \
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 selectionCoeff => (float$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The selection coefficient of the mutation, drawn from the distribution of fitness effects of its 
\f2\fs18 MutationType
\f3\fs20 .\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 subpopID <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 The identifier of the subpopulation in which this mutation arose.  This value is carried over from the 
\f2\fs18 Mutation
\f0\fs20  object directly; if a \'93tag\'94 value was used in the 
\f2\fs18 Mutation
\f0\fs20  object, that value will carry over to the corresponding 
\f2\fs18 Substitution
\f0\fs20  object.  The 
\f2\fs18 subpopID
\f0\fs20  in 
\f2\fs18 Substitution
\f0\fs20  is a read-write property to allow it to be used as a \'93tag\'94 in the same way, if the origin subpopulation identifier is not needed.\
\pard\pardeftab720\li720\fi-446\ri720\sb180\sa60\partightenfactor0

\f2\fs18 \cf0 tag <\'96> (integer$)\
\pard\pardeftab720\li547\ri720\sb60\sa60\partightenfactor0

\f0\fs20 \cf0 A user-defined 
\f2\fs18 integer
\f0\fs20  value.  The value of 
\f2\fs18 tag
\f0\fs20  is carried over automatically from the original 
\f2\fs18 Mutation
\f0\fs20  object.  Apart from that, the value of 
\f2\fs18 tag
\f0\fs20  is not used by SLiM; it is free for you to use.\
\pard\pardeftab720\ri720\sb120\sa60\partightenfactor0

\i\fs22 \cf0 5.13.2  
\f1\fs18 Substitution
\f0\fs22  methods\
\pard\pardeftab397\fi274\ri720\sb40\sa40\partightenfactor0

\f3\i0 \cf0 \
}